---
layout: post
title:  "计算机发展史-Computer History"
date:   2010-07-26 23:42:00
categories: 计算机基础
tags: 高德纳 图灵 冯·诺依曼 陈皓 少儿编程 网络 操作系统 体系结构 CPU arm x86 OSI 进程 线程 协程 编程语言
excerpt: 计算机发展历史，编程语言诞生过程，及几位关键人物
mathjax: true
---

* content
{:toc}

# 总结

-【2022-2-28】MIT出品的The Missing Semester of Your CS Education的[中文翻译地址](http://missing-semester-cn.github.io/),讲授shell命令行、强大的文本编辑器vim的使用、使用版本控制系统git提供的多种特性, 调试性能分析，元编程，密码学，大杂烩等等。
- 【2021-6-16】[你管这玩意儿叫CPU？](https://www.toutiao.com/i6974241663241683463/). 过去200年人类最重要的发明是什么？蒸汽机？电灯？火箭？这些可能都不是，最重要的是晶体管,无论程序员编写的程序多么复杂，软件承载的功能最终都是通过这个小东西简单的开闭完成的. 组成与或非门。
- 【2021-3-31】[图灵奖今日出炉](https://mp.weixin.qq.com/s/Q6kbBomC85xbmKS2SLllfA)，“龙书” 作者、编程语言大佬 Alfred Aho 和 Jeffrey Ullman 获奖
- 【2020-10-29】源自linux之父的名言：**talk is cheap，show me the code**，汉化版：**北沙滩**（别瞎谈），**亮马桥**（亮码瞧）
- 计算机网络里的 **OSI七层模型** 或 **TCP/IP五层模型**，即应用层（应用层、表示层、会话层）、传输层、网络层、数据链路层、物理层
![](https://pic4.zhimg.com/50/v2-6531ff0d8cbf967211297ef7c7813ab1_hd.jpg)

- [OSI七层模型](https://www.toutiao.com/w/a1701287080764423/)

![](https://p5.toutiaoimg.com/img/tos-cn-i-0022/d2916c97afc94b9daa01bdaca34759a0~tplv-obj:1575:2227.image?from=post)

# 计算机编程史

[计算机编程简史](https://coolshell.cn/articles/2724.html)

- 一张经典的图揭示计算机发展历史，可以看到，其中很大一部分人都和Unix有着不解之缘
  - 参见《[Unix传奇上篇](https://coolshell.cn/articles/2322.html)，[Unix传奇下篇](https://coolshell.cn/articles/2324.html)》
 
*   [英文原版](http://www.smashingmagazine.com/2010/06/06/designing-the-world-of-programming-infographic/)
*   [中文翻译版](http://www.mazingtech.com/cn/list.aspx/News/1/%E5%9B%BE%E8%AF%B4%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B%E7%AE%80%E5%8F%B2)

计算机编程简史图（英文版）（中文版）

|英文|中文|
|---|---|
|[![](https://coolshell.cn/wp-content/uploads/2010/07/aboutprogramming04.eng_-409x1024.jpg "计算机编程简史图（英文版） ")](https://coolshell.cn/wp-content/uploads/2010/07/aboutprogramming04.eng_.jpg)|[![](https://coolshell.cn/wp-content/uploads/2010/07/aboutprogramming04_cn-409x1024.jpg "计算机编程简史图（中文版） ")](https://coolshell.cn/wp-content/uploads/2010/07/aboutprogramming04_cn.jpg)|
|||


## 计算机之父

- “计算机之父”这种笼统的称谓没有明确的结果。你可以认为是图灵，也可以认为是冯·诺依曼，你认为是谁就是谁。
- 非要叫的话可以是：
   - `巴贝奇`Charles Babbage——**通用计算机**之父
      - 巴贝奇在1834年所构思的分析机（通用计算机），就已有了计算机的五个部分：处理器、控制器、存储器、输入与输出装置，而不是到了冯·诺依曼才提出的。
      - 生活在机械时代，却构思出了完整的计算机结构，领先世界一百年。
      - [机械美学：差分机的运作](https://v.qq.com/x/page/i0164fo4om1.html)
      - <iframe frameborder="0" src="https://v.qq.com/txp/iframe/player.html?vid=d0319t31fw9" allowFullScreen="true" height="600" width="100%"></iframe>
   - `图灵`Alan Turing——**计算机科学**之父
      - 图灵在现在毫无疑问是名气最大的，有套书以他命名，还有个公司用他咬过的苹果做logo。
      - 图灵也是个天才，他的工作非常有开创性，系统建构了计算机科学的基础，提出了图灵机、图灵测试，所以被称为“计算机科学之父”。
   - `约翰·阿坦那索夫`John Vincent Atanasoff——**电子计算机**之父
      - 阿坦纳索夫和克利福德·贝瑞在1939年制造了`ABC机`。
      - 在电子时代，作为第一台电子计算机的发明者，拔得了头筹，也够资格被称为“电子计算机之父”了。
      - 那时也已经开始使用二进制了，所以二进制也不是冯·诺依曼首创的。
   - `冯·诺依曼`John von Neumann——**现代计算机**之父
      - 在科学界名声很响，有许多开创性的工作，包括数学、量子力学、计算机和经济学领域。
      - 他对二战的贡献很大，不仅参与原子弹研制，还对ENIAC作了关键改进。
      - 另外他还最终完善了计算机的模型，提出冯诺依曼机，奠定了我们现代所使用的计算机的基础。所以把冯诺依曼称为“现代计算机之父”是实至名归的。

- 参考作者：[滑稽现实主义](https://www.zhihu.com/question/27883465/answer/93161520)


## 图灵

- ![](https://pic2.zhimg.com/80/v2-acdf678e24dba6143bc5cfeea626afb0_720w.jpg)

### 成长经历

- 艾伦·麦席森·图灵（英语：Alan Mathison Turing，1912年6月23日—1954年6月7日），英国数学家、逻辑学家，被称为计算机科学之父，人工智能之父。
- 1931年图灵进入剑桥大学国王学院，毕业后到美国普林斯顿大学攻读博士学位，第二次世界大战爆发后回到剑桥，后曾协助军方破解德国的著名密码系统Enigma，帮助盟军取得了二战的胜利。
- 1952年，英国政府对图灵的同性恋取向定罪，随后图灵接受化学阉割（雌激素注射）。
- 1954年6月7日，图灵吃下含有氰化物的苹果中毒身亡，享年41岁。
- 2013年12月24日，在英国司法大臣克里斯·格雷灵的要求下，英国女王伊丽莎白二世向图灵颁发了皇家赦免。
- 图灵对于人工智能的发展有诸多贡献，提出了一种用于判定机器是否具有智能的试验方法，即图灵试验，至今，每年都有试验的比赛。此外，图灵提出的著名的图灵机模型为现代计算机的逻辑工作方式奠定了基础。

1912年6月23日，图灵出生于英国帕丁顿一个没落的贵族家庭，由于父母常年在印度工作，他和年长4岁的哥哥一起被寄养在一对军人夫妇的家中。图灵的童年十分平凡，和普通男孩一样，经历过**调皮捣蛋**和**孤僻寡言**的的阶段，他天性聪敏却有着严重**偏科**的倾向，许多教过他的老师对他的评价并不高。

10岁那年，图灵接触到一本改变了他一生的童书——《**儿童必读的自然奇迹**》，这本科普读物打开了一扇新世界的大门，图灵发现门的那边堆满了一种对他来说最有吸引力的知识——**科学**。他开始**疯狂**地寻找和自学有关科学的一切知识，并用日用品做一些简单的化学实验。他很快意识到手头的科普读物过于浅显，妨碍了他了解事物背后更深层的原理。他甚至写信给父母讨要真正的科学书籍，而不是儿童百科。他写到：“《儿童必读的自然奇迹》中说，二氧化碳在血液里变成苏打，又在肺里变回二氧化碳。如果可以，请把苏打的化学名称，最好是化学式寄给我，好让我看看这个过程到底是怎么进行的。” 13岁时，他已经对酒精等有机物的分子式和结构式了如指掌。

1926年，聪明好学而又对科学知识近乎偏执的图灵考入了舍尔伯尼中学。开学当天正赶上英国大罢工，公共交通瘫痪，图灵竟用两天时间靠自行车征服了到学校的60英里（近100公里）路程。这不是一次冲动之举，而是精心策划之下的行动，当地报纸还专门刊载了这一令人吃惊的事迹。

图灵很有才，也很有**执行力**，却在与人沟通上遇到了大麻烦。知子莫若母，图灵的母亲在为他寻找合适的中学时就一度担心他没法适应公学生活，成长为高智商、低情商的怪人。在讲究教条与制度而不重视理性和科学的舍尔伯尼，图灵显得格格不入，被多数同学孤立和欺负，连老师也经常拿他的小习惯开涮，这对一个心智尚未成熟的男孩来说非常可怕。他们的校长倒看得十分透彻，曾警告图灵的父母：“我希望他不要两头都落空。如果他要留在公学，就必须以好好接受我们的教育为目标；如果他只是想做科学家，那么呆在公学就是浪费时间。”

舍尔伯尼是当时英国社会的一个缩影，中学的经历也预示着图灵不被理解的一生。

1931～1934年，成年后的图灵在剑桥大学国王学院攻读**数学**专业。尽管这里的制度依旧古板，像个放大版的舍尔伯尼，图灵依旧孤僻，但接触到了世界顶级的数学家和一流的学术专著，他可以更专注于自己喜欢的领域，并包揽了许多数学方面的奖项。毕业后，图灵以优异的成绩成为国王学院研究员。他在希尔伯特的问题上花费了整整一年的时间，最终在1936年的《**伦敦数学协会会刊**》上发表了那篇改变世界的论文——《**论可计算数及其在判定问题中的应用**》，提出了使其成为“计算机科学之父”的图灵机。

论文正式发表之前，图灵只身前往美国普林斯顿，在那里找到了领先一步发表成果的邱奇，并师从他继续深造。1937年，图灵嗅到了纳粹德国引战的可能，开始把业余时间花在密码学的研究上。1938年，图灵在取得博士学位后返回了正在紧张备战的英国，不多久，他便参与到政府的密码破译[3]项目中，和全国各地顶尖的数学家们一起，在白金汉郡的布莱切利公馆（Bletchley Park）中深居简出，左右世界战争的格局。

二战时期，各国已经使用无线电进行作战指挥，由于信号可以轻易被敌国接收，需要对无线电内容进行加密，比如将“ABCD”改成“BCDE”发出去，当然军用的加密方式不会如此简单。当时的德国使用一种叫谜机（Enigma machine）的加密机器，按下某个字母的按键，其加密后对应的字母小灯就会亮起。内部的转轮和接插线板将这种对应关系随意打乱，每按一次按键，转轮就会转动一次，组合成新的对应关系，比如第一次按下A，D灯亮起，再按一次A，亮起的可能是Z灯，毫无规律可循。更棘手的是，德军几乎每天都会变更其中的接线。
- <img src="https://pic4.zhimg.com/80/v2-b36ef92aabab27e6ce53e2d0c66e770f_720w.jpg" width="40%" >

解密的方式是**穷举**，即遍历所有可能的对应关系，直到找出有意义的关键词，而这恰恰是机器最擅长的事。英国的同盟国波兰在战前就成功研制了破解谜机的**炸弹机**（bomba），可惜德国在1938年年底将谜机上的转轮从3个增加到了5个，解密的复杂度呈爆炸式增长，针对3转轮谜机设计的炸弹机还未在二战发挥价值就已经宣告报废。解决这个难题的关键人物正是**图灵**，新建的炸弹机（bombe）成功破解了5转轮谜机。其难度之大，大到英国首次利用破解的信息破坏德军行动时，德国的密码专家首先排除了谜机被破解的可能性。
- <img src="https://pic4.zhimg.com/80/v2-4ba1b7d04c066452bfe03492a0e4803f_720w.jpg" width="40%" >

随后，对密码学有着深刻认识的图灵还探索出一种高效的解密算法，人称图灵方法（Turingery），该算法成为布莱切利破解德国密码的核心理论。

布莱切利的工作是图灵在短暂的一生中，为人类所做的第二项伟大贡献。他的成果使战争至少提前2年结束，挽救了至少1400万人的生命。前英国首相温斯顿·丘吉尔曾表示，二战的胜利最该感谢的人就是图灵。

战后，图灵进入国家物理研究所，并设计了属于最早一批电子计算机之一自动计算机ACE（Automatic Computing Engine），首次实现了他心目中的通用图灵机。1950年3月10日，ACE的简化版Pilot ACE开始运行，完整的ACE直到图灵去世之后才建成。
- <img src="https://pic2.zhimg.com/80/v2-1b65d32fd247bf60a1d6417f7158e4a1_720w.jpg" width="70%" >

1948年，图灵成为曼彻斯特大学数学系讲师，并于次年担任学校计算机实验室的副主任，负责计算机软件的研究。他还成为计算机企业的顾问，帮助其研发商用电子计算机。1951年，英国皇家学会将图灵吸纳为会员。

这些年间，图灵的主要智慧仍留给了数学和计算机的理论研究。1950年，第二篇影响世界的论文《计算机与智能》问世，在那个电子计算机才刚刚起步的年代，高瞻远瞩的图灵用一个问题就叩开了人工智能的大门：“机器会思考吗？”文中提出了著名的`图灵测试`（Turing test）：
- 让一台机器躲在挡板后回答测试人员的提问，看测试人员能否判断自己面对的是机器还是真人。
- 能否通过图灵测试，是衡量机器智能程度的重要指标。
- 这位“人工智能之父”过于乐观地预言：到2000年，计算机应该能“骗过”30%的测试人员。

图灵机、炸弹机、人工智能……图灵献给世界太多伟大的作品，却没能在生前得到应有的名誉乃至起码的认可。人们始终觉得他是个难以亲近的怪人，对其二战时期涉密的功绩更是一无所知。

- 1952年，他因同性恋的罪名被起诉，在坐牢和化学阉割之间，他无奈选择了后者，旁人的偏见和药物的副作用使他承受着精神和肉体的双重痛苦。
- 1954年6月7日晚上，他躺在家里因氰化物中毒离开了人世，床头放着一个咬过的苹果，还有16天就是他42岁的生日。尸检的结果认定图灵是通过毒苹果自杀的，却没有对这个苹果做氢化物检测，他的母亲和哥哥却坚持认为这是一场化学实验导致的意外，而真相只有图灵自知。
- 2009年，超过3万人在线请愿为图灵平反，英国首相戈登·布朗代表政府公开道歉。2013年，英国女王伊丽莎白二世正式颁发皇家赦免，图灵终于得到了迟来的公道。
- 1966年，美国计算机协会ACM（Association for Computing Machinery）设立计算机领域的最高奖项，命名为图灵奖。图灵奖素有“计算机界的诺贝尔奖”之称，图灵的名字当之无愧。
- 2019年，英国的中央银行——英格兰银行宣布，图灵的肖像将出现在新版的50英镑纸币上，以此纪念这位改变了国家乃至整个世界命运的伟人。

[图灵机：计算机世界的理论基石](https://zhuanlan.zhihu.com/p/135251031)

### 图灵奖

- 待补充


### 图灵机历史

[图灵机：计算机世界的理论基石](https://zhuanlan.zhihu.com/p/135251031)

- 公元前4世纪，由哲学家欧布里德（Eubulides）提出的著名的**说谎者悖论**。
  - 古老而经典的逻辑游戏：如果一个人说“我正在说谎”，那么他到底在不在说谎呢？
    - 如果他不在说谎，那么“我正在说谎”这句话就是真的；
    - 如果他  在说谎，那么“我正在说谎”这句话就是假的。
  - 无论从哪个方向推演，得到的都是**自相矛盾**的结论，我们无从判定他在不在说谎。
- 类似的，还有伯特兰·罗素（Bertrand Russell）在1901年提出的**罗素悖论**，它的通俗化版本是流传更广的理发师悖论：
  - 如果一位理发师只给不为自己理发的人理发，那他给不给自己理发呢？
  - 罗素悖论直接动摇了整个数学大厦的根基——`集合论`。为使命题合理，当那位理发师圈定服务对象的范围时，必须把自己排除在外。这也就意味着，没有包罗万象的集合——至少它不能轻易包含自己。
- 这些悖论都源自“罪恶”的自指 —— <font color='red'>当一套理论开始描述自身，就难免要出现悖论。</font>
  - 即使再不情愿，人们也不得不承认数学是不完美的，至少它没有自圆其说的能力。
- 尽管如此，仍有数学家想在限定的范围内负隅顽抗，他们找到一个完备的系统，寻求能够判定命题真假的通用算法。这就是德国数学家大卫·希尔伯特（David Hilbert）和威廉·阿克曼（Wilhelm Ackermann）在1928年提出的**判定问题**（Entscheidungsproblem/decision problem）。
- 只可惜没过几年，这种可能性也被否定了。
- 1936年，两位年轻的数学家分别用不同的方法给出了判定问题的解答。
  - 一位是来自美国的阿隆佐·邱奇（Alonzo Church），他引入了一种叫**λ演算**的方法，并最终证明没有任何通用算法可以判定任意两个λ表达式是否相等；
  - 另一位就是来自英国的艾伦·图灵（Alan Turing），和枯燥的数学推理不同，他使用了一种更有趣、更形象的模型，邱奇给了它一个响亮的名字——`图灵机`（Turing machine）。

【2022-1-24】二进制原理
- ![](https://p26.toutiaoimg.com/img/tos-cn-i-qvj2lq49k0/5ba41d7c1788478d891cd6cf4b505709~tplv-obj:400:224.gif)
- ![](https://p26.toutiaoimg.com/img/tos-cn-i-qvj2lq49k0/3f1744b7623c42408114a178ff63f71d~tplv-obj:320:240.gif)


#### 图灵机介绍

图灵机是数学家阿兰·图灵1936年提出来的虚拟的机器，尽管这个机器很简单，但它可以模拟计算机的任何算法，无论这个算法有多复杂。
- ![](https://pic2.zhimg.com/80/v2-94ce773233e7ce82a440c59239f384d9_720w.jpg)
- 假设有一个无穷的纸带，纸带就像一个存储器一样。纸带上面的每个格子是空白的，但是可以读写数据，在这个例子里，机器只能写0，1，或者什么也不写。这个机器就是包含3个信号的图灵机。
- 机器有一个探头，这个头可以移动到每一个空格上，用这个头，机器可以有3个基本操作。
  - 1、 读空格的数据
  - 2、 编辑数据，可以是写一个新的数据，可以是擦除数据
  - 3、 移动纸带向左或者向右，这样机器可以读或者编辑旁边的格子
- 参考：Computer laboratory of university of Cambridge。剑桥大学计算机系：[What is a Turing machine?](https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/turing-machine/one.html)


图灵机的基本组成如下：
- 有一条「纸带」，纸带由一个个连续的格子组成，每个格子可以写入字符，纸带就好比内存，而纸带上的格子的字符就好比内存中的数据或程序；
- 有一个「读写头」，读写头可以读取纸带上任意格子的字符，也可以把字符写入到纸带的格子；
- 读写头上有一些部件，比如存储单元、控制单元以及运算单元：
  - 1、存储单元用于存放数据；
  - 2、控制单元用于识别字符是数据还是指令，以及控制程序的流程等；
  - 3、运算单元用于执行运算指令；

作者：[小林coding](https://www.zhihu.com/question/348237008/answer/1956489945)

图灵机的样子：
- ![](https://pic2.zhimg.com/80/v2-cd2fdeef6ca619507aea9fb06408e91b_720w.jpg)


#### 图灵机工作原理

图灵的基本思想是用机器来**模拟**人们用纸笔进行数学运算的过程，而且还定义了计算机由哪些部分组成，程序又是如何执行的。

图灵机是图灵受打字机的启发而假想出来的一种抽象机器，其处理对象是一条无限长的一维纸带。纸带被划分为一个个大小相等的小方格，每个小方格可以存放一个符号（可以是数字、字母或其他符号）。有个贴近纸带的读写头，可以对单个小方格进行读取、擦除和打印操作。为了让读写头能访问到纸带上的所有小方格，可以
- （1）固定纸带，让读写头沿着纸带左右移动，每次移动一格
- （2）固定读写头，让纸带左右移动

后一种方式类似当时穿孔带以及后来磁带和磁盘的做法，但在纯理论讨论时为了方便说明，我们通常选用前一种方式。
- ![](https://pic4.zhimg.com/80/v2-a0e8c204190e73aa563aee8231e74ccb_720w.jpg)

读写头该如何移动，移动之前或移动之后又该作何操作呢？
- 这取决于机器当前的状态，以及读写头当前所指小方格中的内容，机器中有着一张应对各种情况的**策略表**。
- 构造一台简单的图灵机，实现对纸带上所有3位二进制数的+1操作（超过3位的进位将被丢弃），相邻两个二进制数之间通过一个空的小方格隔开，形如下图所示，读写头从最右侧二进制数的最低位开始扫描，遇到连续2个空方格时认为已处理完所有数，机器停机。
- ![](https://pic2.zhimg.com/80/v2-e6046f3625fe5b55d4cd046ed086291d_720w.jpg)
- 策略表：E表示擦除、P表示打印、L表示左移。
  - <img src="https://pic1.zhimg.com/80/v2-b236f764ee2b1fee60b76400d3b01a20_720w.jpg" width="40%" >
  - 该图灵机有3种工作状态：+1、左移和判断
    - S1 是+1状态，也是机器的初始状态。如果读写头遇到的是0，则直接将0改为1即完成了+1任务，左移一格后进入状态 S2 ；如果遇到的是1，则将1改为0，由于需要进位，即对下一位+1，左移一格后仍留在状态 S1；如果遇到的是一个空方格，即使当前需要进位，也不做处理（将进位丢弃），左移一格后进入状态 S3 。
    - S2 是左移状态，此时已实现当前二进制数的+1，需要将读写头移到下一个数的最低位。如果遇到0或1，说明读写头还在当前二进制数上，继续左移；如果遇到空方格，后面等着它的可能是下一个二进制数，也可能是永无止境的空方格，左移一格之后进入状态 S3 。
    - S3 是判断状态，根据情况判断是否还有二进制数要处理。如果读写头遇到的是0或1，说明当前位置是一个新的二进数的最低位，直接交给 S1 处理；如果遇到的仍是空方格，说明后续不再有数据，停机。
  - <img src="https://pic4.zhimg.com/80/v2-04ec7765ec434701710f52ec43b30e63_720w.jpg" width="70%" >
- 如法炮制，可以设计出具有各种功能的图灵机，而策略表的制定则类似于**编程**。图灵想到，如果把策略表中的信息以统一的格式写成符号串（比如上表可以表达成S1/0/EP1L/S2 S1/1/EP0L/S1 S1//L/S3 ……），然后放在纸带的头部，再设计一台能在运行伊始时从纸带上读取这些策略的图灵机，那么针对不同的任务，就不需要设计不同的图灵机，而只需改变纸带上的策略即可。这种能靠纸带定制策略的图灵机，称为`通用图灵机`UTM（universal Turing machine）。
- 不单是策略表，其实用于描述图灵机的所有信息（包括所使用的符号、初始状态等）都可以表达成纸带上的符号串。这就意味着，一台图灵机可以成为另一台图灵机的输入。

判定问题的解答
- 试想一下，有些情况下，一台图灵机如果长时间没有输出结果，那么很可能陷入了**死循环**或永无止境的计算中。这是不愿看到的，因为机器可能运行1分钟后停机，也可能运行10天半个月甚至几十年才停机，亦或者永远也不会停机，这个很难靠人为判断。假设构建出一台图灵机H，接收其他图灵机及其输入信息作为输入，并能够判定其是否会停机，就解决了上面的烦恼——构建这样的机器难度虽大，但理论上是可行的。
这就是著名的**停机问题**（halting problem）。

H所处理的，本质上正是一种判定问题：某台图灵机在某输入上是否会停机。只要找到一台H判定不了的机器，希尔伯特的美梦就破灭了。

令H表现如下图所示，如果其判定对象会停机则输出1，反之输出0。
- <img src="https://pic1.zhimg.com/80/v2-8383f0d2038dd8e8b52eaf8f92cacc8c_720w.jpg" width="40%" >

再构建一台图灵机G，其运行流程如下图所示。如果H输出1，说明G会停机，但事实上它将陷入循环；如果H输出0，说明G不会停机，但事实上它将停机。
- <img src="https://pic4.zhimg.com/80/v2-8f244b5457adf4c0a05927f99fb1a337_720w.jpg" width="40%" >
悖论已经出现，H无法对G的停机问题进行判定。又一次归因于尴尬的自指：当一个系统强大到一定程度时，终究会遇到无法处理自己的窘境。

因此，**不存在一台图灵机，可以判定任意图灵机是否会停机**。图灵机不是万能的，判定问题的答案也是否定的。而这个看似有点耍赖的证明方式，有着图灵长达36页的数学论证支撑。


#### 图灵机意义

图灵的工作不仅回答了**希尔伯特**的问题，更参透了数学和计算机的本质关系——<font color='blue'>计算机是为解决数学问题而诞生的，却又基于数学，因而数学自身的极限也便框定了计算机的能力范围。</font>

图灵虽然证明了**没有任何机器可以解决所有数学问题**，却也证明了**机器可以完成所有人类能完成的计算工作**，从如今的应用看来，后一个结论的意义重大得多。

从图灵开始，计算机有了真正坚实的理论基础，更多人开始投身计算机的理论研究，而不仅是尝试构建一台机器。从如今的应用来看，图灵机之于计算机领域的价值远高于数学领域，毕竟判定问题还有λ演算和许多其他解答，但计算机的原始公式，只有图灵机这一个。

如今的**所有通用计算机都是图灵机的一种实现**，两者的能力是等价的。
- 当一个计算系统可以模拟任意图灵机（或者说通用图灵机）时，我们称其是**图灵完备**的（Turing complete）；
- 当一个图灵完备的系统可以被图灵机模拟时，我们称其是**图灵等效**的（Turing equivalent）。
- **图灵完备**和**图灵等效**成为衡量计算机和编程语言能力的基础指标，如今几乎所有的编程语言也都是图灵完备的，这意味着它们可以相互取代，一款语言能写出的程序用另一款也照样可以实现。


## 冯诺依曼

- ![](https://pic2.zhimg.com/80/v2-e4d433440561afc5f86bb3e14abd500f_720w.jpg)
- `冯·诺依曼`体系计算机又称存储程序计算，主要由以下几部分组成：
   - CPU（Central Processing Unit）：由控制器、运算器以及寄存器组成
   - 存储器（Memory）:即我们常说的内存
   - I/O设备：输入输出设备
- ![](https://pic2.zhimg.com/80/v2-7c443e162c8c42a605c63dedb96dda1e_720w.jpg)
- 主要特点
   - 程序存储执行
      - 计算机是靠诸多晶体管控制电路而运行，早期的计算机是靠手动控制电路执行，这种设计缺点在于，程序是一次性执行，即没办法存储起来反复执行；
      - 冯·诺依曼体系计算机，则提出了程序是可存储执行，即人们把要执行的程序存储在一个地方，然后在运行的时候让CPU去固定的地方去取，这样做的好处是程序可以存储起来多次运行，且修改程序不需要手动调整电路；
   - 二进制逻辑
      - 十进制逻辑的计数有利于人类阅读，但不利于电路设计，在电路中，状态一般有两种开启或者关闭，二进制逻辑的设计简化了计算机内部电路的设计
- 【2021-3-14】“冯·诺伊曼架构”，简单说就是要有 CPU，内存，显示器和键盘。用键盘给 CPU 下命令，CPU 和内存一起合作，算出结果输出给显示器就可以。
  - 不过 CPU 非常傻，只认识 0 和 1 两个数字。所以如果想算一道算数题，得告诉机器一串 24 位的数字 1000 0011 1100 0000 0000 0001（机器码，ADD %EAX, 1）, 他才能听懂。无论用 Python、C++ 还是别的编程语言，最终都会转换成这 24 个数字。
  - ![](https://p6-tt.byteimg.com/origin/pgc-image/a1515800335f48ae96ff652f84255185?from=pc)

- ![](https://pic1.zhimg.com/80/v2-92fdb4030ccc4cc1aacda3dd200291c9_720w.jpg?source=1940ef5c)

## 高德纳
- [Donald Knuth](https://www-cs-faculty.stanford.edu/~knuth/)，高德纳，《[计算机程序与设计](http://www-cs-faculty.stanford.edu/~uno/taocp.html)》作者，计算科学之父
   - 计算机科学技术中两个最基本的概念：“`算法`”(Algorithm)和“`数据结构`”(Data Structure)就是高德纳于 29 岁时提出来的
   - 艺术是人类智慧的最高形式
   - 高德纳是他的中文名，是 1977 年他访问中国之前所取的，命名者是姚储枫(姚期智的夫人，夫妇都是计算机科学家)。
   - [计算机鼻祖-Donald Knuth（高德纳） 的传奇](https://blog.csdn.net/gatieme/article/details/25613645)

![](http://5b0988e595225.cdn.sohucs.com/images/20180116/caa893f622634d1a8cf8e52f27a99bce.jpeg)

# 计算体系结构

## 计算机指令集

CPU的指令及构架，X86架构，Arm架构，微架构，还有手机处理器上的76、A55这些都是什么东西，它们之间到底是什么样的关系

参考：
- [Arm vs x86: Instruction sets, architecture, and all key differences explained](https://www.androidauthority.com/arm-vs-x86-key-differences-explained-568718/), [中文版](https://www.google.ae/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwjf1tyj5ZzPAhWGWRQKHUoTDJAQFggaMAA&url=http%3A%2F%2Fwww.vaikan.com%2Farm-vs-x86-key-differences-explained%2F&usg=AFQjCNF1yxB0Q64ud33gwpMFqGz4gywKgg&bvm=bv.133178914,d.d24)
- [一文看懂arm架构和x86架构有什么区别](https://blog.csdn.net/bleauchat/article/details/90114342)

计算机的体系结构从指令集的复杂度上可以分两类
- 一类是复杂指令集CISC，主要是X86架构。
- 另一类是精简指令集RISC，这个比较多，主要是ARM、MIPS、PowerPC等。

目前x86和arm的能耗比已经差不多了，关键还是生态。现在大家都用arm指令集，自然软件，操作系统都对arm有各种优化，现在突然来个x86，小的应用厂商已经建立起arm的开发体系和人才队伍了，要真让他们在支持x86，那真是太难为他们了。大厂，比如苹果三星，都自己做处理器，也是arm指令集的，更加没有必要用x86了。应该说x86在移动端已经很难挤进去了

从CPU发明到现在，有非常多种架构，从我们熟悉的X86，ARM，到不太熟悉的MIPS，IA64，它们之间的差距都非常大。但是从最基本的逻辑角度可以分两大类，即所谓的“**复杂指令集** CISC ”与“**精简指令集** RISC”系统。 Intel和ARM处理器的第一个区别是，前者使用复杂指令集（CISC)，而后者使用精简指令集（RISC）。属于这两种类中的各种架构之间最大的区别，在于它们的设计者考虑问题方式的不同。

作者：[波心荡](https://www.zhihu.com/question/20148756/answer/103220283)

## 如何查看linux体系结构

[如何查看linux系统的体系结构](https://blog.csdn.net/lixuande19871015/article/details/90485929)

命令：

```shell
# (1) aarch64就是ARM架构
uname -a
# Linux tegra-ubuntu 4.4.38-tegra #1 SMP PREEMPT Fri Jul 28 09:55:22 PDT 2017 aarch64 aarch64 aarch64 GNU/Linux
uname -m
# 。。。。
file /bin/bash
# 含ARM
# /bin/bash: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 3.7.0, BuildID[sha1]=64c27467ad7a6c507c8f79464fea872fed5dd044, stripped
arch
# aarch64
cat /proc/cpuinfo # 查看cpu信息

# (2) x86架构
uname -a
# Linux ubuntu 4.4.0-21-generic #37-Ubuntu SMP Mon Apr 18 18:33:37 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux
uname -m # 返回 x86_64

file /bin/bash
# /bin/bash: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.32, BuildID[sha1]=04eca96c5bf3e9a300952a29ef3218f00487d37b, stripped
arch
# x86_64 或i386

# (3) MIPS架构
uname -a
# Linux DrogooBox 3.3.8 #33 Tue Mar 22 15:02:01 CST 2016 mips GNU/Linux

```


## ARM —— 精简指令集

### 什么是ARM

ARM架构过去称作进阶精简指令集机器（AdvancedRISCMachine，更早称作：AcornRISCMachine），是一个32位精简指令集（RISC）处理器架构，其广泛地使用在许多嵌入式系统设计。由于节能的特点，ARM处理器非常适用于移动通讯领域，符合其主要设计目标为低耗电的特性 .

在今日，ARM家族占了所有32位嵌入式处理器75%的比例，使它成为占全世界最多数的32位架构之一。ARM处理器可以在很多消费性电子产品上看到，从可携式装置（PDA、移动电话、多媒体播放器、掌上型电子游戏，和计算机）到电脑外设（硬盘、桌上型路由器）甚至在导弹的弹载计算机等军用设施中都有他的存在。在此还有一些基于ARM设计的派生产品，重要产品还包括Marvell的XScale架构和德州仪器的OMAP系列.

### ARM架构

ARM构架图
- ![](http://file.elecfans.com/web1/M00/50/D9/o4YBAFr7zl2AGVr8AABPkxqzXZA667.jpg)

它由32位ALU、若干个32位通用寄存器以及状态寄存器、32&TImes;8位乘法器、32&TImes;32位桶形移位寄存器、指令译码以及控制逻辑、指令流水线和数据/地址寄存器组成.
- 1、ALU：它有两个操作数锁存器、加法器、逻辑功能、结果以及零检测逻辑构成。
- 2、桶形移位寄存器：ARM采用了32&TImes;32位的桶形移位寄存器，这样可以使在左移/右移n位、环移n位和算术右移n位等都可以一次完成。
- 3、高速乘法器：乘法器一般采用“加一移位”的方法来实现乘法。ARM为了提高运算速度，则采用两位乘法的方法，根据乘数的2位来实现“加一移位”运算;ARM高速乘法器采用32&TImes;8位的结构，这样，可以降低集成度（其相应芯片面积不到并行乘法器的1/3）。
- 4、浮点部件：浮点部件是作为选件供ARM构架使用。FPA10浮点加速器是作为协处理方式与ARM相连，并通过协处理指令的解释来执行。
- 5、控制器：ARM的控制器采用的是硬接线的可编程逻辑阵列PLA。
- 6、寄存器

## x86 —— 复杂指令集

![](http://file.elecfans.com/web1/M00/50/ED/pIYBAFr7zpSASlXUAABbDZ2xUGo091.jpg)

这个架构图并不是所有的都是如此，根据不同的主板，平台，架构是略有差别的比如说，目前很多主板已经将北桥集成到CPU当中，将南桥集成为PCH，但大致的框架还是如此的。下面对这个架构图上的各个内容分别进行一些简介:
- 1：CPU，大家都不陌生的名词，中央处理器，计算机的核心大脑。
- 2：北桥（North Bridge Chipset）：北桥是电脑主板上的一块芯片，位于CPU插座边，起连接作用。
- 3：南桥芯片（South Bridge）是主板芯片组的重要组成部分，一般位于主板上离CPU插槽较远的下方，PCI插槽的附近，这种布局是考虑到它所连接的I/O总线较多，离处理器远一点有利于布线。
- 4： 内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。
- 5：显卡（Video card，Graphics card）全称显示接口卡，又称显示适配器，是计算机最基本配置、最重要的配件之一。
- 6：显示接口
- 7：网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。
- 8：声卡的基本功能是把来自话筒、磁带、光盘的原始声音信号加以转换，输出到耳机、扬声器、扩音机、录音机等声响设备，或通过音乐设备数字接口（MIDI）使乐器发出美妙的声音。
- 9：SATA（Serial Advanced Technology Attachment，串行高级技术附件）是一种基于行业标准的串行硬件驱动器接口，是由Intel、IBM、Dell、APT、Maxtor和Seagate公司共同提出的硬盘接口规范。
- 10：硬盘是电脑主要的存储媒介之一，由一个或者多个铝制或者玻璃制的碟片组成。碟片外覆盖有铁磁性材料。
- 11：总线

## x86 vs ARM

ARM采用了RISC，x86采用了CISC指令集，二者的差异表现在了能耗和速度上。RISC的能耗较低，但执行速度慢；x86的速度高能耗大。

从性能、扩展能力、操作系统的兼容性、软件开发的方便性及可使用工具的多样性及功耗这五个方面详细的对比了arm架构和x86架构的区别

### 一、性能 

X86结构的电脑无论如何都比ARM结构的系统在性能方面要快得多、强得多。X86的CPU随便就是1G以上、双核、四核大行其道，通常使用45nm（甚至更高级）制程的工艺进行生产；而ARM方面：CPU通常是几百兆，最近才出现1G左右的CPU，制程通常使用不到65nm制程的工艺，可以说在性能和生产工艺方面ARM根本不是X86结构系统的对手。

但ARM的优势不在于性能强大而在于效率，ARM采用RISC流水线指令集，在完成综合性工作方面根本就处于劣势，而在一些任务相对固定的应用场合其优势就能发挥得淋漓尽致.

### 二、扩展能力

X86结构的电脑采用“桥”的方式与扩展设备（如：硬盘、内存等）进行连接，而且x86结构的电脑出现了近30年，其配套扩展的设备种类多、价格也比较便宜，所以x86结构的电脑能很容易进行性能扩展，如增加内存、硬盘等.

ARM结构的电脑是通过专用的数据接口使CPU与数据存储设备进行连接，所以ARM的存储、内存等性能扩展难以进行（一般在产品设计时已经定好其内存及数据存储的容量），所以采用ARM结构的系统，一般不考虑扩展。基本奉行“够用就好”的原则.

### 三、操作系统的兼容性

X86系统由微软及Intel构建的Wintel联盟一统天下，垄断了个人电脑操作系统近30年，形成巨大的用户群，也深深固化了众多用户的使用习惯，同时x86系统在硬件和软件开发方面已经形成统一的标准，几乎所有x86硬件平台都可以直接使用微软的视窗系统及现在流行的几乎所有工具软件，所以x86系统在兼容性方面具有无可比拟的优势。

ARM系统几乎都采用Linux的操作系统，而且几乎所有的硬件系统都要单独构建自己的系统，与其他系统不能兼容，这也导致其应用软件不能方便移植，这一点一直严重制约了ARM系统的发展和应用。GOOGLE开发了开放式的Android系统后，统一了ARM结构电脑的操作系统，使新推出基于ARM结构的电脑系统有了统一的、开放式的、免费的操作系统，为ARM的发展提供了强大的支持和动力.

### 四、软件开发的方便性及可使用工具的多样性

X86结构的系统推出已经近30年，在此期间，x86电脑经过飞速发展的黄金时期，用户的应用、软件配套、软件开发工具的配套及兼容等工作，已经到达非常成熟甚至可以说是完美的境界。所以使用X86电脑系统不仅有大量的第三方软件可供选择，也有大量的软件编程工具可以帮助您完成您所希望完成的工作。

Arm结构的电脑系统因为硬件性能的制约、操作系统的精简、以及系统兼容等问题的制约，造成Arm结构的电脑系统不可能像X86电脑系统那样有众多的编程工具和第三方软件可供选择及使用，ARM的编程语言大多采用C和JAVA。

对这一点的比较，更直接的结论是：基于x86结构电脑系统平台开发软件比arm结构系统更容易、更简单、实际成本也更低，同时更容易找到第三方软件（免去自己开发的时间和成本），而且软件移植更容易。

从以上对比分析，给了我们的一个很清晰的感觉，ARM和X86结构的电脑根本就无法对比，ARM根本就不是X86电脑的的对手。是的，如果只考虑上述几个方面的要数，ARM确实无法与X86电脑竞争，甚至连比较的资格都没有。但是近1、2年，ARM的产品在终端应用特别是手持终端应用飞速发展（如：智能手机、平板电脑等），其销售数量已经远远超出x86结构的电脑销售数量，可见ARM是具有其与X86结构电脑不可对比的优势。该优势就是：功耗.

### 五、功耗 

X86电脑因考虑要适应各种应用的需求，其发展思路是：性能+速度。20多年来x86电脑的速度从原来8088的几M发展到现在随便就是几G，而且还是几核，其速度和性能已经提升了千、万倍，技术进步使x86电脑成为大众生活中不可缺少的一部分。但是x86电脑发展的方向和模式，使其功耗一直居高不下，一台电脑随便就是几百瓦，即使是号称低功耗节能的手提电脑或上网本，也有十几、二十多瓦的功耗，这与ARM结构的电脑就无法相比.


# 操作系统

【2022-1-26】linux操作系统发明人 [Linus Torvalds](https://github.com/torvalds)，[github源码](https://github.com/torvalds/linux)

## 操作系统介绍

【2022-3-13】[关于LMOS自主操作系统的发展，大家有什么建议？](https://www.zhihu.com/question/30866956)
- [LMOS](http://sam.zoy.org/lmos/) 操作系统，[代码](https://gitee.com/lmos)
  - ![](http://sam.zoy.org/lmos/arch.png)
- 桑文峰，从2012年到2014年，花了两年时间研究清楚了操作系统底层是怎么实现的，并且实现了一个小的os，可以fork和exec新任务，还在网上开了一门视频课程。github地址： 《跟着瓦利哥学写OS》的[课程代码和课件](https://github.com/sangwf/walleclass)
- [自己动手写操作系统](https://item.taobao.com/item.htm), 用c语言和汇编语言编写出一个具备操作系统基本功能的操作系统框架。本书不同于其他的理论型书籍，而是提供给读者一个动手实践的路线图。
- 日本：[30天自制操作系统](https://detail.tmall.com/item.htm)

## 操作系统基本架构

[操作系统初识](https://www.jianshu.com/p/d46d82238518)
- ![](https://upload-images.jianshu.io/upload_images/2111160-98608484cd10d510.jpg)


## 进程、线程、协程

[一文读懂什么是进程、线程、协程](https://cloud.tencent.com/developer/article/1546730)

- 计算机的核心是**CPU**，它承担了所有的计算任务；
- 而**操作系统**是计算机的管理者，它负责任务的调度、资源的分配和管理，统领整个计算机硬件；
- **应用程序**则是具有某种功能的程序，程序是运行于操作系统之上的。

- 程序 = 数据结构 + 算法


![](https://ask.qcloudimg.com/http-save/6667215/le0t3hqy8t.jpeg)

### 任务调度

大部分操作系统(如Windows、Linux)的任务调度是采用**时间片轮转**的**抢占式**调度方式。

在一个进程中，当一个线程任务执行几毫秒后，会由操作系统的内核（负责管理各个任务）进行调度，通过硬件的计数器中断处理器，让该线程强制暂停并将该线程的寄存器放入内存中，通过查看线程列表决定接下来执行哪一个线程，并从内存中恢复该线程的寄存器，最后恢复该线程的执行，从而去执行下一个任务。
- 上述过程中，任务执行的那一小段时间叫做**时间片**，任务正在执行时的状态叫**运行状态**，被暂停的线程任务状态叫做**就绪状态**，意为等待下一个属于它的时间片的到来。

这种方式保证了每个线程轮流执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“**同时进行**”，这也就是所说的**并发**
- 别觉得并发有多高深，它的实现很复杂，但它的概念很简单，就是一句话：**多个任务同时执行**
- ![](https://ask.qcloudimg.com/http-save/6667215/zis17r67gg.png)


### 生命周期

早期只有进程的操作系统中，进程有五种状态，**创建**、**就绪**、**运行**、**阻塞**(等待)、**退出**。早期的进程相当于现在的只有单个线程的进程，现在的**多线程**也有五种状态，生命周期与早期进程的生命周期类似。区别：
- 图里的进程换成线程

早期进程的生命周期
- ![](https://ask.qcloudimg.com/http-save/6667215/c052wle29q.png)

线程生命周期
- ![](https://ask.qcloudimg.com/http-save/6667215/qj5b597ilr.png)

进程在运行过程有三种状态：**就绪**、**运行**、**阻塞**，创建和退出状态描述的是进程的创建过程和退出过程。
- `创建`：进程正在创建，还不能运行。操作系统在创建进程时要进行的工作包括分配和建立进程控制块表项、建立资源表格并分配资源、加载程序并建立地址空间；
- `就绪`：时间片已用完，此线程被强制暂停，等待下一个属于它的时间片到来；
- `运行`：此线程正在执行，正在占用时间片；
- `阻塞`：也叫等待状态，等待某一事件(如IO或另一个线程)执行完；
- `退出`：进程已结束，所以也称结束状态，释放操作系统分配的资源。


### 多线程与多核

时间片轮转的调度方式说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。很多操作系统的书都说“同一时间点只有一个任务在执行”。那有人可能就要问双核处理器呢？难道两个核不是同时运行吗？
- 其实“同一时间点只有一个任务在执行”这句话是不准确的，至少它是不全面的。那多核处理器的情况下，线程是怎样执行呢？这就需要了解**内核线程**。

**多核**(心)处理器是指在一个处理器上集成多个运算核心从而提高计算能力，也就是有多个真正并行计算的处理核心，每一个处理核心对应一个内核线程。

- **内核线程**（Kernel Thread，KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。
- 一般一个处理核心对应一个内核线程，比如单核处理器对应一个内核线程，双核处理器对应两个内核线程，四核处理器对应四个内核线程。
- 现在的电脑一般是双核四线程、四核八线程，是采用超线程技术将一个物理处理核心模拟成两个逻辑处理核心，对应两个内核线程，所以在操作系统中看到的CPU数量是实际物理CPU数量的两倍，如你的电脑是双核四线程，打开“任务管理器\性能”可以看到4个CPU的监视器，四核八线程可以看到8个CPU的监视器。
- ![](https://ask.qcloudimg.com/http-save/6667215/alti04wyyo.png)

**超线程**技术就是利用特殊的硬件指令，把一个物理芯片**模拟**成两个逻辑处理核心，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了CPU的闲置时间，提高的CPU的运行效率。这种超线程技术(如双核四线程)由处理器硬件的决定，同时也需要操作系统的支持才能在计算机中表现出来。

程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——**轻量级进程**（Lightweight Process，LWP），轻量级进程就是我们通常意义上所讲的线程，也被叫做**用户线程**。由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。

用户线程与内核线程的对应关系有三种模型：**一对一**模型、**多对一**模型、**多对多**模型，在这以4个内核线程、3个用户线程为例对三种模型进行说明,见[原文](https://cloud.tencent.com/developer/article/1546730)。

### 1、进程

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动
- 进程是系统进行**资源分配**和**调度**的一个独立单位。
- 每个进程都有自己的独立内存空间，不同进程通过**进程间通信
由于进程比较重量，占据独立的内存，所以上下文进程间的**切换开销**（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定**安全**。

进程一般由**程序**、**数据集合**和**进程控制块**三部分组成。
- **程序**用于描述进程要完成的功能，是控制进程执行的指令集；
- **数据集合**是程序在执行时所需要的数据和工作区；
- **程序控制块**(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。

进程具有的特征：
- 动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；
- 并发性：任何进程都可以同其他进程一起并发执行；
- 独立性：进程是系统进行资源分配和调度的一个独立单位；
- 结构性：进程由程序、数据和进程控制块三部分组成。

### 2、线程

在早期的操作系统中并没有线程的概念，**进程**是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。

任务调度采用的是**时间片轮转**的**抢占式**调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。

后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程。

线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。

- 一个标准的线程由**线程ID**、**当前指令指针**(PC)、**寄存器**和**堆栈**组成。
- 而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。

**线程**是指进程内的一个**执行单元**,也是进程内的**可调度实体**。
- 线程是进程的一个实体, 是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。
- 线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。
- 线程间通信主要通过**共享内存**，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。

### 3、协程（异步）

协程，英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。

因为是自主开辟的异步任务，所以很多人也更喜欢叫它们**纤程**（Fiber），或者**绿色线程**（GreenThread）。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。

协程是一种用户态的轻量级**线程**，协程的调度完全由**用户**控制。从技术的角度来说，“协程就是你可以**暂停**执行的函数”。
- 协程拥有自己的**寄存器上下文**和**栈**。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

**线程**与**进程**的区别:
- 1) 地址空间: 线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间
- 2) 资源拥有: 进程是资源分配和拥有的单位, 同一个进程内的线程共享进程的资源
- 3) 线程是CPU调度的基本单位,但进程不是
- 4) 二者均可并发执行
- 5) 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制

总结：
- 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；
- 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；
- 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见；
- 调度和切换：线程上下文切换比进程上下文切换要快得多。

线程与进程关系
- ![](https://ask.qcloudimg.com/http-save/6667215/rgoregh2l9.png)

**协程**与**线程**的区别:
- 1) 一个线程可以多个协程，一个进程也可以单独拥有多个协程。
- 2) 线程进程都是**同步**机制，而协程则是**异步**。
- 3) 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。
- 4）线程是**抢占式**，而协程是**非抢占式**的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。
- 5）协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程.。
- 6）线程是协程的资源。协程通过Interceptor来间接使用线程这个资源。

### 进程池与线程池

【2022-3-11】[Linux高性能服务器编程—进程池和线程池概念](https://zhuanlan.zhihu.com/p/409320531)

池的描述和定义：`Pool`（池）的概念被广泛的应用在服务器端软件的开发上。使用池结构可以明显的提高你的应用程序的速度，改善效率和降低系统资源的开销。所以在应用服务器端的开发中池的设计和实现是开发工作中的重要一环。

进程池和线程池相似，所以这里只以进程池为例进行介绍。

`进程池`由服务器预先创建的一组`子进程`，这些子进程的数目在3~10个之间。线程池中的线程数目应该和CPU数量差不多。

进程池中的所有子进程都运行相同的代码，有着相同的属性，比如优先级、PGID等，因为进程池在服务器启动之初就创建好了，所有每个子进程都相对干净，没有打开不必要的文件描述符（从父进程继承而来），也不会错误地使用大块的堆内存（从父进程复制得到）。

当新的任务来临，主进程选择哪个子进程来为新任务服务，则有两种方式：
- 1、主进程使用某种算法来主动选择子进程，最简单的算法是随机算法和Round Robin（轮流选取）算法。更加优秀的算法可以使任务在各个工作进程中更加均匀地分配，从而减轻服务器的整体压力。
- 2、主线程和子线程通过一个共享的工作队列来同步，子进程都睡眠在该工作队列上。当有新任务来到时，主进程将任务添加到工作队列中。这将唤醒正在等待任务的子进程，不过只有一个子进程将获得信任的“接管权”，它可以从工作队列中取出任务并执行之，而其他子进程将继续睡眠在工作进程中。

当选择好子进程之后，主进程还需要使用某种通知机制来告诉目标子进程有新任务需要处理，并传递必要的数据。最简单的方法是，在父进程和子进程之间建立一条管道，通过管道来实现进程间通信。父线程和子线程之间的通信相对简单，只需要创建全局变量，因为它们共享全局变量。
- ![](https://pic1.zhimg.com/80/v2-614cb306ee0ece668c3ab773a04b0ae4_1440w.jpg)

使用进程池处理多客户任务时，首先要考虑的一个问题是：监听socket和连接socket是否都由主进程来统一管理。
半同步/半反应堆模式是由主进程统一管理这两种socket的；而半同步/半异步模式，以及领导者/追随者模式，则是由主进程管理所有监听socket，而各个子进程分别管理属于自己的连接socket的。
对于前一种情况，主进程接受新的连接以得到连接socket，然后它需要将该socket传递给子进程（对于线程池而言，父线程将socket传递给子线程是很简单的，因为它们可以很容易地共享该socket。

常连接是指一个客户的多次请求可以复用一个TCP连接。那么，在设计进程池时还需要考虑：一个客户连接上的所有任务是否始终由一个子进程来处理。如果说客户任务是无状态的，那么我们可以考虑使用不同的子进程来为该客户的不同请求服务
- ![](https://pic1.zhimg.com/80/v2-dd3b5cca54c84d095e6310b124bc2edc_1440w.jpg)

# 编程语言

[编程语言分类与关系](https://blog.csdn.net/coding_dong/article/details/80920571)

## 编程语言大全

各门语言难度：[C++ 最难学？最易/难学习的编程语言 TOP 5 来了](https://www.toutiao.com/i7047434834607931940/)
- ![img](https://p26.toutiaoimg.com/origin/tos-cn-i-tjoges91tu/St4ODUM6UmOGe6)

### 语言汇总

- TIOBE 公司，每月会发布一版编程语言的流行度[排行榜](https://www.tiobe.com/tiobe-index/)
- 语言类型分布图：[知乎](https://www.zhihu.com/question/19918532)
  - ![img](https://img-blog.csdn.net/20180705132612202?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGluZ19kb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- [一图看懂编程语言分类](https://blog.csdn.net/acelit/article/details/62466679)
  - ![img](https://img-blog.csdn.net/20170316225437760)
- 各语言[关系图谱](https://exploring-data.com/vis/programming-languages-influence-network/)：（可交互）
- 国外有一篇对主流编程语言进行优劣点评的文章《[These Modern Programming Languages Will Make You Suffer](https://betterprogramming.pub/modern-languages-suck-ad21cbc8a57c)》，非常精彩，强烈建议看一下。对其中 Meta Language 部分的翻译，见 《[一文解决现代编程语言选择困难：响应式编程](https://www.infoq.cn/article/zCMypl8ZzgT9U60sbZ9x)》
- 从计算机最底层的硬件开始，按照贴近硬件的程度，主流编程语言的层次依赖关系图
  - ![img](https://static001.geekbang.org/infoq/d3/d3cf643a29e9f428cc414994660ab0e4.jpeg?x-oss-process=image/resize,p_80/auto-orient,1)
  - C 语言在计算机技术中有其它任何高级语言不可替代的作用。所谓 “0/1 生汇编，汇编生 C，C 生万物，乃编程之本”，任何想立志学好计算机的人都不可能跨过 C 语言。
  - C 语言是面向**内存**的编程语言，用 C 编程的时候，需要知道每个数据在内存中样子，是直接在和计算机对话的。而其它语言，都是做各种各样的封装，屏蔽掉了底层的各种概念，让你都不知道计算机是怎么工作的。
  - 知乎上有人给了一个比喻：如果不会 C 语言，以为自己学会了编程，其实嘛，在“编程”这个“城市”里是没有买“房子”的，没有房子就没有门，说白了，就是没入门，也就是门外汉。
  - 系统地学习 C 语言，在实际产品研发中大规模使用 C 语言，会使你深刻掌握计算机底层的原理与机制，这才是是否能成为“牛”人的根本所在。
- [九种编程语言大对比（图文版）](https://blog.csdn.net/kymdidicom/article/details/113449578)，9张信息图囊括了九种主流编程语言：Python、Java、C、C++、JavaScript、C#、Ruby、PHP以及Objective-C。对于每种编程语言，大家都能够看到由其打造的顶级应用成果，相关职位的平均薪酬（美国）以及该语言的优势与弊端。

### 发展历史

[计算机编程语言发展史](https://www.cnblogs.com/ambitious-to-49/p/10146437.html)

主体脉络：**机器**语言 -> **汇编**语言 -> **高级**语言
- **机器**语言：最初的计算机所使用的是由“0”和“1”组成的二进制数，二进制是计算机的语言的基础。计算机发明之初，计算机只能被少部分人使用，人  们需要用0、1组成的指令序列交由计算机执行，对于机器语言的使用与普及都是很令人头疼的问题。对于程序的移植能力几乎没有，从而时间成本，人力成本十分昂贵。但机器语言也不是没有优势，由于这种语言是直接对计算机硬件进行操作，所以在特定型号的计算机上面，运算效率也是很高的，机器语言的出 现对于未来的计算机语言发展起到了很好的推动作用，所以机器语言也是第一代计算机语言。
- **汇编**语言：汇编语言是在机器语言的基础上诞生的一门语言，用一些简洁的英文字母、符号串来替代一个特定的指令的二进制串，这也提高了语言的记忆性和识别性。对于程序的开发与维护起到了积极作用。汇编语言同样也是直接对硬件进行操作，这样依然局限了它的移植性。但是使用汇编语言针对计算机特定硬件而编制的汇编语言程序，对于计算机硬件的功能和特长的发挥已有了很大进步，它精炼而质量高，所以至今仍是一种常用的程序开发语言。
- **高级**语言：在与计算机的不断交流中，人们对计算机程序的移植性需求不断提高，此时急需要一种不依赖于特定型号的计算机的语言，用这种语言编写的程序能在在各种平台都正常运行。从最初的语言诞生至今，已经相继出现了几百种语言。高级语言的发展也从最初的结构化语言发展成为面向过程语言设计和面向对象语言设计。面向过程语言设计的代表有：C语言，Fortran，cobol，pascal，ada等等一系列语言，而面向对象语言设计的代表则为：java, c++,c#等。对于面向过程的程序来说，执行顺序是流水线似的，在一个模块被执行完成前，人们不能干别的事，也无法动态地改变程序的执行方向，这恰恰与人们的日常处理事情的方式相矛盾。而对于面相对象的程序设计来说，很好的将事物象的部分抽取归类，各个累与模块之间能相互组合，完成特定的功能，同时又能重复使用。对使用者的技术要求也相对降低。

计算机编程语言的发展史：**机器**语言 -> **汇编**语言 -> **高级**语言
- 1940s，产生了真正意义上的电子计算机，这个时期的语言由于内存和计算能力的有限，都是使用硬件相关的**汇编**语言；
- 1950s~1960s，随着电子技术的进步，计算机进入大型机时代，一些**高级**语言被逐渐开发出来主要用于系统级编程和数学计算，
  - Fortran（1950s由IBM团队发明的数学计算语言），
  - COBOL（1950s由IBM等行业领袖推行的金融、商务系统开发语言），
  - LISP（用于人工智能领域，主要的数据结构是Linked List，全名为List Process语言，引入了很多先进的特性如递归、动态类型、自动内存管理等特性）
  - ALGOL（用于算法描述、学术领域，引入嵌套结构，语法范围等，很大的影响了BPCL，B，PASCAL等语言
  - Basic（最早是为给非科学领域的学生所编写，Microsoft VB的前身）
- 1970s，产生了C语言和一些早期的**面向对象**编程语言
  - C（1970s由Dennis Ritchie和Brian Kernighan发明的为DEC机开发的系统编程语言，前身是BPCL，B语言）
  - Simula（第一个支持面向对象的编程语言）
  - SmallTalk（第一个完整实现面向对象特性的编程语言）
- 1980s，向PC时代过渡，语言特性的合并、优化、发展
  - C++（综合了SmallTalk面向对象特性和C语言语法，最为广泛应用的面向对象语言之一）
  - MATLAB（工业领域，工程计算语言）
  - Objective-C（iOS编程语言，已经是Top5的语言之一）
  - Erlang（多重范式编程语言，函数式、并发式、分布式，80年代由爱立信发明用于通信网络编程，现已广泛应用于互联网高并发分布式计算领域，最有名的作品
  - 括CouchDB/RabbitMQ）
  - Perl（源于Unix脚本的动态语言，初衷是为了使报告更容易处理，借鉴了C/sh/AWK和SED）
  - Tcl（曾经是很流行的测试脚本语言，现在已经没落）
- 1990s，PC时代，互联网时代萌芽，产生了很多动态语言和可视化编程集成环境IDE
  - Windows由于垄断PC市场，其基于VC/VB的桌面应用开发曾经是客户端开发技术的主流，随之而来催生了大量的基于Windows SDK客户端应用，MFC是其中最为知名的一个C++类库实现 Python/Ruby/Lua/PHP/JS
  - Java（发展为3个体系，J2SE/J2EE/J2ME，J2EE包含一些企业特性如JDBC, JPA, JTA/JMS/EJB，J2ME是移动版本）
  - Visual Basic/Visual C++/Delphi（Object Pascal）/Power Builder
  - Javascript（浏览器客户端脚本，Netscape发明，包含ECMAScript核心脚本, DOM文档对象模型, BOM浏览器对象模型三部分）
- 2000s~现在, 互联网/移动互联网时代，C/S模式进化为B/S模式，Java/PHP/.Net大行其道，并行计算/分布式计算越来越重要
  - ActionScript（Adobe公司发明，面向对象的Flash开发语言）
  - C#/Visual Basic.Net
  - Groovy（由VMVare支持，基于Java平台的动态语言，支持元数据编程Metaprogramming，动态扩展对象数据，如反射，
- 还比如范型编程（如C++的STL，最早版本由HP实现）能为语言提供运行时再确定的动态类型特性，可以大大简化编码）
  - Go （C语言之父发明的并行计算语言）
  - Node.js（服务器端的JS运行环境，Js语言在服务器端的延伸，具有单线程，高并发的特性）


### Python太低级？

- 各种编程语言之间确实有高低级之分，但不是培训班 Tony 老师告诉的高低级。 
  - ADD %EAX, 1 叫做**汇编**语言，是低级语言，而 Python 和 C++ 则同属于**高级**语言范畴。
  - C++ 是基于 C 语言“改进”而来，Python 则是由 C 语言编写的。
- 那么 Python 和 C++ 谁更高级呢？
  - 在数据科学和人工智能领域，Python 是当之无愧的王者
  - 但在高频交易、网络游戏领域，C++ 可以说是目前的业界标准。
  - 对于少儿编程领域来说，Python 在简单易入门方面几乎没有对手。
- Python 有多简单呢？写一个同样功能的网站，用汇编语言，C++ 与 Python 的工作量对比大约是 1000000:3:1
- Python 和 C++ 的真正区别是**编译型**语言与**解释型**语言的区别，简单来说就是 C++ 是直接变成 0101 让 CPU 运行的，而 Python 则需要随身带个翻译，这就导致 Python 在运行时比 C++ 慢 10 - 100 倍左右。不过不用担心，现在的 CPU 已经快到让你感觉不到任何区别。
- 为什么 Tony 老师说 C++ 比 Python 高级呢？当然是因为学同样的东西，他能收 3 倍的课时费，贵的就高级，没毛病。
  - Tony 老师也许会反驳说 Python 只是玩具语言，大一点的孩子都不用。
  - 我们可以看一下 2016 ～ 2020 编程语言流行度排行榜:
    - ![](https://p3-tt.byteimg.com/origin/pgc-image/b967e918b1824010b6c94ba760438f89?from=pc)
- 参考
  - 【2021-3-14】[Python太低级，我选 C++？码农带你揭穿少儿编程的骗局](https://www.toutiao.com/i6921532950840476174)

## 编译型 vs 解释型

编译型语言和解释型语言
- 计算机不能直接的理解**高级语言**，只能直接理解**机器语言**，所以必须要把高级语言翻译成机器语言，计算机才能执行高级语言的编写的程序。翻译的方式有两种，一个是**编译**，一个是**解释**。两种方式只是翻译的**时间**不同。

### 编译型

编译型语言：
- 需通过**编译器**（compiler）将源代码编译成机器码，之后才能执行的语言。一般需经过**编译**（compile）、**链接**（linker）这两个步骤。
  - ![img](https://img-blog.csdn.net/20180705132835717?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGluZ19kb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 编译是把源代码编译成机器码，链接是把各个模块的机器码和依赖库串连起来生成可执行文件。编译和执行是分开的，但是**不能跨平台**。
- 优点：
  - 编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序**执行效率高**。可以脱离语言环境独立运行。
- 缺点：
  - 编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。
- 代表语言：C、C++、Pascal、Object-C、swift等


### 解释型

解释型语言
- 解释性语言的程序不需要编译，相比编译型语言省了道工序，解释性语言在运行程序的时候才逐行翻译。每一个语句都是执行的时候才能翻译。这样解释性语言每执行一次要翻译一次，**效率较低**。
  - ![img](https://img-blog.csdn.net/20180705132541162?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGluZ19kb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 优点：
  - 有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）。
  - 灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。
- 缺点：
  - 每次运行的时候都要解释一遍，性能上不如编译型语言。
- 代表语言：JavaScript、Python、Erlang、PHP、Perl、Ruby

### 混合型

混合型语言
- 混合型语言也叫**半编译型**语言。比如java、C#，C#在编译的时候不是直接编译成机器码而是**中间码**，.NET平台提供了中间语言运行库运行中间码，中间语言运行库类似于**Java虚拟机**。.net在编译成IL代码后，保存在dll中，首次运行时由JIT在编译成机器码缓存在内存中，下次直接执行。
  - ![img](https://img-blog.csdn.net/20180705132554135?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGluZ19kb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- Java解释器 采用生成与系统无关的字节代码指令技术。也就是说，在任何不同的操作系统上，只要正确安装了java运行系统，就有了编写调试java程序的平台，在分布式应用中，java的这个特点使同一个java程序能在不同的系统上运行，从而提高了软件生产效率。可移植性是跨平台特性的一个延伸，即具有了跨平台性，就保证了可移植性。java程序、java类库、java编译器、java系统都具有可移植性。
- 另外有一个特殊的情况，正常情况下JavaScript属于解释性语言，V8引擎是被设计用来提高网页浏览器内部JavaScript执行的性能，为了提高性能，v8会把js代码转换为高效的机器码，而不在是依赖于解释器去执行。v8引入了JIT在运行时把js代码进行转换为机器码。这里的主要区别在于V8不生成字节码或任何中间代码。这里的特殊之处在于JIT做代码优化(同时生成编译版本)；解释型语言无法做到这些。

## 强类型语言和弱类型语言

### 强类型语言

强类型语言，一旦一个变量被指定了某个数据类型，如果不经过强制类型转换，那么它就永远是这个数据类型。你不能把一个整形变量当成一个字符串来处理。
- 主要语言：Java、C#、Python、Object-C、Ruby

### 弱类型语言

数据类型可以被忽略，一个变量可以赋不同数据类型的值。一旦给一个整型变量a赋一个字符串值，那么a就变成字符类型。
- 主要语言：JavaScript、PHP、C、C++（C和C++有争议，但是确实可以给一个字符变量赋整形值，可能初衷是强类型，形态上接近弱类型）


## 动态和静态

主要针对点是：运行时是否能够改变代码结构。

注意：
- 通常情况下**解释型**语言是**动态**类型语言，**编译型**语言是**静态**类型语言。但也不全是
  - swift是编译型语言但是它也是动态类型语言
  - C#和Java是解释型语言也是静态类型语言。

### 动态结构语言

是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。
- 主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。

对数据类型检查的时间
- 动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。
- 主要语言：Python、Ruby、Erlang、JavaScript、swift、PHP、SQL、Perl。

### 静态结构语言

与动态语言相对应的，运行时结构不可变的语言就是静态语言。
- 如Java、C、C++。

对数据类型检查的时间
- 静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型。 
- 主要语言：C、C++、C#、Java、Object-C

## 执行速度

多种编程语言执行速度对比：
- ![](https://p3.toutiaoimg.com/img/tos-cn-i-qvj2lq49k0/eb193ff464674be29b84675497b7f91e~tplv-obj:1913:1040.image?from=post)

以斐波那契数列计算为例，对比各种语言的性能
- **编译**速度：GO > C > JS > PHP > C++ > Java > Python
- **运行**速度：C++ > C > GO > Java > JS > PHP > Python

|编程语言|编译时间|运行时间|备注|
|--------|---|---|---------------|
|Go 1.14|0.09s|0.04s|go build f.go|
|Java 1.8|1.2s|0.14s|javac f.java|
|C|0.14s|0.03s|gcc-6 -O2 -o c.bin f.c|
|C++ 14|0.8s|0.03s|g++-6 -O2 -o a.bin f.cpp|
|Python 3|3.6s|3.6s|编译+执行一起: python3 f.py|
|PHP 7|0.8s|0.8s|编译+执行一起: php f.php|
|JS Node|0.33S|0.33S|编译+执行一起: node f.js|


## 计算机课程

计算机速成课 [Crash Course Computer Science](https://thecrashcourse.com/courses/computerscience)，Carrie Anne Philbin在本课程以入门级大学材料和AP计算机科学原理指南为基础。 笔记：[CPU中的程序是怎么运行起来的](https://blog.csdn.net/wgp2hpp/article/details/110790031)
1. 概述计算机的历史以及为我们提供现代计算机的设计决策
2. 描述编程和软件的基本要素
3. 确定计算机硬件的基本组件及其作用
4. 描述如何使用计算机以及计算机如何随着时间演变
5. 了解计算机的普及程度以及

[Youtube地址](https://www.youtube.com/playlist?list=PL8dPuuaLjXtNlUrzyH5r6jN9ulIgZBpdo)

<iframe src="//player.bilibili.com/player.html?aid=457294840&bvid=BV145411j7aH&cid=242822115&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"  height="600" width="100%"> </iframe>

## 代码如何被CPU执行

[简单！代码原来是这样被CPU跑起来的](https://www.cnblogs.com/jiazhuangdongbiancheng/p/15521829.html)

- <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8463b24f49d4c50a51ccfe5900ff0fc~tplv-k3u1fbpfcp-watermark.awebp" width="70%" >

像C++/java/python这些高级语言写的程序没法被直接运行，因为计算机只认识0、1这样的二进制，简称**机器码**，我们写的代码（高级语言）需要替换成机器码，计算机才能执行。这个转换的过通常叫「**编译**」。

hello.c

```c
#include <studio.h>
int main() 
{
   printf("Hello World\n");
   return 0;
}
```

Linux下用GCC来编译Hello World程序

```shell
gcc hello.c # 编译代码，输出可执行文件
./hello # 可执行的二进制文件
# Hello World
```

编译的过程很复杂，分为4个步骤：**预处理**(Prepressing)、**编译**(Compliation)、**汇编**(Assertmbly)和**链接**(Linking)。
- （1）**预编译**：处理源代码中以“#”开始的预编译指令，比如“#include”、“define”等。
- （2）**编译**：把预处理完的文件进行词法分析、语法分析、语义分析及优化后生产成相应的汇编代码，这个过程是最复杂的。
- （3）**汇编**：将汇编代码转换成机器码，也就是上图的目标文件hello.o
- （4）**链接**：代码程序经常是由多个代码文件组成的，当每个文件都被汇编成“.o”文件时，需要一套机制将它们「组装」在一起，这个过程就叫做链接。
- ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcc651436d3f47fb8627cb343ec6e8c5~tplv-k3u1fbpfcp-watermark.awebp)

站在CPU的视角来看看Hello World是如何被打印出来的。

### 连接-中转站和高速公路

首先编译好的文件是存在磁盘上的，得先加载到内存中。CPU通过总线和芯片打通了磁盘、内存之间的通信
- 问：为什么CPU不能直接读取磁盘的程序运行而要经过内存？
- 答：慢，缓慢的磁盘会影响我们程序执行的速度，因此需要更加快速、离CPU更近的存储，那就是内存。内存是一大块存储空间，可以存储很多数据信息
  - <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6454fd4ce5c499aad4c0050cbe4e46c~tplv-k3u1fbpfcp-watermark.awebp" width="50%" >
- 问：如何找到程序？
- 答：地址，每个字节在内存中都有一个地址，这样当CPU去内存中读程序时，只需要根据对应的地址就可以知道程序的具体内容。
  - <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b78698efab3f4f1a9f27c0a5f603f594~tplv-k3u1fbpfcp-watermark.awebp" width="50%" >
- 问：CPU是如何与内存、磁盘通信？
- 答：通过主板上的**总线**和**芯片组**，总线好理解，就像高速公路，数据信息可以通过这条高速公路传递到CPU中。电脑主板上芯片很多，这里说的主要是**南桥**芯片和**北桥**芯片。
  - **北桥**芯片：北桥负责高速设备和CPU之间的沟通，主要就是CPU和内存、显卡之间的通信，但是随着技术的迭代，主板上的北桥芯片已经被内置到了CPU里了。
  - **南桥**芯片：南桥负责低速设备和北桥之间的通信，主要负责I/O总线之间的通信，如USB、LAN、ATA、SATA、音频控制器、键盘控制器、实时时钟控制器、高级电源管理等
- 问：为什么CPU与高速设备、低速设备之间的通信需要这两个芯片？CPU自己不能干吗？
- 答：① 任务分工，如果把所有的任务都交给CPU来处理，CPU太忙；② 备份，如果南桥芯片坏了，可以直接更换南桥，而不用换掉整个CPU。
  - <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea5c8c14ce4c4244881e829ee77c6c6f~tplv-k3u1fbpfcp-watermark.awebp" width="80%" >

### CPU-最强大脑

CPU 全称是 Central Processing Unit，即**中央处理单元**，本质是一块超大规模的集成电路。从逻辑上来分，它的内部是由**寄存器**、**控制器**、**运算器**和**时钟**组成的，下面来解释下各个组成是干什么的。
- **寄存器**：CPU内部其实有很多类型的寄存器，我们只需了解寄存器就是暂存数据、指令等信息的，它的本质是临时存储，由于是直接集成在CPU内部，所以读写它们的速度很快，一般一个CPU内部会有20-100个寄存器，这里给大家列举下常用寄存器与其功能。
  - 累加寄存器：存储执行运算的数据和运算后的数据
  - 标志寄存器：存储运算处理后的CPU的状态
  - 程序计数器：存储下一条指令所在内存的地址
  - 基址寄存器：存储数据内存的起始地址
  - 变址寄存器：存储基址寄存器的相对地址
  - 通用寄存器：存储任意数据
  - 指令寄存器：存储指令，CPU内部使用，程序员无法通过程序对该寄存器进行读写操作
  - 栈寄存器：存储栈区域的起始地址
- **控制器**：控制器负责把数据读出或者写入寄存器，并根据指令的结果来控制计算机。
- **运算器**：从名字就可以猜出来，运算器的主要工作就是运算，运算从内存读入寄存器的值
- **时钟**：它并不是我们见的钟表概念，它代表了你的CPU的工作频率，频率越高说明你的CPU处理的速度越快，但是越快就会带来另一个问题：散热。
  - <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fba39fd3cbf04d888b8db4653d303dfd~tplv-k3u1fbpfcp-watermark.awebp" width="80%" >

CPU的大致工作流程如下：
- 在时钟信号到来的时候，就开始工作，通过控制器把内存的数据读到各个寄存器中，然后如果有计算相关的逻辑，就交给运算器。发现没有，CPU的工作其实挺简单的，本质就是不停的读指令、执行指令。
  
但是CPU是如何读到代码指令的，以及代码里面的if else、函数调用都是如何执行分支判断、函数跳转的？

示例：伪代码，有分支判断、有函数跳转。

```c
a = 1 #0x0010
b = 2 #0x0011
if a > b { #0x0012
 printf("%s","a") #0x0013
} else { 
 add(a,b) #0x0014
} 
printf("%s","end") #0x0017

func add(int a,int b) { #0x0020
  return a+b
}
```

执行过程：
- <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f1263709ee543209dc39bc23c7c83a3~tplv-k3u1fbpfcp-watermark.awebp" width="80%" >
- 首先每段程序都有个开始的地址0x0010，也就是CPU读取程序的入口
- 把a=1这个数字读入通用寄存器中，程序计数器（PC寄存器）自动加1，即指向下一条指令 0x0011
- 指令寄存器拿到程序计数器的指令地址，把b=2这个数字读入通用寄存器中，程序计数器（PC寄存器）自动加1，即指向下一条指令0x0012
- 指令寄存器发现此处是比较逻辑，会执行a-b，此时可能会有三个结果分别是大于0，等于0，小于0，然后把这个结果存到标志寄存器里
  - 知识点：经常说的是CPU是64位或者32位，其实也表示了标志寄存器的长度
  - <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e640e071a8484ae99404346020619936~tplv-k3u1fbpfcp-watermark.awebp" width="80%" >
- 很明显，a是小于b的，CPU根据标志寄存器的状态值应该跳转到else里面，注意这时程序计数器的值不是加1，而是设置成else的地址 0x0014，当执行到0x0015的时候，需要发生函数跳转，程序计数器会被设置成 0x0020，但是这里并不是简单的函数跳转（专业术语叫做call），因为在函数执行完毕之后，还要返回，也就是程序计数器需要从0x0020再变成0x0017。call执行的时候会把后续要执行的指令地址0x0017存到栈中。
- 当add函数执行完，会有个return，return的时候会把上一步骤存入栈中的地址0x0017写入程序计数器中
- 指令寄存器根据程序计数器当前的地址执行最后的打印（end），结束。

总结：
- **顺序执行**的指令代码，程序计数器会自动累加（当然不一定累加的是1），然后找到下一条要执行的指令。
- **分支判断**时，程序计数器不是简单的累加地址，需要地址的跳转。
- **函数调用**不仅仅需要跳转地址，还要把函数执行完毕之后要执行的地址存下来，方便折回继续执行。
- 其实还有个**循环执行**，也就是代码中的for、while之类的，这时程序计数器会不停的在某些地址之间来回切换。



# 其它

## 少儿编程

- 【2021-3-14】[Python太低级，我选 C++？码农带你揭穿少儿编程的骗局](https://www.toutiao.com/i6921532950840476174)
- 少儿编程该怎样入门?
- 从我个人经验来说，学好编程只需要两个条件：
  - 带着目标学习
  - 一个字一个字亲手写代码
- 学习编程其实是一个非常庞大的过程，你需要学完编程语言、标准库、常用第三方库、网络协议、数据库、操作系统、数据结构、常用算法等一大堆内容，才能真正做一个产品级的程序。但是对于少儿编程来说，学好编程语言本身，一点点标准库和第三方库，也可以做出一些好玩的程序。
- 对于娃是否应该学习编程这件事情，如果中高考不考，可以完全不用学。Tony 老师往往告诉你学习编程，可以训练小朋友逻辑思维，让小朋友数学更好。但真相却恰恰相反，是逻辑思维好的小朋友，学编程更容易而已。
- 编程语言中用到的数学逻辑只有 3 个:
  - 条件判断
  - 循环
  - 递归
- 所以入门编程，你最需要的是给娃定一个目标，让他能带着任务学习，比如编写一个小小的游戏，或者让机器人跑起来。有了目标，就可以按照下图一步一步开始学习：
  - ![](https://p3-tt.byteimg.com/origin/pgc-image/aee41b60a1f143369f9dcef63f083be7?from=pc)
- 解释
  - 学完蓝色部分，基本什么也做不了，但是对编程本身会有非常清晰的概念，大部分娃学到这里也就结束了。
  - 学完橙色部分，就可以实现有趣的小游戏，或者让机器人随心所欲跑来跑去，娃会有满满的乐趣和成就感。
  - 绿色和紫色部分，预留给走专业路线的娃，如果上了高中依然热爱编程，并且有剩余精力，可以开始学习这两部分内容。不过即使学完紫色部分，也不代表编程就学完了
- 展示一下专业码农的[路线图](https://p3-tt.byteimg.com/origin/pgc-image/7eb17b3f555a44babf724f1283de9fb4?from=pc)，英文原版图谱:[前端知识图谱](https://roadmap.sh/frontend),[后端知识图谱](https://roadmap.sh/backend):
  - ![](https://p3-tt.byteimg.com/origin/pgc-image/7eb17b3f555a44babf724f1283de9fb4?from=pc)
  - 学完这些，才能差不多找一份互联网中级码农的工作，而且职业生涯还比较艰辛。行业变化特别快，技术天天都更新，工资全是加班费，年轻人便宜还玩命。
- 总结
  - 不要让娃从 C++ 入门编程，这样只会加速娃放弃学习
  - 学习编程不会提高娃的数学成绩，也不会提高逻辑思维能力
  - 绝大部分娃最终都会放弃，不要对娃有太高的期许，保留乐趣最重要
  - 如果娃有兴趣，坐得住，老师靠谱，可以从 Python 入门编程


# 结束
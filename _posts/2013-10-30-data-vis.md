---
layout: post
title:  "数据可视化-data-visualization"
date:   2013-10-30 15:06:00
categories: 数据挖掘
tags: 数据分析 graphviz echarts pyecharts matplotlib seaborn 有限状态机 t-sne 分形 元胞自动机 图灵斑图
excerpt: 数据可视化工具及经验汇总
author: 鹤啸九天
mathjax: true
---

* content
{:toc}

# 总结

- 可视化方法
- 【2020-8-7】[Python数据可视化工具测评：5大工具谁是第一？](https://www.toutiao.com/i6857488478171562510/?tt_from=mobile_qq&utm_campaign=client_share&timestamp=1596811627&app=news_article&utm_source=mobile_qq&utm_medium=toutiao_android&use_new_style=1&req_id=202008072247070101470841452B60EFB6&group_id=6857488478171562510)
    - Matplotlib、Pyecharts、Seaborn、Plotly、Bokeh这五大工具
    - ![](http://p3-tt.byteimg.com/large/pgc-image/1a00b53e61244311b268f235036f4d80?from=pc)
    - 评测维度
    - ![](http://p1-tt.byteimg.com/large/pgc-image/3b7002a2598e49719906d8c7bc6fd9ee?from=pc)
- Seaborn和Plotly、bokeh有一个共同的地方就是虽然强大，但是网上有关这三个库的教程、讨论都远少于Pyecharts与Matplotlib

|**工具**|**得分**|**分布**|**示例**|
|---|---|---|---|
|Pyecharts|85|![](http://p3-tt.byteimg.com/large/pgc-image/7093619494244189aeb5eee909b73060?from=pc)|![](http://p6-tt.byteimg.com/large/pgc-image/3c90d333349f4a7ebbe633094712bcca?from=pc)|
|Matplotlib|77|![](http://p3-tt.byteimg.com/large/pgc-image/646166041e6343d39c033b2ebab97fdf?from=pc)|![](http://p1-tt.byteimg.com/large/pgc-image/83e98dc271c345b29f8ff7ac9291719f?from=pc)|
|Plotly|76|![](http://p1-tt.byteimg.com/large/pgc-image/b61e531a2f824044b8c2e99427b08973?from=pc)|![](http://p6-tt.byteimg.com/large/pgc-image/83a94c90fbd14a2692c67747f61513e7?from=pc)|
|Bokeh|71|![](http://p6-tt.byteimg.com/large/pgc-image/8ccde1b5c1be4fa7ac39f0c9a6b76416?from=pc)|![](http://p6-tt.byteimg.com/large/pgc-image/ca1f4b4b76f045d987f88a2be6a4fd67?from=pc)|
|Seaborn|72|![](http://p6-tt.byteimg.com/large/pgc-image/355779f843154053b67fb29c1beb7dd3?from=pc)|![](http://p3-tt.byteimg.com/large/pgc-image/5380934b5a2046e082a5d13581d18075?from=pc)|

# matplotlib

## Matplotlib

- Python 有非常丰富的第三方绘图库，matplotlib 使用起来也许并不是很便捷，因为图上每个元素都需要自己来定制。但仔细体会 matplotlib 背后的设计思想是很有趣的事情。seaborn 之类的绘图库是基于 matplotlib 封装的，因而后期需要自己灵活定制图形时就大大受用了。本文的两幅思维导图是基于两种不同的思路绘制的，偶有内容交叉，日常使用可以选择自己熟悉的方式（网上的教程大多是基于过程的函数式编程，即 pyplot 方法）。**建议配合最后附上出的参考资料学习**。

![](https://raw.githubusercontent.com/woaielf/woaielf.github.io/master/_posts/Pic/1704/170427-1.png)

![](https://raw.githubusercontent.com/woaielf/woaielf.github.io/master/_posts/Pic/1704/170427-2.png)

Reference
> 《Python for data analysis》<br>
[Matplotlib: Python plotting — Matplotlib 2.0.2 documentation](http://matplotlib.org/index.html) <br>
[绘图: matplotlib核心剖析](http://www.cnblogs.com/vamei/archive/2013/01/30/2879700.html#commentform) <br>
[【数据可视化】 之 Matplotlib](https://zhuanlan.zhihu.com/p/21443208?utm_medium=social&utm_source=qq?utm_medium=social&utm_source=qq) <br>
[Python--matplotlib绘图可视化知识点整理](http://python.jobbole.com/85106/) <br>
[一份非常好的Matplotlib 教程](http://blog.csdn.net/u011497262/article/details/52325705)

- 绘制热力图

```python
import numpy as np
import matplotlib
import matplotlib.pyplot as plt

# 这里是创建一个数据
vegetables = ["cucumber", "tomato", "lettuce", "asparagus",
              "potato", "wheat", "barley"]
farmers = ["Farmer Joe", "Upland Bros.", "Smith Gardening",
           "Agrifun", "Organiculture", "BioGoods Ltd.", "Cornylee Corp."]

harvest = np.array([[0.8, 2.4, 2.5, 3.9, 0.0, 4.0, 0.0],
                    [2.4, 0.0, 4.0, 1.0, 2.7, 0.0, 0.0],
                    [1.1, 2.4, 0.8, 4.3, 1.9, 4.4, 0.0],
                    [0.6, 0.0, 0.3, 0.0, 3.1, 0.0, 0.0],
                    [0.7, 1.7, 0.6, 2.6, 2.2, 6.2, 0.0],
                    [1.3, 1.2, 0.0, 0.0, 0.0, 3.2, 5.1],
                    [0.1, 2.0, 0.0, 1.4, 0.0, 1.9, 6.3]])

# 这里是创建一个画布
fig, ax = plt.subplots()
im = ax.imshow(harvest)

# 这里是修改标签
# We want to show all ticks...
ax.set_xticks(np.arange(len(farmers)))
ax.set_yticks(np.arange(len(vegetables)))
# ... and label them with the respective list entries
ax.set_xticklabels(farmers)
ax.set_yticklabels(vegetables)

# 因为x轴的标签太长了，需要旋转一下，更加好看
# Rotate the tick labels and set their alignment.
plt.setp(ax.get_xticklabels(), rotation=45, ha="right",
         rotation_mode="anchor")

# 添加每个热力块的具体数值
# Loop over data dimensions and create text annotations.
for i in range(len(vegetables)):
    for j in range(len(farmers)):
        text = ax.text(j, i, harvest[i, j],
                       ha="center", va="center", color="w")
ax.set_title("Harvest of local farmers (in tons/year)")
fig.tight_layout()
plt.colorbar(im)
plt.show()
```

![](https://pic1.zhimg.com/80/v2-688f8d2f666ccbbd221c4be9826863e6_720w.jpg?source=1940ef5c)


```python
from matplotlib import pyplot as plt
from matplotlib import cm as cm

def correlation_matrix(df):
    fig = plt.figure(figsize=(50,30))
    ax1 = fig.add_subplot(111)
    ax1.set_title('intent translate map',fontsize=40,color='b')
    cmap = cm.get_cmap('jet', 30) 
    cax = ax1.imshow(df.corr(), interpolation="nearest", cmap=cmap)
    ax1.grid(True)
    #plt.title('Abalone Feature Correlation') 
    labels_x = df.index
    labels_y = df.columns
    #labels=['Sex','Length','Diam','Height','Whole','Shucked','Viscera','Shell','Rings',]
    ax1.set_xticklabels(labels_x,fontsize=20)
    ax1.set_yticklabels(labels_y,fontsize=20)
    # Add colorbar, make sure to specify tick locations to match desired ticklabels
    fig.colorbar(cax, ticks=[.75,.8,.85,.90,.95,1])
    plt.show()

correlation_matrix(df)
```

# turtle

- 【2021-4-6】[Python的turtle库使用-画出好看的图形](https://www.toutiao.com/i6947915708235907591/),1969年诞生,Python语言的标准库之一,入门级的图形绘制函数库, [官方文档](https://docs.python.org/3/library/turtle.html), [入门指南](https://blog.csdn.net/sandalphon4869/article/details/99443949)
- [布局](https://img-blog.csdnimg.cn/20190813115627644.png)
  - ![](https://img-blog.csdnimg.cn/20190813115627644.png)
- 示例, [彩色螺旋线](https://p3-tt.byteimg.com/origin/pgc-image/e649fedd95824c0ca17582dd36f07b32)

```python
import turtle

turtle.shape('turtle')
turtle.speed(9)            # 画笔速度
turtle.pensize(2)			# 画笔的宽度
turtle.bgcolor("black")		# 画布背景色
colors = ["red","yellow","green","blue"]	# 定义画笔线色

for i in range(255):		# 循环一次 画一条线
    turtle.forward(2 * i) 	        # 向当前方向前进n像素
    turtle.color(colors[i % 4])	# 根据求余 调整画笔线色
    turtle.left(91)                # 向左旋转91度

turtle.done()
```

![](https://p3-tt.byteimg.com/origin/pgc-image/e649fedd95824c0ca17582dd36f07b32)

# seaborn

- 建立在matplotlib上
- Seaborn的heatmap[参数介绍](https://blog.csdn.net/m0_38103546/article/details/79935671)
  - data：矩阵数据集，可以使numpy的数组（array），如果是pandas的dataframe，则df的index/column信息会分别对应到heatmap的columns和rows
  - linewidths,热力图矩阵之间的间隔大小
  - vmax,vmin, 图例中最大值和最小值的显示值，没有该参数时默认不显示
  - cmap：matplotlib的colormap名称或颜色对象；如果没有提供，默认为cubehelix map (数据集为连续数据集时) 或 RdBu_r (数据集为离散数据集时)

```python
import seaborn as sns
import numpy as np
import matplotlib.pyplot as plt
import random

np.random.seed(1)
data = np.random.rand(16, 16)

sns.set()
ax = sns.heatmap(data, center=0)
#plt.savefig('res.png', dpi=300)
plt.show()
```
![](https://pic2.zhimg.com/80/v2-c4a0b7721ad6d32762a782e573b41d43_720w.jpg?source=1940ef5c)

```python
f, (ax1,ax2) = plt.subplots(figsize = (10, 8),nrows=2)
# cubehelix map颜色
cmap = sns.cubehelix_palette(start = 1.5, rot = 3, gamma=0.8, as_cmap = True)
sns.heatmap(pt, linewidths = 0.05, ax = ax1, vmax=15000, vmin=0, cmap=cmap)
ax1.set_title('cubehelix map')
ax1.set_xlabel('')
ax1.set_xticklabels([]) #设置x轴图例为空值
ax1.set_ylabel('kind')
# matplotlib colormap
sns.heatmap(pt, linewidths = 0.05, ax = ax2, vmax=15000, vmin=0, cmap='rainbow') 
# rainbow为 matplotlib 的colormap名称
ax2.set_title('matplotlib colormap')
ax2.set_xlabel('region')
ax2.set_ylabel('kind')
f.savefig('sns_heatmap_cmap.jpg', bbox_inches='tight')

# 加数值标注
np.random.seed(0)
x = np.random.randn(10, 10)
f, (ax1, ax2) = plt.subplots(figsize=(8,8),nrows=2)
sns.heatmap(x, annot=True, ax=ax1)
sns.heatmap(x, annot=True, fmt='.1f', ax=ax2)
f.savefig('sns_heatmap_fmt.jpg')
```

![](https://pic1.zhimg.com/80/v2-3cbbbc15f7116beded4643bf77a68214_hd.jpg)
![](https://pic3.zhimg.com/80/v2-50d816db7cc91dbf4e48a9860d0c1800_hd.jpg)

# pyecharts

## 简介

Echarts是一个由百度开源的数据可视化工具，凭借着良好的交互性，精巧的图表设计，得到了众多开发者的认可。pyecharts是一个全新的可视化绘图工具，因此它的绘图逻辑完全不同于前面说到的matplotlib、seaborn、plotly。

## 版本

- 【2020-12-08】pyecharts分为v0.5和v1两个大版本，v0.5和v1两个版本不兼容，风格迥异，v1是一个全新的版本。旧版基本放弃。
- 查看版本：print(pyecharts.version)
- 旧版是**过程式**调用，新版是**链式**调用

## 安装

命令：

```python
pip install pyecharts
# 如果需要绘制地图，下列地图数据包需要安装
pip install echarts-countries-pypkg
pip install echarts-china-provinces-pypkg
pip install echarts-china-cities-pypkg
pip install echarts-china-counties-pypkg
pip install echarts-china-misc-pypkg
```

- [pyecharts官网](https://pyecharts.org/#/zh-cn/quickstart)，示例程序

注意：
>- 在使用 Pandas&Numpy 时，请确保将数值类型转换为 python 原生的 int/float。比如整数类型请确保为 int，而不是 numpy.int32

## 基础知识

[【干货分享】pyecharts的绘图原理详解](https://zhuanlan.zhihu.com/p/301058247)

pyecharts的绘图逻辑分为以下几步。
- ① 选择**图表类型**；散点、折线、饼图以及地图等
  - from pyecharts.charts import Scatter 
  - ![常见图表类型](https://pic1.zhimg.com/80/v2-d75494d592313e6adcc0d89658fbb2c0_720w.jpg)
- ② 声明图形类并添加数据；每一个图形库都是被pyecharts作者封装成为了一个**类**，即面向对象，用类时，需要**实例**化这个类。声明类之后，相当于初始化了一个**画布**，之后的绘图就是在这个画布上进行。接下来要做的就是添加数据，pyecharts中添加数据共有2种方式，一种是普通的**过程式**添加数据，一种是**链式**调用(观察下面代码)来添加数据
  - 散点图、折线图等二维数据图形，它既有X轴，又有Y轴，两个轴都要添加
    - .add_xaxis(xaxis_data=x)为X轴添加数据；
    - .add_yaxis(series_name='', y_axis=y)为Y轴添加数据；series_name参数必须有，添加的数据标题
  - 饼图、地图没有X轴、Y轴区分的图形，直接使用add()方法添加即可
    - .add(series_name='', data_pair=[(i,j)for i,j in zip(lab,num)])；
- ③ 选择**全局变量**；调节各种各样的参数，把图形变得更好看. 常用的有: [图片总结](https://pic1.zhimg.com/80/v2-e0dc24bb8b127698ee04f322d99bb968_720w.jpg)
  - `标题`配置项: TitleOpts
  - `图例`配置项: LegendOpts
  - `工具`配置项: ToolboxOpts
  - `视觉映射`配置项: VisualMapOpts
  - `提示框`配置项: TooltipOpts
  - `区域缩放`配置项: DataZoomOpts
  - ![](https://pic1.zhimg.com/80/v2-e0dc24bb8b127698ee04f322d99bb968_720w.jpg)
  - 还有初始化：InitOpts，示例：
    - import pyecharts.options as opts
    - pie = Pie(init_opts=opts.InitOpts(width="700px",height="300px")) 
- ④ **显示**及保存图表；
  - render('a.html') # html格式展示，链接分享
  - render_notebook() # 渲染到jupyter notebook

```python
# 1.选择图表类型：我们使用的是散点图，就直接从charts模块中导入Scatter这个图形。  
from pyecharts.charts import Scatter  
import numpy as np  

x = np.linspace(0,2 * np.pi,100)  
y = np.sin(x)  

(  
    # 注意：使用什么图形，就要实例化该图形的类；  
    # 2.我们绘制的是Scatter散点图，就需要实例化散点图类，直接Scatter() 即可；  
    Scatter()   
    # 实例化类后，接着就是添加数据，下面这种方式就是使用“链式调用”的方式绘图；  
    # 注意：散点图有X、Y轴，因此需要分别给X轴、Y轴添加数据；  
    # 3.我们先给X轴添加数据；  
    .add_xaxis(xaxis_data=x)  
    # 4.我们再给Y轴添加数据；  
    .add_yaxis(series_name="这个图是干嘛的",y_axis=y)  
).render_notebook()  
```

### 坐标轴设置

[pyecharts1.7 坐标轴设置：X轴、Y轴通用](https://blog.csdn.net/H_biubiu/article/details/106100656)

- type_ ：坐标轴类型， 可选：
    - 'value' 数值轴，适用于连续数据。
    - 'category' 类目轴，适用于离散的类目数据
    - 'time' 时间轴，适用于连续的时序数据，与数值轴相比时间轴带有时间的格式化，在刻度计算上也有所不同，例如会根据跨度的范围来决定使用月，星期，日还是小时范围的刻度。
    - 'log' 对数轴。适用于对数数据。


```python
from random import randint

from pyecharts import options as opts
from pyecharts.charts import Bar
from pyecharts.commons.utils import JsCode

x_data = ['分类1','分类2','分类3','分类4','分类5',]
y1_data = [0.72,0.61,0.98,0.92,0.67,]
y2_data = [d * randint(1, 10) for d in y1_data]

instance_bar = (
    Bar()
        .add_xaxis(xaxis_data=x_data)
        .add_yaxis(series_name='系列1', yaxis_data=y1_data)
        .add_yaxis(series_name='系列2', yaxis_data=y2_data)
        .set_global_opts( # 全局设置
        xaxis_opts=opts.AxisOpts( # （1）x轴设置
            type_='category',  # value数值轴，category类目轴，time时间轴，log对数轴
            name='x名称',  # Optional[str]
            is_show=True,  # bool， 是否显示坐标轴
            is_scale=False,  # bool，坐标刻度是否包含零刻度，只在数值轴中（type： ‘value’）有效。设置成 true 后坐标刻度不会强制包含零刻度。在双数值轴的散点图中比较有用。在设置 min 和 max 之后该配置项无效
            is_inverse=True,  # bool，是否是反向坐标轴
            name_location='start',  # str，坐标轴名称显示位置，'start'，'middle'/'center'，'end'
            name_gap=15,  # Numeric，坐标轴名称与轴线之间的距离
            name_rotate=20,  # Optional[Numeric]，坐标轴名字旋转，角度值
            name_textstyle_opts=opts.TextStyleOpts( # （2）坐标轴名称的文字样式
                color='blue',  # 颜色
                font_style=None,  # 字体，可选：‘normal’，‘italic’，‘oblique’
                font_weight=None,  # 粗细，可选：‘normal’，‘bold’，‘bolder’，‘lighter’
                font_family=None,  # 字体, ‘serif’ , ‘monospace’, ‘Arial’, ‘Courier New’, ‘Microsoft YaHei’, …
                font_size=None,  # 字体大小
                align=None,  # 水平对齐方式，默认自动
                vertical_align=None,  # 垂直对齐方式，默认自动
                line_height=None,  # 行高
                background_color='yellow',  # 文字块背景色。可以是直接的颜色值，例如：’#123234’, ‘red’, ‘rgba(0,23,11,0.3)’
                border_color=None,  # 文字块边框颜色
                border_width=None,  # 文字块边框高度
                border_radius=None,  # 文字块的圆角
                padding=None,  # Union[Numeric, Sequence, None]，文字块的内边距。例：padding: [3, 4, 5, 6]：表示 [上, 右, 下, 左] 的边距，padding: 4：表示 padding: [4, 4, 4, 4]，padding: [3, 4]：表示 padding: [3, 4, 3, 4]
                shadow_color=None,  # 文字块的背景阴影颜色
                shadow_blur=None,  # 文字块的背景阴影长度
                width=None,  # 文字块的宽度
                height=None,  # 文字块的高度
                rich=None,  # Optional[dict]，自定义富文本样式
            ),
            interval=30,  # Optional[Numeric]，坐标轴间隔，强制设置坐标轴分割间隔。无法在类目轴中使用。在时间轴（type： ‘time’）中需要传时间戳，在对数轴（type： ‘log’）中需要传指数值
            grid_index=0,  # Numeric，坐标轴所在的 grid 的索引，默认位于第一个 grid
            position='',  # Optional[str]，坐标轴位置可选：'top'，'bottom'，默认 grid 中的第一个 x 轴在 grid 的下方（'bottom'），第二个 x 轴视第一个 x 轴的位置放在另一侧
            offset=0,  # Numeric，坐标轴偏移，X 轴相对于默认位置的偏移，在相同的 position 上有多个 X 轴的时候有用
            split_number=5,  # Numeric，坐标轴的分割段数，需要注意的是这个分割段数只是个预估值，最后实际显示的段数会在这个基础上根据分割后坐标轴刻度显示的易读程度作调整。在类目轴中无效。
            boundary_gap='',  # Union[str, bool, None]，坐标轴两边留白策略。类目轴和非类目轴的设置和表现不一样。类目轴中 boundaryGap 可以配置为 true 和 false。默认为 true，这时候刻度只是作为分隔线，标签和数据点都会在两个刻度之间的带(band)中间。非类目轴，包括时间，数值，对数轴，boundaryGap是一个两个值的数组，分别表示数据最小值和最大值的延伸范围，可以直接设置数值或者相对的百分比，在设置 min 和 max 后无效。boundaryGap： [‘20%’, ‘20%’]
            min_='',  # Union[Numeric, str, None]，坐标轴最小值
            max_='',  # Union[Numeric, str, None]，坐标轴最大值
            min_interval=0,  # Numeric，坐标轴最小间隔，自动计算的坐标轴最小间隔大小。例如可以设置成1保证坐标轴分割刻度显示成整数。只在数值轴或时间轴中（type： ‘value’ 或 ‘time’）有效。
            max_interval=0,  # Optional[Numeric] ，坐标轴最大间隔，自动计算的坐标轴最大间隔大小。例如，在时间轴（（type： ‘time’））可以设置成 3600 * 24 * 1000 保证坐标轴分割刻度最大为一天。只在数值轴或时间轴中（type： ‘value’ 或 ‘time’）有效。
            axisline_opts=opts.AxisLineOpts( # （3）坐标轴轴线相关设置
                is_show=True, # 是否显示坐标轴轴线。
                is_on_zero=True, # X 轴或Y 轴的轴线是否在另一个轴的 0 刻度上，只有在另一个轴为数值轴且包含 0 刻度时有效。
                on_zero_axis_index=0,
                symbol=None,
                linestyle_opts=opts.LineStyleOpts( # 坐标轴线风格配置项
                    is_show=True,
                    width=1,
                    opacity=1,
                    curve=0,
                    type_="solid",
                    color=None,
                )
            ),
            axistick_opts=opts.AxisTickOpts( # （4）坐标轴刻度相关设置
                is_show=True,
                is_align_with_label=True,
                is_inside=True,
                length=20,
                linestyle_opts=opts.LineStyleOpts(
                    is_show=True,
                    width=1,
                    opacity=1,
                    curve=0,
                    type_="solid",
                    color=None,
                )
            ),
            axislabel_opts=opts.LabelOpts(
                is_show=True,  # bool
                position="top",  # Union[str, Sequence]
                color='pink',  # Optional[str]
                font_size=None,  # Optional[Numeric]
                font_style=None,  # Optional[str]
                font_weight=None,  # Optional[str]
                font_family=None,  # Optional[str]
                rotate=10,  # Optional[Numeric]
                margin=8,  # Optional[Numeric]\,
                interval=None,  # Union[Numeric, str, None]
                horizontal_align=None,  # Optional[str]
                vertical_align=None,  # Optional[str]
                formatter=JsCode("""
                function(value,index) {
                  if (index === 2) {
                    return 'formatter';
                  } else {
                    return value;
                  }
                }
                """),  # Optional[JSFunc] 回调函数
                # 字符串模板 formatter='-{value}-',
                background_color=None,  # Optional[str]
                border_color=None,  # Optional[str]
                border_width=None,  # Optional[Numeric]
                border_radius=None,  # Optional[Numeric]
                rich=None,  # Optional[dict]
            ),
            axispointer_opts=opts.AxisPointerOpts( # 坐标轴指示器设置
                is_show=True,
                link=None,
                type_="line",
                label=None,
                linestyle_opts=opts.LineStyleOpts(
                    is_show=True,
                    width=10,
                    opacity=0.5,
                    curve=0,
                    type_="solid",
                    color='green',
                ),
            ),
            splitarea_opts=opts.SplitAreaOpts( # 坐标轴在 grid 区域中的分隔区域设置
                is_show=True,
                areastyle_opts=opts.AreaStyleOpts(
                    opacity=0.05,
                    color={
                        'type': 'linear',
                        'x': 0,
                        'y': 0,
                        'x2': 0,
                        'y2': 1,
                        'colorStops': [{
                            'offset': 0, 'color': 'red'  # 0% 处的颜色
                        }, {
                            'offset': 1, 'color': 'blue'  # 100% 处的颜色
                        }],
                        'global': False  # 缺省为 false
                    }
                )

            ),
            splitline_opts=opts.SplitLineOpts( # 坐标轴在 grid 区域中的分隔线设置
                is_show=True,
                linestyle_opts=opts.LineStyleOpts(
                    is_show=True,
                    width=1,
                    opacity=1,
                    curve=0,
                    type_="solid",
                    color='#0099ff',
                )
            )

        )
    )
)
```

### 示例

```python
from pyecharts.charts import Bar

#===========过程式调用==========
bar = Bar()
bar.add_xaxis(["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"])
bar.add_yaxis("商家A", [5, 20, 36, 10, 75, 90])
# render 会生成本地 HTML 文件，默认会在当前目录生成 render.html 文件
# 也可以传入路径参数，如 bar.render("mycharts.html")
bar.render()

#============链式调用==========
from pyecharts.charts import Bar

bar = (
    Bar()
    .add_xaxis(["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"])
    .add_yaxis("商家A", [5, 20, 36, 10, 75, 90])
)
bar.render()

```
- 使用 options 配置项，在 pyecharts 中，一切皆 Options。

```python
from pyecharts.charts import Bar
from pyecharts import options as opts

# V1 版本开始支持链式调用
# 你所看到的格式其实是 `black` 格式化以后的效果
# 可以执行 `pip install black` 下载使用
bar = (
    Bar()
    .add_xaxis(["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"])
    .add_yaxis("商家A", [5, 20, 36, 10, 75, 90])
    .set_global_opts(title_opts=opts.TitleOpts(title="主标题", subtitle="副标题"))
    # 或者直接使用字典参数
    # .set_global_opts(title_opts={"text": "主标题", "subtext": "副标题"})
)
bar.render()

# 不习惯链式调用的开发者依旧可以单独调用方法
bar = Bar()
bar.add_xaxis(["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"])
bar.add_yaxis("商家A", [5, 20, 36, 10, 75, 90])
bar.set_global_opts(title_opts=opts.TitleOpts(title="主标题", subtitle="副标题"))
bar.render()

# 设置主题
from pyecharts.globals import ThemeType

bar = (
    Bar(init_opts=opts.InitOpts(theme=ThemeType.LIGHT))
    .add_xaxis(["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"])
    .add_yaxis("商家A", [5, 20, 36, 10, 75, 90])
    .add_yaxis("商家B", [15, 6, 45, 20, 35, 66])
    .set_global_opts(title_opts=opts.TitleOpts(title="主标题", subtitle="副标题"))
)
```

效果示例
- ![](https://user-images.githubusercontent.com/19553554/55602584-f2b36780-5798-11e9-8ce4-b579344b3a8f.png)

## 图表详解

- [示例](https://gallery.pyecharts.org/#/README)

### 柱形图

```python
from pyecharts.charts import Bar
from pyecharts import options as opts

# V1 版本开始支持链式调用
bar = (
    Bar()
    .add_xaxis(["衬衫", "毛衣", "领带", "裤子", "风衣", "高跟鞋", "袜子"])
    .add_yaxis("商家A", [114, 55, 27, 101, 125, 27, 105])
    .add_yaxis("商家B", [57, 134, 137, 129, 145, 60, 49])
    .set_global_opts(title_opts=opts.TitleOpts(title="某商场销售情况"))
)
bar.render()

# 不习惯链式调用的开发者依旧可以单独调用方法
bar = Bar()
bar.add_xaxis(["衬衫", "毛衣", "领带", "裤子", "风衣", "高跟鞋", "袜子"])
bar.add_yaxis("商家A", [114, 55, 27, 101, 125, 27, 105])
bar.add_yaxis("商家B", [57, 134, 137, 129, 145, 60, 49])
bar.set_global_opts(title_opts=opts.TitleOpts(title="某商场销售情况"))
#bar.render()
bar.render_notebook()
```

### 分页混合

- 【2021-8-21】多种图类型分布在一个页面的多个tab页

```python
import pyecharts.options as opts
from pyecharts.charts import Bar, Pie, Page, Tab
from pyecharts.components import Table

# 示例数据
train_list = [['NLU00000',
  '还有双鸭山到淮阴的汽车票吗13号的',
  'Travel-Query',
  'destination:淮阴+departure:双鸭山+datetime_date:13号+query_type:汽车票'],
 ['NLU00001', '从这里怎么回家', 'Travel-Query', 'destination:家+query_type:导航'],
 ['NLU00002', '随便播放一首专辑阁楼里的佛里的歌', 'Music-Play', 'album:阁楼+play_mode:随机播放'],
 ['NLU00003', '给看一下墓王之王嘛', 'FilmTele-Play', 'name:墓王之王'],
 ['NLU00004',
  '我想看挑战两把s686打突变团竞的游戏视频',
  'Video-Play',
  'name:挑战两把s686打突变团竞的游戏视频'],
 ['NLU00005', '我想看和平精英上战神必备技巧的游戏视频', 'Video-Play', 'name:和平精英上战神必备技巧的游戏视频'],
 ['NLU00006',
  '2019年古装爱情电视剧小女花不弃的花絮播放一下',
  'Video-Play',
  'name:小女花不弃的花絮+datetime_date:2019年'],
 ['NLU00007', '找一个2004年的推理剧给我看一会呢', 'FilmTele-Play', 'tag:推理+age:2004年'],
 ['NLU00008',
  '自驾游去深圳都经过那些地方啊',
  'Travel-Query',
  'destination:深圳+query_type:导航'],
 ['NLU00009',
  '给我转播今天的女子双打乒乓球比赛现场',
  'Video-Play',
  'datetime_date:今天+name:女子双打乒乓球比赛现场']]

stat_info = {'intent': {'Travel-Query': 1000,
  'Music-Play': 1000,
  'FilmTele-Play': 1000,
  'Video-Play': 1000,
  'Radio-Listen': 1000,
  'HomeAppliance-Control': 1000,
  'Weather-Query': 1000,
  'Alarm-Update': 1000,
  'Calendar-Query': 1000,
  'TVProgram-Play': 50,
  'Audio-Play': 50},
 'slot': {'destination': 917,
  'departure': 384,
  'datetime_date': 3244,
  'query_type': 945,
  'album': 158,
  'play_mode': 396,
  'name': 2236,
  'tag': 384,
  'age': 367,
'artist': 1150,
  'channel': 622,
  'song': 424,
  'instrument': 109,
  'appliance': 963,
  'command': 994,
  'details': 652,
  'index': 503,
  'city': 840,
  'datetime_time': 1143,
  'notes': 696,
  'play_setting': 233,
  'language': 152,
  'type': 419,
  'region': 458,
  'frequency': 331}}

all_num = {}
table_data = {}
for name in ('intent', 'slot'):
    all_num[name] = sum(stat_info[name].values())
    table_data[name] = [[k,v,'{:.2f}'.format(v*100/all_num[name])] for k,v in stat_info[name].items()]
# ============== 表格 =============
table_sample = Table()
headers = ['id', 'text', 'intent', 'slot_info']
rows = train_list
table_sample.add(headers, rows).set_global_opts(
    title_opts=opts.ComponentTitleOpts(title="训练集数据示例")
)

table_intent = Table()
headers = ["意图名", "频次", "占比(%)"]
rows = table_data['intent']
table_intent.add(headers, rows).set_global_opts(
    title_opts=opts.ComponentTitleOpts(title="意图分布")
)
table_slot = Table()
headers = ["槽位名", "频次", "占比(%)"]
rows = table_data['slot']
table_slot.add(headers, rows).set_global_opts(
    title_opts=opts.ComponentTitleOpts(title="槽位分布")
)
# ============== 柱形图 =============
bar_intent = (Bar()
        .add_xaxis(list(stat_info['intent'].keys()))
        .add_yaxis("意图", list(stat_info['intent'].values()))
        .set_global_opts(
            title_opts=opts.TitleOpts(title="意图频次"),
            #datazoom_opts=[opts.DataZoomOpts()], # 拖拽功能
            toolbox_opts=opts.ToolboxOpts(is_show=True), # 工具箱
        )
)
bar_slot = (Bar()
        .add_xaxis(list(stat_info['slot'].keys()))
        .add_yaxis("槽位", list(stat_info['slot'].values()))
        .set_global_opts(
            title_opts=opts.TitleOpts(title="槽位频次"),
            #datazoom_opts=[opts.DataZoomOpts()],
            toolbox_opts=opts.ToolboxOpts(is_show=True), # 工具箱
        )
)
# ============== 饼图 =============
pie_intent = (Pie()
    .add("意图分布", list(stat_info['intent'].items()),
            radius=["30%", "75%"], # radius=[40,75]，radiius:半径
            center=["25%", "50%"],
            rosetype="radius",
            label_opts=opts.LabelOpts(is_show=True))
     .set_global_opts(
        title_opts=opts.TitleOpts(title="意图占比分布"),   # TitleOpts:标题设置项
         toolbox_opts=opts.ToolboxOpts(is_show=True), # 工具箱
        legend_opts=opts.LegendOpts(pos_top="5%",pos_right="15%", orient='vertical')) #LegendOpts：图例配置项
) 
pie_slot = (Pie()
    .add("槽位分布", list(stat_info['slot'].items()),
            radius=["30%", "75%"], # radius=[40,75]，radiius:半径
            center=["25%", "50%"],
            rosetype="radius",
            label_opts=opts.LabelOpts(is_show=True))
     .set_global_opts(
        title_opts=opts.TitleOpts(title="槽位占比分布"),   # TitleOpts:标题设置项
        toolbox_opts=opts.ToolboxOpts(is_show=True), # 工具箱
        legend_opts=opts.LegendOpts(pos_top="5%",pos_right="15%", orient='vertical')) #LegendOpts：图例配置项
)
#pie.render("环形图.html")
#pie.render_notebook()
# ============== 汇总 =============
# 绘制在一张图里
# page = Page(layout=Page.SimplePageLayout)
# page.add(table_sample, table_intent, table_slot, bar_intent, bar_slot, pie_intent, pie_slot)
# page.render("ccf.html")
# page.render_notebook()

tab = Tab()
tab.add(table_sample, "训练数据样例")
tab.add(table_intent, "意图分布-表")
tab.add(table_slot, "槽位分布-表")
tab.add(bar_intent, "意图分布-柱形图")
tab.add(bar_slot, "槽位分布-柱形图")
tab.add(pie_intent, "意图分布-饼图")
tab.add(pie_slot, "槽位分布-饼图")
tab.render("ccf.html")
tab.render_notebook()
```

### 动画

【2021-6-14】按照时间线轮播，[kaggle代码地址](https://www.kaggle.com/wqw547243068/finace)

```python
# -*- coding: UTF-8 -*-
import copy
import random

NUM = 10
wealth_list = [100]*NUM
person_id = [ '编号{}'.format(i) for i in range(NUM)]
print("迭代前的财富分配：{}".format(wealth_list))
wealth_process = {}
MAX = 1000000
stop = [1, 1000, 10000, 100000, MAX]
for iter in range(MAX):
	for i,v in enumerate(wealth_list):
		send_person = random.randint(0,NUM-1)
		#print('第{}轮: {} -> {}'.format(iter, i, send_person))
		#if wealth_list[i] > 0:
		#	wealth_list[i] -= 1
		wealth_list[i] -= 1
		wealth_list[send_person] += 1
	if iter+1 in stop:
		wealth_process[iter+1] = {'data': [], 'range':[]}
		wealth_process[iter+1]['range'] = [min(wealth_list), max(wealth_list), max(wealth_list)/min(wealth_list),sum(wealth_list)/NUM]
		wealth_process[iter+1]['data'] = copy.deepcopy(wealth_list)
        
		print("迭代{}轮后的财富分配：[{},{}], 极差：{}, 均值:{}, 详情：{}".format(iter+1, 
                       *wealth_process[iter+1]['range'], wealth_process[iter+1]['data']))
print("迭代{}轮后的财富分配：{}".format(iter+1, wealth_list))


from pyecharts import options as opts
from pyecharts.charts import Bar, Timeline
from pyecharts.commons.utils import JsCode
#from pyecharts.faker import Faker

#x = Faker.choose()
x = person_id
tl = Timeline()
for i in wealth_process:
    bar = (
        Bar()
        .add_xaxis(x)
        .add_yaxis("财富值", wealth_process[i]['data'])
        #.add_yaxis("商家B", Faker.values())
        .set_global_opts(
            #title_opts=opts.TitleOpts("幂律分布：财富随机分配实验,第{}轮".format(i)),
            title_opts=opts.TitleOpts(title="幂律分布：财富随机分配实验",
                    subtitle="{}人，每人底钱100元，每轮随机给别人1元，迭代{}轮后，[{},{}], 均值{:.2f}, 极差{}".format(NUM, MAX,
                                                                             *wealth_process[i]['range'])),
            graphic_opts=[
                opts.GraphicGroup(
                    graphic_item=opts.GraphicItem(
                        rotation=JsCode("Math.PI / 4"),
                        bounding="raw",
                        right=100,
                        bottom=110,
                        z=100,
                    ),
                    children=[
                        opts.GraphicRect(
                            graphic_item=opts.GraphicItem(
                                left="center", top="center", z=100
                            ),
                            graphic_shape_opts=opts.GraphicShapeOpts(
                                width=400, height=50
                            ),
                            graphic_basicstyle_opts=opts.GraphicBasicStyleOpts(
                                fill="rgba(0,0,0,0.3)"
                            ),
                        ),
                        opts.GraphicText(
                            graphic_item=opts.GraphicItem(
                                left="center", top="center", z=100
                            ),
                            graphic_textstyle_opts=opts.GraphicTextStyleOpts(
                                text="第{}轮→马太效应".format(i),
                                font="bold 26px Microsoft YaHei",
                                graphic_basicstyle_opts=opts.GraphicBasicStyleOpts(
                                    fill="#fff"
                                ),
                            ),
                        ),
                    ],
                )
            ],
        )
    )
    tl.add(bar, "第{}轮".format(i))
tl.render("timeline_bar_with_graphic.html")
tl.render_notebook()
```


### 热力图

- [官方代码示例](https://gallery.pyecharts.org/#/Heatmap/heatmap_base)

```python
import random
from pyecharts import HeatMap

x_axis = [
    "12a", "1a", "2a", "3a", "4a", "5a", "6a", "7a", "8a", "9a", "10a", "11a",
    "12p", "1p", "2p", "3p", "4p", "5p", "6p", "7p", "8p", "9p", "10p", "11p"]
y_axis = [
    "Saturday", "Friday", "Thursday", "Wednesday", "Tuesday", "Monday", "Sunday"]
data = [[i, j, random.randint(0, 50)] for i in range(24) for j in range(7)]
# ==== 旧版过程调用 =====
heatmap = HeatMap()
heatmap.add(
    "热力图直角坐标系",
    x_axis,
    y_axis,
    data,
    is_visualmap=True,
    visual_range=[0, 1], # 取值范围
    visual_range_color=["#CDC5BF","#FF69B4", "#FF0000"], # 颜色设置
    visual_text_color="#000",
    visual_orient="horizontal",
)
heatmap.render('heatmap.html')
heatmap.render_notebook()

# === 新版链式调用 ===
from pyecharts.charts import HeatMap

heatmap = (HeatMap()
            .add_xaxis(x_axis)
            .add_yaxis("发博数", y_axis, data)
            .set_global_opts(
                title_opts=opts.TitleOpts(title="用户发博时间热力图"),
                visualmap_opts=opts.VisualMapOpts(max_=600)
            )
    )

```

![](https://pic4.zhimg.com/50/v2-c775a724d9447266ec572725392edae8_hd.webp?source=1940ef5c)

【2021-8-22】实践，参考[官方教程](https://gallery.pyecharts.org/#/Heatmap/heatmap_on_cartesian)

```python
# y轴标签 intent_list，x轴便签slot_list，数据矩阵data
data = [[x,y,intent_slot_list[y][x]] for x in range(len(slot_list)) for y in range(len(intent_list))]
heat_map = (
    HeatMap(init_opts=opts.InitOpts(width="1440px", height="720px"))
    .add_xaxis(xaxis_data=slot_list)
    .add_yaxis(
        series_name="频次",
        yaxis_data=intent_list,
        value=data,
        label_opts=opts.LabelOpts(
            is_show=True, color="#fff", position="bottom", horizontal_align="50%"
        ),
    )
    .set_series_opts()
    .set_global_opts(
        title_opts=opts.TitleOpts(title="意图槽位分布图"),
        toolbox_opts=opts.ToolboxOpts(is_show=True), # 工具箱
        legend_opts=opts.LegendOpts(is_show=False),
        xaxis_opts=opts.AxisOpts(
            type_="category",
            splitarea_opts=opts.SplitAreaOpts(
                is_show=True, areastyle_opts=opts.AreaStyleOpts(opacity=1)
            ),
        ),
        yaxis_opts=opts.AxisOpts(
            type_="category",
            splitarea_opts=opts.SplitAreaOpts(
                is_show=True, areastyle_opts=opts.AreaStyleOpts(opacity=1)
            ),
        ),
        visualmap_opts=opts.VisualMapOpts(
            min_=1, max_=1000, is_calculable=True, orient="horizontal", pos_left="center"
        ),
    )
)
```


### graph图谱

- 【2020-11-27】多轮转化图

```python
import random
import pyecharts as pe
# 为了避免显示空白，加入以下代码执行后，重新刷新当前jupyter页面即可
pe.configure(
    jshost="https://pyecharts.github.io/assets/js",
    echarts_template_dir=None,
    force_js_embed=None,
    output_image=None,
    global_theme=None
)
# 代码参考：http://pyecharts.org/#/zh-cn/charts_base?id=heatmap%EF%BC%88%E7%83%AD%E5%8A%9B%E5%9B%BE%EF%BC%89
# x_axis = ["12a", "1a", "2a", "3a", "4a", "5a", "6a", "7a", "8a", "9a", "10a", "11a",
#     "12p", "1p", "2p", "3p", "4p", "5p", "6p", "7p", "8p", "9p", "10p", "11p"]
# y_axis = ["Saturday", "Friday", "Thursday", "Wednesday", "Tuesday", "Monday", "Sunday"]
# data = [[i, j, random.randint(0, 50)] for i in range(24) for j in range(7)]
page = pe.Page('多轮对话场景分析')
title = '投诉进度查询状态转化'
# (1) 节点状态转化图
x_axis = y_axis = attr_list
item_len = len(x_axis)
data = [[x_axis[i], y_axis[j], val_list[i][j]] for i in range(item_len) for j in range(item_len)]
heatmap = pe.HeatMap()
heatmap.add(
    '%s（x -> y）'%(title),
    x_axis,
    y_axis,
    data,
    is_visualmap=True,
    visual_range=[dh.get_values().min(), dh.get_values().max()],
    visual_text_color="#000",
    visual_orient="horizontal",
)
#heatmap.render()
page.add(heatmap)

# (2) Graph图谱
from pyecharts import Graph

nodes = [{"name": "A", "symbolSize": 10},
         {"name": "B", "symbolSize": 20},
         {"name": "C", "symbolSize": 30},
         {"name": "D", "symbolSize": 40},
         {"name": "E", "symbolSize": 50},
         {"name": "F", "symbolSize": 40},
         {"name": "G", "symbolSize": 30},
         {"name": "H", "symbolSize": 20}]
links = []
for i in nodes:
    for j in nodes:
        links.append({"source": i.get('name'), "target": j.get('name')})
nodes = json.loads(json.dumps(nodes))
graph = Graph("%s-状态图"%(title))
graph.add("", nodes, links, repulsion=80000, symbol='roundRect', layout='force',edgeSymbolSize= [0, 20],edgeSymbol =['circle', 'arrow'])
#graph.render()
page.add(graph)
# 集中渲染到html文件
page.render('muti_turn_vis.html')
page
```

### 3D散点图

散点图维度绘制时，注意数轴类型，默认只把Z轴当数值，其余轴当做离散类目处理，因此会出现x、y轴数值失效的情形，此时需要单独设置x和y轴的类型。
- 注意：【2021-8-19】2D和3D设置方法不同！
- 

代码：适用于1.*以上版本

```python
import random
from pyecharts import options as  opts
#from pyecharts.charts import Scatter # 2D散点图
from pyecharts.charts import Scatter3D
from pyecharts.faker import Faker

N = 50
label = range(N)
# 数据点格式：[x,y,z,label],默认取前面数据当坐标，后面作为其他信息
Scatter_data = [(random.randint(0,N),random.randint(0,N),random.randint(0,N)) for i in range(N)]

c = (
    Scatter3D(init_opts = opts.InitOpts(width='900px',height='600px'))  #初始化
    .add("",Scatter_data,
        xaxis3d_opts=opts.Axis3DOpts(type_='value'), # 3D散点图x轴类型设置
        yaxis3d_opts=opts.Axis3DOpts(type_='value'), # 3D散点图y轴类型设置
        grid3d_opts=opts.Grid3DOpts(width=100, depth=100, rotate_speed=100, is_rotate=True)
    )
    #设置全局配置项
    .set_global_opts(
        title_opts=opts.TitleOpts(title="3D散点图"),  #添加标题
        visualmap_opts=opts.VisualMapOpts(
            max_=50, #最大值
            pos_top=50, # visualMap 组件离容器上侧的距离
            dimension=2, # 按第三(2+1)个维度取值范围来标颜色
            range_size=[10, 40], # 数据点大小
            range_color=Faker.visual_color  #颜色映射                                         
        ),
        #xaxis_opts=opts.AxisOpts(type_='value'), # 2D散点图设置数值
        #yaxis_opts=opts.AxisOpts(type_='value'),# 2D散点图设置数值
        #zaxis_opts=opts.AxisOpts(type_='value') # category
    )
)
c.render("3D散点图.html") # 保存到文件
c.render_notebook() # 输出到jupyter notebook页面
```

效果示例：

![](https://img-blog.csdnimg.cn/20210615152659376.png)


### 雷达图

打分信息可视化

```python
from pyecharts import options as opts
from pyecharts.charts import Radar

v1 = [(4300, 10000, 28000, 35000, 50000, 19000)]
v2 = [(5000, 14000, 28000, 31000, 42000, 21000)]
p = Radar().add_schema(
            schema=[
                opts.RadarIndicatorItem(name="销售", max_=6500),
                opts.RadarIndicatorItem(name="管理", max_=16000),
                opts.RadarIndicatorItem(name="信息技术", max_=30000),
                opts.RadarIndicatorItem(name="客服", max_=38000),
                opts.RadarIndicatorItem(name="研发", max_=52000),
                opts.RadarIndicatorItem(name="市场", max_=25000),
            ]
        ) \
        .add("预算分配", v1)\
        .add("实际开销", v2)\
        .set_series_opts(label_opts=opts.LabelOpts(is_show=False))
p.render('radar.html')
p.render_notebook()
```

应用

```python
import pyecharts as pe

s = {'score':[[]], 'name_cn':[], 'full_score':[]}
for i in data['factor_score']:
    s['score'][0].append(i['score'])
    s['name_cn'].append(i['name_cn'])
    s['full_score'].append(i['ref_score']['full_score'])
print(s)
print(data['total_score']['score'])
print([(s['name_cn'][i],s['full_score'][i],s['score'][i]) for i in range(len(s['score']))])
c = pe.charts.Radar()
opt = pe.options

c.add_schema(
        #schema= [ opt.RadarIndicatorItem(name=s['name_cn'][i], max_=s['full_score'][i]) for i in range(len(s['score']))]
        schema = [
            opt.RadarIndicatorItem(name=s['name_cn'][0], max_=s['full_score'][0]),
            opt.RadarIndicatorItem(name=s['name_cn'][1], max_=s['full_score'][1]),
            opt.RadarIndicatorItem(name=s['name_cn'][2], max_=s['full_score'][2]),
            opt.RadarIndicatorItem(name=s['name_cn'][3], max_=s['full_score'][3]),
            opt.RadarIndicatorItem(name=s['name_cn'][4], max_=s['full_score'][4]),
            opt.RadarIndicatorItem(name=s['name_cn'][5], max_=s['full_score'][5]),
            opt.RadarIndicatorItem(name=s['name_cn'][6], max_=s['full_score'][6]),
            opt.RadarIndicatorItem(name=s['name_cn'][7], max_=s['full_score'][7]),
        ]
    ).add("评分你好", s['score']) \
    .set_series_opts(label_opts=pe.options.LabelOpts(is_show=True))
#.add("预算分配", v1).add("实际开销", v2) \
c.render('radar.html')
c.render_notebook() 
```

### 地图数据

基础数据：
- 全球国家地图: echarts-countries-pypkg ：世界地图和 213 个国家，包括中国地图
- 中国省级地图: echarts-china-provinces-pypkg ：23 个省，5 个自治区
- 中国市级地图: echarts-china-cities-pypkg ：370 个中国城市
- 中国县区级地图: echarts-china-counties-pypkg ：2882 个中国县、区
- 中国区域地图: echarts-china-misc-pypkg ：11 个中国区域地图，比如华南、华北。

安装：

```shell
pip install echarts-countries-pypkg
pip install echarts-china-provinces-pypkg
pip install echarts-china-cities-pypkg
pip install echarts-china-counties-pypkg
pip install echarts-china-misc-pypkg
```

【2021-8-31】中国地理行政区划数据：省份、城市、区划数据，json格式：
- !wget https://github.com/nixing87/area/blob/main/json/all_province_with_adcode_key.json
- !wget https://github.com/nixing87/area/blob/main/json/all_city_with_adcode_key.json

[Pyecharts绘制可视化地图专辑-星巴克门店分析](https://jishuin.proginn.com/p/763bfbd5b04d)

#### 二维显示

- 平面显示
![](https://img-blog.csdnimg.cn/20210826111622243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBAbGhhc19kZmdoamts,size_28,color_FFFFFF,t_70,g_se,x_16)

全国地图

```python
from pyecharts import options as opts
from pyecharts.globals import ThemeType
from pyecharts.charts import Map#主题

# 省会及直辖市
data = [['江苏', 492], ['安徽', 830], ['湖南', 879], ['河南', 1073], ['浙江', 1092], ['广东', 1151], ['天津', 94], ['内蒙古', 58],
        ['北京', 337], ['陕西', 213], ['广西', 210], ['宁夏', 49], ['贵州', 109], ['上海', 295], ['江西', 771], ['福建', 261],
        ['新疆', 49], ['四川', 405], ['云南', 141], ['海南', 136], ['山东', 459], ['吉林', 80], ['黑龙江', 331], ['河北', 218],
        ['香港', 36], ['重庆', 468], ['山西', 119], ['甘肃', 83], ['湖北', 29631], ['辽宁', 107], ['台湾', 18], ['澳门', 10],
        ['青海', 18], ['西藏', 1]]

# 方法一 设置地图参数
map = (
    Map(init_opts=opts.InitOpts(bg_color="#FFFAFA", theme=ThemeType.ESSOS,width=1000))
        .add("确诊人数", data)
        .set_global_opts(
        title_opts=opts.TitleOpts(title="fungis-基于丁香园数据的疫情图"),
        # visualmap_opts=opts.VisualMapOpts(max_=2000),#使用系统默认label，最大区间值，因图而异
        visualmap_opts=opts.VisualMapOpts( # 定制label区间、名称
            is_piecewise=True,  # 设置是否为分段显示
            # 自定义的每一段的范围，以及每一段的文字，以及每一段的特别的样式。例如：
            pieces=[
                {"min": 2000, "label": '>2000人', "color": "#eb2f06"},
                {"min": 1000, "max": 2000, "label": '1001-2000人', "color": "#FF3030"},  # 不指定 max，表示 max 为无限大（Infinity）。
                {"min": 500, "max": 1000, "label": '500-1000人', "color": "#FF4500"},
                {"min": 100, "max": 499, "label": '100-499人', "color": "#FF7F50"},
                {"min": 10, "max": 99, "label": '10-99人', "color": "#FFA500"},
                {"min": 1, "max": 9, "label": '1-9人', "color": "#FFDEAD"},
            ],
            # 两端的文本，如['High', 'Low']。
            range_text=['高', '低'],
        )
    )
)
map.render(path="./html/中国疫情人数区间地图1.html")
```

城市区县地图

```python
from pyecharts.charts import Map
from pyecharts import options as opts
from pyecharts.globals import ThemeType  # 主题

# 各个城市相关数据
data = [['信阳市', 220], ['南阳市', 134], ['郑州市', 130], ['驻马店市', 123], ['商丘市', 83], ['周口市', 65], ['平顶山市', 52], ['新乡市', 46],
        ['安阳市', 45], ['许昌市', 31], ['漯河市', 30], ['洛阳市', 27], ['焦作市', 25], ['开封市', 24], ['鹤壁市', 17], ['濮阳市', 10],
        ['三门峡市', 7], ['济源市', 4]]
cityName = ['信阳市', '南阳市', '郑州市', '驻马店市', '商丘市', '周口市', '平顶山市', '新乡市', '安阳市', '许昌市', '漯河市', '洛阳市', '焦作市', '开封市', '鹤壁市',
            '濮阳市', '三门峡市', '济源市']
confirmedCount = [220, 134, 130, 123, 83, 65, 52, 46, 45, 31, 30, 27, 25, 24, 17, 10, 7, 4]
curedCount = [28, 28, 34, 14, 9, 11, 12, 6, 10, 2, 6, 2, 1, 1, 3, 0, 3, 0]
deadCount = [0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

map = (
    # 初始化配置项中可以设置画布宽高，背景色和主题
    Map(init_opts=opts.InitOpts(bg_color="#FFFAFA", theme=ThemeType.ROMANTIC, width=1000))
        .add("确诊人数", data, "河南", is_map_symbol_show=False, 
            # 【2021-9-1】地图上显示数值
            label_opts=opts.LabelOpts(
                is_show=True,
                formatter=JsCode("function(data){return data.value;}"),
            ),
        )  # 设置是否显示地图上的小红点
        .set_global_opts(
        # 标题配置项，pos_left可取值center、left、right、5%等等
        title_opts=opts.TitleOpts(title="河南疫情确诊人数分布图-fungis", pos_left="left"),
        visualmap_opts=opts.VisualMapOpts(
            is_piecewise=True,  # 设置是否为分段显示
            # 自定义的每一段的范围，以及每一段的文字，以及每一段的特别的样式。例如：
            pieces=[
                {"min": 201, "label": '>200人', "color": "#e55039"},  # 不指定 max，表示 max 为无限大（Infinity）。
                {"min": 101, "max": 200, "label": '101-200人', "color": "#FF4500"},
                {"min": 51, "max": 100, "label": '51-100人', "color": "#FF7F50"},
                {"min": 10, "max": 50, "label": '10-50人', "color": "#FFA500"},
                {"min": 1, "max": 9, "label": '1-9人', "color": "#FFDEAD"},
            ],
            # 两端的文本，如['High', 'Low']。
            range_text=['高', '低'],
        ),
    )
)
map.render(path="./河南疫情确诊人数分布图1.html")
```

#### 三维显示


[利用Python绘制酷炫的3D地图](https://blog.csdn.net/weixin_43413451/article/details/114697829)

坐标点数据

```python
from pyecharts import options as opts
from pyecharts.charts import Geo
from pyecharts.faker import Faker

c = (
    Geo()
    .add_schema(maptype="china")
    .add("geo", [list(z) for z in zip(Faker.provinces, Faker.values())])
    .set_series_opts(label_opts=opts.LabelOpts(is_show=False))
    .set_global_opts(
        visualmap_opts=opts.VisualMapOpts(), title_opts=opts.TitleOpts(title="Geo-基本示例")
    )
    #.render("geo_base.html")
)
c.render_notebook()
```

3D全国地图

```python
from pyecharts import options as opts
from pyecharts.charts import Map3D
from pyecharts.globals import ChartType
from pyecharts.commons.utils import JsCode
 
example_data = [
    ("黑龙江", [127.9688, 45.368, 100]),
    ("内蒙古", [110.3467, 41.4899, 300]),
    ("吉林", [125.8154, 44.2584, 300]),
    ("辽宁", [123.1238, 42.1216, 300]),
    ("河北", [114.4995, 38.1006, 300]),
    ("天津", [117.4219, 39.4189, 300]),
    ("山西", [112.3352, 37.9413, 300]),
    ("陕西", [109.1162, 34.2004, 300]),
    ("甘肃", [103.5901, 36.3043, 300]),
    ("宁夏", [106.3586, 38.1775, 300]),
    ("青海", [101.4038, 36.8207, 300]),
    ("新疆", [87.9236, 43.5883, 300]),
    ("西藏", [91.11, 29.97, 300]),
    ("四川", [103.9526, 30.7617, 300]),
    ("重庆", [108.384366, 30.439702, 300]),
    ("山东", [117.1582, 36.8701, 300]),
    ("河南", [113.4668, 34.6234, 300]),
    ("江苏", [118.8062, 31.9208, 300]),
    ("安徽", [117.29, 32.0581, 300]),
    ("湖北", [114.3896, 30.6628, 300]),
    ("浙江", [119.5313, 29.8773, 300]),
    ("福建", [119.4543, 25.9222, 300]),
    ("江西", [116.0046, 28.6633, 300]),
    ("湖南", [113.0823, 28.2568, 300]),
    ("贵州", [106.6992, 26.7682, 300]),
    ("广西", [108.479, 23.1152, 300]),
    ("海南", [110.3893, 19.8516, 300]),
    ("上海", [121.4648, 31.2891, 1300]),
]
 
c = (
    Map3D(init_opts=opts.InitOpts(width="1400px", height="700px"))
    .add_schema(
        itemstyle_opts=opts.ItemStyleOpts(
            color="rgb(5,101,123)",
            opacity=1,
            border_width=0.8,
            border_color="rgb(62,215,213)",
        ),
        map3d_label=opts.Map3DLabelOpts(
            is_show=False,
            formatter=JsCode("function(data){return data.name + " " + data.value[2];}"),
        ),
        emphasis_label_opts=opts.LabelOpts(
            is_show=False,
            color="#fff",
            font_size=10,
            background_color="rgba(0,23,11,0)",
        ),
        light_opts=opts.Map3DLightOpts(
            main_color="#fff",
            main_intensity=1.2,
            main_shadow_quality="high",
            is_main_shadow=False,
            main_beta=10,
            ambient_intensity=0.3,
        ),
    )
    .add(
        series_name="柱形图数据",
        data_pair=example_data,
        type_=ChartType.BAR3D, # 柱形图显示
        # type_=ChartType.SCATTER3D, # 散点图显示
        bar_size=1,
        shading="lambert",
        label_opts=opts.LabelOpts(
            is_show=False,
            formatter=JsCode("function(data){return data.name + ' ' + data.value[2];}"),
        ),
    )
    .set_global_opts(title_opts=opts.TitleOpts(title="城市数据"))
    #
)
c.render("带有数据展示地图.html")
c.render_notebook()
```

世界地图-3D

```python
import pyecharts.options as opts
from pyecharts.charts import MapGlobe
from pyecharts.faker import POPULATION
 
data = [x for _, x in POPULATION[1:]]
low, high = min(data), max(data)
 
c = (
    MapGlobe(init_opts=opts.InitOpts(width="1400px", height="700px"))
    .add_schema()
    .add(
        maptype="world",
        series_name="World Population",
        data_pair=POPULATION[1:],
        is_map_symbol_show=False,
        label_opts=opts.LabelOpts(is_show=False),
    )
    .set_global_opts(
        visualmap_opts=opts.VisualMapOpts(
            min_=low,
            max_=high,
            range_text=["max", "min"],
            is_calculable=True,
            range_color=["lightskyblue", "yellow", "orangered"],
        )
    )
)
c.render("地球.html")
#c.render_notebook()
```


### 三维数据函数可视化

示例：

```python
import math
from typing import Union

import pyecharts.options as opts
from pyecharts.charts import Surface3D

"""
Gallery 使用 pyecharts 1.1.0
参考地址: https://echarts.apache.org/examples/editor.html?c=surface-wave&gl=1

目前无法实现的功能:

1、暂时无法设置光滑表面 wireframe
2、暂时无法把 visualmap 进行隐藏
"""


def float_range(start: int, end: int, step: Union[int, float], round_number: int = 2):
    """
    浮点数 range
    :param start: 起始值
    :param end: 结束值
    :param step: 步长
    :param round_number: 精度
    :return: 返回一个 list
    """
    temp = []
    while True:
        if start < end:
            temp.append(round(start, round_number))
            start += step
        else:
            break
    return temp


def surface3d_data():
    for t0 in float_range(-3, 3, 0.05):
        y = t0
        for t1 in float_range(-3, 3, 0.05):
            x = t1
            z = math.sin(x ** 2 + y ** 2) * x / 3.14
            yield [x, y, z]


(
    Surface3D(init_opts=opts.InitOpts(width="1600px", height="800px"))
    .add(
        series_name="",
        shading="color",
        data=list(surface3d_data()),
        xaxis3d_opts=opts.Axis3DOpts(type_="value"),
        yaxis3d_opts=opts.Axis3DOpts(type_="value"),
        grid3d_opts=opts.Grid3DOpts(width=100, height=40, depth=100),
    )
    .set_global_opts(
        visualmap_opts=opts.VisualMapOpts(
            dimension=2,
            max_=1,
            min_=-1,
            range_color=[
                "#313695",
                "#4575b4",
                "#74add1",
                "#abd9e9",
                "#e0f3f8",
                "#ffffbf",
                "#fee090",
                "#fdae61",
                "#f46d43",
                "#d73027",
                "#a50026",
            ],
        )
    )
    .render("surface_wave.html")
)
```


# [smartchart](https://github.com/JohnYan2017/Echarts-Django)

- 【2021-1-2】[smartchart](https://www.smartchart.cn/blog/article/2019/6/1/3.html)
- 安装

```shell
#安装SmartChart
pip3 install smartchart
pip3 install smartchart -U #(升级)
# 如果安装过程慢,建意使用
pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple smartchart
#如果你是第一次安装SmartChart(注意,非第一次不要执行,会覆盖原有DB)
pip3 install smartdb # (初始化DB)
```


# PyGraphviz

## 介绍
- 【2020-8-4】[PyGraphviz (几何图形可视化工具) 简单入门](https://zhuanlan.zhihu.com/p/104636240)
- [Graphviz](https://graphviz.org/download/) 是一个几何图形可视化软件，能够将数据的结构信息表示为抽象图形和网络图的方式。
- PyGraphviz 主要对数据量大、可任意定制的图形上具有强大优势。
- 建议：由于 PyGraphviz 暂时无法对同源节点合并线段。在流程图、小型结构图方面，Visio 可以作为 Graphviz 的直接替代软件。

## 安装

- 各操作系统下的安装

```shell
brew install graphviz # mac
pip install graphviz # linux
conda install graphviz # conda
```

## 使用

```python
import pygraphviz as pgv
# 创建图形
G = pgv.AGraph(directed=True, strict=False, nodesep=0, ranksep=1.2, rankdir="TB",
               splines="none", concentrate=True, bgcolor="write",
               compound=True, normalize=False, encoding='UTF-8')
# 添加节点
G.add_node(name, label=None, fontname="Times-Roman", fontsize=14,
           shape="ellipse", style="rounded", color="black", fontcolor="black",
           pos="x,y(!)", fixedsize=False, width=1, height=1)

G.add_nodes_from(names, **attr) # 批量添加点，参数同上 
# 添加边
G.add_edge(origin, target, color="black", style="solid", penwidth=1,
           label="", fontname="Times-Roman", fontsize=14, fontcolor="black",
           arrowsize=1, arrowhead="normal", arrowtail="normal", dir="forward")
# label -> str：边标签，未指定时不显示
# penwidth：线条粗细
# arrowsize：箭头大小
# arrowhead：箭头类型，可选 normal, vee
# dir：箭头方向，可选 both, forward, back, none。只有在无向图中才起作用！
G.add_nodes_from([[origin_1, target_1],
                  [origin_2, target_2],...], **attr)  # 批量添加线，参数同上
# 导出图形
G.layout()
G.draw(file_name, prog="neato")
# prog：布局算法，可选 neato, dot (推荐), twopi, circo, fdp

```

- 创建图：
    - directed -> False \| True：有向图
    - strict -> True \| False：简单图
    - nodesep：同级节点最小间距
    - ranksep：不同级节点最小间距
    - rankdir：绘图方向，可选 TB (从上到下), LR (从左到右), BT (从下到上), RL (从右到左)
    - splines：线条类型，可选 ortho (直角), polyline (折线), spline (曲线), line (线条), none (无)
    - concentrate -> True \| False：合并线条 (双向箭头)
    - bgcolor：背景颜色
    - compound -> True \| False：多子图时，不允许子图相互覆盖
    - normalize -> False \| True：以第一个节点作为顶节点
- 添加节点
    - name -> str：节点名。label 为节点标签，未指定时显示 name
    - fontname：字体名称，常用：Microsoft YaHei, SimHei, KaiTi, SimSun, FangSong, Times-Roman, Helvetica, Courier。可以使用 "times bold italic" 表示字体类型、粗细、倾斜
    - fixedsize -> Flase \| True \| "shape"`：固定大小，默认随文本长度变化。设置为 True 时，width 和 height 参数共同控制点大小。设置为 "shape" 时，将取标签文本和设置值的较大者
    - pos -> str：点的初始位置。使用 "x,y!" 时，可以强制固定点的位置。
    - style：节点线样式，使用 `color` 设置线条颜色 (style="filled" 时，设置填充颜色)
        - ![](https://pic2.zhimg.com/80/v2-bd489505b51d33d230d0f26a83a5cced_720w.png)
    - shape: 节点形状
        - ![](https://pic3.zhimg.com/80/v2-f9785df4406b61d27be1e4b73919b688_720w.jpg)


## 案例

### 因果关系图

- 效果：
![](https://pic1.zhimg.com/80/v2-ee8eea4bf4ae7307281ff7f448563c45_720w.jpg)
- 代码：

```python
import pygraphviz as pgv

G = pgv.AGraph(directed=True, strict=False, ranksep=0.2, splines="spline", concentrate=True)

# 设置节点标签
nodeA = "Police\nIntelligence"
nodeB = "Police Station"
nodeC = "Criminal Action"
nodeD = "Incidents"
nodeE = "Police Dockets"
nodeF = "Control Room\nAwareness"
nodeG = "Patroller Information"
nodeH = "Patroller Awareness"

# 添加节点
G.add_nodes_from([nodeA, nodeB, nodeC, nodeD, nodeE, nodeF, nodeG, nodeH],
                 color="#ffffff", fontname="times bold italic")

# 添加边
G.add_edges_from([[nodeA, nodeB], [nodeA, nodeF], [nodeB, nodeC], [nodeC, nodeD],
                  [nodeC, nodeG], [nodeD, nodeE], [nodeD, nodeG], [nodeE, nodeA],
                  [nodeF, nodeA], [nodeF, nodeG], [nodeF, nodeH], [nodeG, nodeF],
                  [nodeH, nodeG]], color="#7F01FF", arrowsize=0.8)

# 导出图形
G.layout()
G.draw("因果关系图.png", prog="dot")
```

### 因子相关性图

- 效果：
![](https://pic2.zhimg.com/80/v2-16cb830982e85989b8b8a53ba8e7e7e9_720w.jpg)
- 代码：

```python
import pygraphviz as pgv

G = pgv.AGraph(directed=True, rankdir="TB")

# 设置节点标签
Root = "道路交通流畅"
negative_1 = "平均延误时间"
negative_2 = "负荷度"
negative_3 = "小区位置"
negative_4 = "相对延误率"
negative_5 = "房屋密度"
negative_6 = "人口密度"
negative_7 = "总延误率"
negative_8 = "排队率"
negative_9 = "行驶时间"
positive_1 = "通行能力"
positive_2 = "公路层级"
positive_3 = "路网结构"
positive_4 = "行驶速度"
positive_5 = "路网长度"
positive_6 = "小区面积"
positive_7 = "内部道路密度"
positive_8 = "路网密度"

# 添加节点
G.add_node(Root, style="filled", shape="box3d", color="#feb64d")
for negative in [eval(_) for _ in dir() if _.startswith("negative")]:
    G.add_node(negative, style="filled", shape="ellipse", color="#CFDBF6")

for positive in [eval(_) for _ in dir() if _.startswith("positive")]:
    G.add_node(positive, style="filled", shape="ellipse", color="#B4E7B7")

# 添加边
G.add_edges_from([[Root, negative_1], [Root, negative_6], [Root, negative_8], [Root, negative_9],
                  [negative_1, negative_2], [negative_1, negative_7], [negative_2, negative_3],
                  [negative_2, negative_7], [negative_3, negative_4], [negative_8, negative_9],
                  [positive_2, negative_5], [positive_3, negative_4], [positive_4, negative_5]],
                 color="#B4DBFF", style="dashed", penwidth=1.5)

G.add_edges_from([[Root, positive_1], [Root, positive_8], [negative_5, negative_4],
                  [negative_6, positive_4], [negative_5, positive_4], [negative_9, positive_5],
                  [positive_1, positive_2], [positive_2, positive_3], [positive_6, positive_5],
                  [positive_7, positive_6], [positive_8, positive_7]],
                 color="#B4E7B7", style="dashed", penwidth=1.5)

# 导出图形
G.layout()
G.draw("因子相关性图.png", prog="dot")
```

### 神经网络图

- 效果：
![](https://pic3.zhimg.com/80/v2-c3f55cc605a0cf341faf7540a76cb53b_720w.jpg)
- 代码：

```python
import pygraphviz as pgv

G = pgv.AGraph(directed=True, rankdir="LR")

# 设置层数、每层节点数
network_structure = input("输入神经网络每层节点数，如：[10, 7, 5, 4, 2, 1]\n")
all_nodes = [[f"layer{layer_index}node{node_index}" for node_index in range(layer_nodes_num)] for
             layer_index, layer_nodes_num in enumerate(eval(network_structure))]

# 添加输入层节点
for node_index, node in enumerate(all_nodes[0]):
    G.add_node(node, label="", shape="circle", style="bold", color="#60acfc", pos=f"0,{0.6 * node_index}!")

# 添加输入层文本
G.add_node(f"Input_Layer", shape="none", label=f"Input_Layer({len(all_nodes[0])})",
           pos=f"{0},{(node_index + 1) * 0.6}!")

# 添加中间层、输出层节点
for layer_index, layer in enumerate(all_nodes[1:]):
    color = "#5bc49f" if layer_index == len(all_nodes[1:]) - 1 else "#ff7c7c"

    for node_index, node in enumerate(layer):
        x = 1.5 * (layer_index + 1)
        y = - 0.3 * (len(all_nodes[layer_index + 1]) - len(all_nodes[0])) + 0.6 * node_index
        G.add_node(node, label="", shape="circle", style="bold", color=color, pos=f"{x},{y}!")

    # 添加中间层、输出层文本
    text = f"Output_Layer({len(all_nodes[-1])})" if layer_index == len(all_nodes[1:]) - 1 else f"Layer_{layer_index + 1}({len(layer)})"
    G.add_node(f"Layer_{layer_index + 1})", shape="none", label=text,
               pos=f"{x},{y + 0.4}!")

# 添加线
for layer_index in range(all_nodes.__len__() - 1):
    for start in all_nodes[layer_index]:
        for end in all_nodes[layer_index + 1]:
            G.add_edge(start, end)

# 导出图形
G.layout()
G.draw("神经网络.png")

# 运行代码，输入 [5, 10, 15, 15, 15, 10, 5, 1]
```

### 有限状态机FSM的可视化

- 有限状态机（Finite-state machine, FSM），又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。FSM是一种算法思想，简单而言，有限状态机由一组状态、一个初始状态、输入和根据输入及现有状态转换为下一个状态的转换函数组成。
- [Transitions](https://github.com/pytransitions/transitions)
- [Python的Transitions库实现有限状态机(FSM)](https://www.jianshu.com/p/decf86e0e420)

```python
from transitions.extensions import GraphMachine

states = ['first', 'second']
transitions = [
    ['any_trigger', 'first', 'first'],
    ['anything', '*', 'second'],
]

machine = GraphMachine(states=states, transitions=transitions, initial='first',
                       auto_transitions=False, show_conditions=True)

machine.get_graph().draw('fsm.png', prog='dot')
from IPython.display import Image
Image('fsm.png')
```

- 结果
![](https://upload-images.jianshu.io/upload_images/618241-70acdf59c5f312c8.png)

# turtle工具

[python中的画图神器——turtle模块](https://zhuanlan.zhihu.com/p/106388608)

turtle库的基础命令介绍

## 画布

画布cancas是绘图区域，可以设置它的大小和初始位置

```python
turtle.screensize(1000,600,'red')    # 大小的设置
turtle.setup(width=0.5,height=0.75)  # 初始位置
```

## 画笔

### （1）画笔运动的命令

```python
turtle.forward(a)   # 向当前画笔方向移动a像素长度
turtle.backward(a)  # 向当前画笔相反方向移动a像素长度
turtle.right(a)     # 顺时针移动
aturtle.left(a)     # 逆时针移动
aturtle.pendown()   # 移动时绘制图形
turtle.goto(x,y)    # 将画笔移动到坐标为x,y的位置
turtle.penup()      # 移动时不绘制图形，提起笔
turtle.speed(a)     # 画笔绘制的速度范围
turtle.circle()     # 画图，半径为正，表示圆心在画笔的左边画圈
```

### （2）画笔控制命令

```python
turtle.pensize(width)   # 绘制图形的宽度
turtle.pencolor()       # 画笔的颜色
turtle.fillcolor(a)     # 绘制图形的填充颜色
turtle.color(a1,a2)     # 同时设置pencolor=a1,fillcolor=a2
turtle.filling()        # 返回当前是否在填充状态
turtle.begin_fill()     # 准备开始填充图形
turtle.end_fill()       # 填充完成
turtle.hideturtle()     # 隐藏箭头显示
turtle.showturtle()     # 显示箭头
```

### （3）全局控制命令

```python
turtle.clear()   # 清空turtle窗口,但是turtle的位置和状态不会改变
turtle.reset()   # 清空窗口，重置turtle状态为起始位置
turtle.undo()    # 撤销上一个turtle动作
```

## 实战

[原文](https://zhuanlan.zhihu.com/p/106388608)涉及案例：樱花、玫瑰花、皮卡丘、星空、小黄人、单身狗等

### 爱心

![img](https://pic1.zhimg.com/80/v2-1fc08ade2e2384dd1e2634f4a696bb9c_1440w.jpg)

```python
from turtle import *

color('red', 'pink')  # 画笔色red，背景色pink
begin_fill()
left(135)  # 左转135°
fd(100)  # 前进100像素
right(180)  # 画笔掉头

circle(30, -180)

backward(35)  # 由于此时画笔方向约为绝对方向的135°，需倒退画线
right(90)
forward(35)
circle(-30, 180)
fd(100)
end_fill()
hideturtle()
done()
```


# 元胞自动机

[Python 实现最简单的元胞自动机](https://zhuanlan.zhihu.com/p/60819315)

## 介绍

元胞自动机（cellular automata) 是离散而抽象的计算系统。元胞自动机在时间和空间上是离散的，最小单位是简单元胞（单元格）。每个元胞会产生有限数量的状态集，后续元胞由其邻域元胞的状态确定。这里所说的领域元胞，是指当前元胞的前一个元胞(记作元胞A)以及元胞A左右两个元胞。也就是说，邻域元胞总共包含三个元胞。给定初始层的状态，基于一定规则，我们可以不断更新下一层元胞的状态。通俗的讲，元胞自动机就是基于一定规则的“繁衍机器”。

## 示例

![img](https://pic2.zhimg.com/80/v2-2481140be1abc12abf77784c7516ce31_720w.jpg)

```python
import time


def print_seq(seq, speed=0.5):
    for item in seq:
        if item:
            print('*', end='')
        else:
            print('-', end='')
    print('')
    time.sleep(speed)


class Cell:
    def __init__(self, deepth=31):
        self.ca = [0 if i != 31 else 1 for i in range(64)]
        self.ca_new = []
        self.deepth = deepth

    def process(self):
        print_seq(self.ca)
        for i in range(self.deepth):
            self._rule()
            print_seq(self.ca_new)
            self.ca = self.ca_new
            self.ca_new = []

    def _rule(self):
        for i in range(64):
            if 0 < i < 63:
                if self.ca[i - 1] == self.ca[i + 1]:
                    self.ca_new.append(0)
                else:
                    self.ca_new.append(1)
            elif i == 0:
                if self.ca[1]:
                    self.ca_new.append(1)
                else:
                    self.ca_new.append(0)
            else:
                if self.ca[62]:
                    self.ca_new.append(1)
                else:
                    self.ca_new.append(0)

def main():
    cell = Cell()
    cell.process()


if __name__ == '__main__':
    main()
```



# 分形几何

分形几何学的基本思想：客观事物具有**自相似性**的层次结构，局部和整体在形态，功能，信息，时间，空间等方面具有统计意义上的相似性，称为自相似性，自相似性是指局部是整体成比例缩小的性质。

## 分形理论

自然界的很多事物，例如树木、云彩、山脉、闪电、雪花以及海岸线等等都呈现出传统的几何学不能描述的形状。这些形状都有如下的特性：
- 有着十分精细的不规则的结构
- 整体与局部相似，例如一根树杈的形状和一棵树很像
分形几何学就是用来研究这样一类的几何形状的科学，借助计算机的高速计算和图像显示，使得我们可以更加深入地直观地观察分形几何。

## 图形绘制

【2021-9-1】分形几何图形绘制，参考：
- [分形与混沌](https://wizardforcel.gitbooks.io/hyry-studio-scipy/content/24.html)
- [Python 绘制分形图（曼德勃罗集、分形树叶、科赫曲线、分形龙、谢尔宾斯基三角等）](https://zhuanlan.zhihu.com/p/25792397)

### 曼德勃罗集

![img](https://pic2.zhimg.com/80/v2-bd5df212248a6fcfdba43896c455fb39_1440w.png)

```python
import numpy as np
import pylab as pl
import time
from matplotlib import cm

def iter_point(c):
    z = c
    for i in xrange(1, 100): # 最多迭代100次
        if abs(z)>2: break # 半径大于2则认为逃逸
        z = z*z+c
    return i # 返回迭代次数

def draw_mandelbrot(cx, cy, d):
    """
    绘制点(cx, cy)附近正负d的范围的Mandelbrot
    """
    x0, x1, y0, y1 = cx-d, cx+d, cy-d, cy+d 
    y, x = np.ogrid[y0:y1:200j, x0:x1:200j]
    c = x + y*1j
    start = time.clock()
    mandelbrot = np.frompyfunc(iter_point,1,1)(c).astype(np.float)
    print "time=",time.clock() - start
    pl.imshow(mandelbrot, cmap=cm.jet, extent=[x0,x1,y0,y1])
    pl.gca().set_axis_off()

x,y = 0.27322626, 0.595153338

pl.subplot(231)
draw_mandelbrot(-0.5,0,1.5)
for i in range(2,7):    
    pl.subplot(230+i)
    draw_mandelbrot(x, y, 0.2**(i-1))
pl.subplots_adjust(0.02, 0, 0.98, 1, 0.02, 0)
pl.show()
```

### 分形树

用turtle动态绘制分形树

![img](https://img-blog.csdn.net/20171221152808602?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

```python
## 绘制分型树,末梢的树枝的颜色不同
import turtle

def draw_brach(brach_length):
    if brach_length > 5:
        if brach_length < 40:
            turtle.color('green')
        else:
            turtle.color('red')

        # 绘制右侧的树枝
        turtle.forward(brach_length)
        print('向前',brach_length)
        turtle.right(25)
        print('右转20')
        draw_brach(brach_length-15)
        # 绘制左侧的树枝
        turtle.left(50)
        print('左转40')
        draw_brach(brach_length-15)

        if brach_length < 40:
            turtle.color('green')
        else:
            turtle.color('red')

        # 返回之前的树枝上
        turtle.right(25)
        print('右转20')
        turtle.backward(brach_length)
        print('返回',brach_length)

def main():
    turtle.left(90)
    turtle.penup()
    turtle.backward(150)
    turtle.pendown()
    turtle.color('red')

    draw_brach(100)

    turtle.exitonclick()

if __name__ == '__main__':
    main()
```

樱花树

```python
from turtle import *
from random import *
from math import *

def tree(n, l):
    pd() # 下笔
 # 阴影效果
 t = cos(radians(heading() + 45)) / 8 + 0.25
 pencolor(t, t, t)
    pensize(n / 3)
    forward(l) # 画树枝
 if n > 0:
        b = random() * 15 + 10 # 右分支偏转角度
 c = random() * 15 + 10 # 左分支偏转角度
 d = l * (random() * 0.25 + 0.7) # 下一个分支的长度
 # 右转一定角度，画右分支
 right(b)
        tree(n - 1, d)
 # 左转一定角度，画左分支
 left(b + c)
        tree(n - 1, d)

 # 转回来
 right(c)
 else:
 # 画叶子
 right(90)
        n = cos(radians(heading() - 45)) / 4 + 0.5
 pencolor(n, n*0.8, n*0.8)
        circle(3)
        left(90)

 # 添加0.3倍的飘落叶子
 if(random() > 0.7):
            pu()
 # 飘落
 t = heading()
            an = -40 + random()*40
 setheading(an)
            dis = int(800*random()*0.5 + 400*random()*0.3 + 200*random()*0.2)
            forward(dis)
            setheading(t)

 # 画叶子
 pd()
            right(90)
            n = cos(radians(heading() - 45)) / 4 + 0.5
 pencolor(n*0.5+0.5, 0.4+n*0.4, 0.4+n*0.4)
            circle(2)
            left(90)
            pu()
 #返回
 t = heading()
            setheading(an)
            backward(dis)
            setheading(t)
    pu()
    backward(l)# 退回
bgcolor(0.5, 0.5, 0.5) # 背景色
ht() # 隐藏turtle
speed(0) # 速度，1-10渐进，0最快
tracer(0, 0)
pu() # 抬笔
backward(100)
left(90) # 左转90度
pu() # 抬笔
backward(300) # 后退300
tree(12, 100) # 递归7层
done()
```


### 分形树叶

![img](https://pic3.zhimg.com/80/v2-8a45f2b2aeaf61d1ec341a42a889e1fe_1440w.png)


```python
import numpy as np
import matplotlib.pyplot as pl
import time

# 蕨类植物叶子的迭代函数和其概率值
eq1 = np.array([[0,0,0],[0,0.16,0]])
p1 = 0.01

eq2 = np.array([[0.2,-0.26,0],[0.23,0.22,1.6]])
p2 = 0.07

eq3 = np.array([[-0.15, 0.28, 0],[0.26,0.24,0.44]])
p3 = 0.07

eq4 = np.array([[0.85, 0.04, 0],[-0.04, 0.85, 1.6]])
p4 = 0.85

def ifs(p, eq, init, n):
"""
    进行函数迭代
    p: 每个函数的选择概率列表
    eq: 迭代函数列表
    init: 迭代初始点
    n: 迭代次数

    返回值： 每次迭代所得的X坐标数组， Y坐标数组， 计算所用的函数下标    
    """

# 迭代向量的初始化
pos = np.ones(3, dtype=np.float)
pos[:2] = init

# 通过函数概率，计算函数的选择序列
p = np.add.accumulate(p)    
rands = np.random.rand(n)
select = np.ones(n, dtype=np.int)*(n-1)
for i, x in enumerate(p[::-1]):
select[rands<x] = len(p)-i-1

# 结果的初始化
result = np.zeros((n,2), dtype=np.float)
c = np.zeros(n, dtype=np.float)

for i in range(n):
eqidx = select[i] # 所选的函数下标
tmp = np.dot(eq[eqidx], pos) # 进行迭代
pos[:2] = tmp # 更新迭代向量

# 保存结果
result[i] = tmp
c[i] = eqidx

return result[:,0], result[:, 1], c

start = time.clock()
x, y, c = ifs([p1,p2,p3,p4],[eq1,eq2,eq3,eq4], [0,0], 100000)
time.clock() - start
pl.figure(figsize=(6,6))
pl.subplot(121)
pl.scatter(x, y, s=1, c="g", marker="s", linewidths=0)
pl.axis("equal")
pl.axis("off")
pl.subplot(122)
pl.scatter(x, y, s=1,c = c, marker="s", linewidths=0)
pl.axis("equal")
pl.axis("off")
pl.subplots_adjust(left=0,right=1,bottom=0,top=1,wspace=0,hspace=0)
pl.gcf().patch.set_facecolor("#D3D3D3")
pl.show()
```

### 其它分形图(科赫曲线、分形龙、谢尔宾斯基三角等)

![img](https://pic1.zhimg.com/80/v2-824736899082436410dfce4bf60474dc_1440w.png)

```python
from math import sin, cos, pi
import matplotlib.pyplot as pl
from matplotlib import collections

class L_System(object):
def __init__(self, rule):
info = rule['S']
for i in range(rule['iter']):
ninfo = []
for c in info:
if c in rule:
ninfo.append(rule[c])
else:
ninfo.append(c)
info = "".join(ninfo)
self.rule = rule
self.info = info

def get_lines(self):
d = self.rule['direct']
a = self.rule['angle']
p = (0.0, 0.0)
l = 1.0
lines = []
stack = []
for c in self.info:
if c in "Ff":
r = d * pi / 180
t = p[0] + l*cos(r), p[1] + l*sin(r)
lines.append(((p[0], p[1]), (t[0], t[1])))
p = t
elif c == "+":
d += a
elif c == "-":
d -= a
elif c == "[":
stack.append((p,d))
elif c == "]":
p, d = stack[-1]
del stack[-1]
return lines

rules = [
{
"F":"F+F--F+F", "S":"F",
"direct":180,
"angle":60,
"iter":5,
"title":"Koch"
},
{
"X":"X+YF+", "Y":"-FX-Y", "S":"FX",
"direct":0,
"angle":90,
"iter":13,
"title":"Dragon"
},
{
"f":"F-f-F", "F":"f+F+f", "S":"f",
"direct":0,
"angle":60,
"iter":7,
"title":"Triangle"
},
{
"X":"F-[[X]+X]+F[+FX]-X", "F":"FF", "S":"X",
"direct":-45,
"angle":25,
"iter":6,
"title":"Plant"
},
{
"S":"X", "X":"-YF+XFX+", "Y":"+XF-YFY-FX+",
"direct":0,
"angle":90,
"iter":6,
"title":"Hilbert"
},
{
"S":"L--F--L--F", "L":"+R-F-R+", "R":"-L+F+",
"direct":0,
"angle":45,
"iter":10,
"title":"Sierpinski"
},

]

def draw(ax, rule, iter=None):
if iter!=None:
rule["iter"] = iter
lines = L_System(rule).get_lines()
linecollections = collections.LineCollection(lines)
ax.add_collection(linecollections, autolim=True)
ax.axis("equal")
ax.set_axis_off()
ax.set_xlim(ax.dataLim.xmin, ax.dataLim.xmax)
ax.invert_yaxis()

fig = pl.figure(figsize=(7,4.5))
fig.patch.set_facecolor("papayawhip")

for i in xrange(6):
ax = fig.add_subplot(231+i)
draw(ax, rules[i])

fig.subplots_adjust(left=0,right=1,bottom=0,top=1,wspace=0,hspace=0)
pl.show()
```


# 图灵斑图

【2021-9-24】[图灵YYDS！60年前不被看好的理论再次被证，这次是原子层面的](https://www.toutiao.com/i6999522250848207399/)

你以为，斑马的黑白条纹，贝壳的复杂花纹，都只是随便长长？并不！

这些自然界的重复图案，有相当一部分能用一组方程式描述。听上去有些离谱，但确实是图灵本人搞出来的——60年前，他对大自然进行一番研究后，给出了这组方程式。
- ![](https://p6-tt.byteimg.com/origin/pgc-image/fd8aab8b19c746648f86ae4aefc48047.png?from=pc)
- 公式认为，任何重复的自然图案，都是通过两种具有特定特征的事物（如分子、细胞）进行相互作用而产生的。
  - 两种事物的特定特征为：速度不同、能在空间内传播、其中一种是催化剂。这种催化剂，能自动激活、并随后产生抑制剂，使得它比催化剂的传播速度更快，导致催化剂中途停止，最终生成相应的图案。
  - ![](https://p6-tt.byteimg.com/origin/pgc-image/8a767b682543427ca6e5172b28723fee?from=pc)
- 只需要对反应扩散方程的不同条件进行约束，这两种事物，就能自发地组成斑纹、条纹、环纹、螺旋或斑点等图案。
这组方程式适用于不少自然界的图案，包括斑马、贝壳、鱼类、豹的条纹等。他们给这类图案统一起了个名字，叫**图灵斑图** （turing pattern）.但无论是斑马、豹、贝壳还是鱼类，基本都属于宏观尺度的图案，微观尺度上的图灵斑图研究少之又少。现在，来自斯坦福等高校的科学家终于发现，一种晶体生长的微观纹路，也可以用图灵斑图来描述,这种晶体名叫**铋**，它在特殊条件下的原子生长模式，与图灵方程式预测的形态非常相似，目前研究成果已经刊登到Nature Physics上。仅凭一组公式预测图案的图灵，60年后再次跨越了微观和宏观的界限。
- ![](https://p6-tt.byteimg.com/origin/pgc-image/182740d45cf24eaa9450635411a4f957.png?from=pc)



# 结束



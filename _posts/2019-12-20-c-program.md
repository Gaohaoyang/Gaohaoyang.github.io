---
layout: post
title:  C++学习笔记
subtitle:   C++ Primer 学习记录
date:   2019-12-20 15:17:00
author:  wangqiwen
categories: 编程语言
tags: C C++
excerpt: C/C++编程语言笔记
mathjax: true
header-img: img/post-bg-ios10.jpg
catalog: true
---

* content
{:toc}


# C++ Primer学习笔记

> 2019-4-17 [地址](https://github.com/wangpengcheng/wangpengcheng.github.io/tree/master/_posts)

## 第1章 开始
### std::cin 中的循环流使用
_参考链接：_[while(cin >> num)循环输入问题](https://bbs.csdn.net/topics/390809866)[C++ cin输入流 详细用法](https://blog.csdn.net/imkelt/article/details/51925479);

C++ 中可以使用`while(std::cin >> value){//Code }`的方式来进行循环数据的读入，直到没有输出为止；示例代码如下：
```c++
/*
输入样例： 3 4 5 6
输出 ： Sum is :18
 */

#inlude <iostream>
int main()
{
    int sum =0;value=0;
    //循环读取数据

    while(std::cin>>value){
        sm+=value;
    }
    std::out<<"Sum is:"<<sum<<std:endl;
    return 0;
}
```
注意：

* 当键盘向程序中输入数据时，对于文件结束；Windows是`Ctrl+Z`然后 `Enter`或者`Return`;UNIX 中是`Ctrl+D` 然后再加`enter`;
* 当缓冲区中有残留数据时，`std::cin`会直接去读取缓冲区的数据而不会请求键盘输入。重要的是，回车符也会被存在输入缓冲区中。
* 当程序中有多个等待循环输入时，需要使用`cin.clear()`来重置循环状态，方便再次输入; 

# 第二章 变量和基本类型

## C++变量和基本类型
### C++中的基本类型
_参考链接：_[C/C++中基本数据类型所占内存大小](https://blog.csdn.net/zcyzsy/article/details/77935651);[C/C++中基本数据类型在不同系统中所占空间大小](https://blog.csdn.net/yimingsilence/article/details/54730438);

C++中定义了算术类型(arithmetic type)和空类型(void)在内的基础数据结构算术类型表如下：

| 类型 | 含义 | 最小尺寸 |
|:------------:|:---------------:|:-----:|
| bool         | 布尔类型| 未定义 |
| char | centered | 8位 |
| wchart_t | 宽字符 | 16位 |
| chart16_t | Unicode字符 | 16位 |
| chart32_t | Unicode字符 | 32位 |
| short | 短整型 | 16位 |
| int | 整型 | 16位 |
| long | 长整型 | 32位 |
| long long | 长整型 | 64位 |
| float | 单精度浮点数 | 6位有效数字 |
| double | 双精度浮点数 | 10位有效数字 |
| long double | 扩展精度浮点数 | 10位有效数字 |

注意：

* 关于不同类型，字节内存分配的问题，不同的操作系统存在不同的内存分配策略；因此不一定按照上面的进行分配；详细内容参看参考链接。
* 对于C++中的字节对齐内容需要重点考虑([C++ 字节对齐的总结(原因和作用)](https://blog.csdn.net/sweetfather/article/details/78487563);[C/C++ 字节对齐](https://blog.csdn.net/chengonghao/article/details/51674166));
* c++中除去布尔类型和扩展的字符类型之外，其它类型可以划分为带符号的(signed)和无符号的(unsigned)两种；无符号仅能表示大于0的值。器字节内存分配也有所不同；（[C/C++ unsigned 详细探讨](https://blog.csdn.net/zhenlin123/article/details/81062635)）;

### C++中的声明和定义
C++中使用分离式编译机制，允许每个文件被单独编译；为了支持这种模式；C++语言将声明和定义区分开来；声明(declaration) 使得名字为程序所知；定义（definition）负责创建与名字关联的实体。
如果想要声明一个变量而非定义它，就在变量名字前添加关键字`extern`;而且不要显示的初始化变量：
```c++
extern int i ;//声明i 而非定义i

int j;//声明并定义j
```
### C++中的类型转换：
C++中的类型转换分为显式转换和隐式转换2种；显式转换直接在代码中注明其转换类型;如`double a=1.002;int i=(int)a;`将类型进行显式转换；同时也存在隐式转换；如`int i=10/1.0`;其中`10/1.0`即包含隐式的`int`到`double`的转换，`=`又进行了一次`double`到`int`的隐式转换；隐式转换在编码规范中不推荐；应该劲量使用显式转换；

```c++
bool b=42;      //b为真

int i=b;        //i的值为1

i=3.14;         //i的值为3

double pi=i;    //pi的值为3.0

unsigned char c=-1; //假设char占a比特，c的值为255

signed char c2=256; //假设char:占8比特，c2的值是未定义的
```
* 当数字加减超过数据类型的取值范围的时候，就会按照位运算进行取模，输出结果是取模之后的结果（[C++ 带符号和无符号char类型赋值超出表示范围的情况](https://blog.csdn.net/eastlhu/article/details/72809256)）；

例如：8比特大小的unsigned char可以表示0至255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256（总数）取模后所得的余数。
因此，把-1赋给8比特大小的unsigned char所得的结果是255，使用2种方法计算：

> 有整数a和b，a对b进行取模或取余运算
> 
> 1、求整数商：c=a/b
> 
> * 取模运算在计算商值向负无穷方向舍弃小数位
> * 取余运算在计算商值向0方向舍弃小数位
>
> 2、计算模或者余数：r=a-(c*b)
> 
> * 取模运算遵循尽可能让商小，取余运算遵循尽可能让余数的绝对值小。因此，取模和取余的结果不同。
> * mod为取模，rem为取余，取模和取余所得的结果在a和b(同为整数) 符号相同 的时候是相等的
> * 当a和b符号一致时，求模运算和求余运算所得的c的值一致，因此结果一致。但是当符号不一致的时候，结果不一样。
> * 具体来说，求模运算结果的符号和b一致，求余运算结果的符号和a一致

在本例中，将-1和256带入a和b，c=-1/256，向负无穷方向舍弃小数得-1，计算得r=255.
> 计算机中带符号的整数采用二进制的补码进行存储;
> 正数的补码等于其二进制编码;
> 负数的补码等于其绝对值的二进制编码，取反，再加1;
> 在本例中，-1的绝对值是1，二进制编码为0000 0001，取反加1就是1111 1111;
> unsigned是无符号数，会把1111 1111看成正数，刚好是255的二进制编码。

```c++

unsigned u=10;
int i=-42;
std::cout<<i+i<<std::endl; //正确：输出32

std::cout<<u+i<<std::endl; //如果int占32位，输出4294967264
//上面讲-42转化为unsigned int 负数转化为无符号函数，类似于直接给无符号数赋值一个负值；等于这个负数加上无符号数的模。  

unsigned ul=42,u2=10;
std::cout<<u1-u2<<std::endl;//正确：输出32；

std::cout<<u2-u1<<std::endl;//正确：不过，结果是取模后的值；

```

GCC编译器32位机和64位机各个类型变量所占字节数

|C类型| 32位机器(字节)| 64位机器(字节)|
|:---|:---|:---|
|`char` | 1 |1|
|`short`| 2| 2|
|`int`| 4 |4|
|`long int`|  4| 8|
|`long long`| 8| 8|
|`char *` | 4 |8|
|`float`| 4| 4|
|`double`|  8| 8|




### 字面常量值：
字面常量值就是常量；如`10/*十进制*/`；`014/*八进制*/`；`0x14/*十六进制*/`；包含整数和字符；C++11标准中允许使用`{}`进行数据对象的初始化，但是C++98中并不允许；例
```c++
vector<int > main_test={1,2,3};
```
### C++中的关键字
_参考链接：_ [C++关键字详解](https://blog.csdn.net/scmuzi18/article/details/53696778);

C++中存在预定义的关键字；如下图所示

![C++关键字表格](https://wangpengcheng.github.io/img/cplusplus_key_words.png)

注：上表中为C++98/03中的63个关键字，其中红色标注为C语言中的32个关键字。C++11中有73个关键字，新增加的10个为：`alignas、alignof、char16_t、char32_t、constexpr、decltype、noexpect、nullptr、static_assert、thread_local`

1. asm
   _asm是一个语句的分隔符。不能单独出现，必须接汇编指令。一组被大括号包含的指令或一对空括号。
例：
```c++
_asm
{
  mov al,2
  mov dx,0xD007
  out al,dx
}
```
    也可以在每个汇编指令前加`_asm`
```c++
  _asm mov al,2
  _asm mov dx,0xD007
  _asm out al,dx
```
2. auto 
   auto关键字会根据初始值自动推断变量的数据类型。不是每个编译器都支持auto。
   例：
```c++
    auto  x = 7;  //使用整数7对变量x进行初始化，可推断x为int型。

    auto  y=1.234;  //使用浮点数1.234对变量y进行初始化，可推断y为double型。
```

3. *_cast
   即 `const_cast`、`dynamic_cast`、`reinterpret_cast`、`static_cast`。
   C++类型风格来性转换。`const_cast`删除const变量的属性，方便赋值；`dynamic_cast`用于将一个父类对象的指针转换为子类对象的指针或引用；`reinterpret_cast`将一种类型转换为另一种不同的类型；`static_cast`用于静态转换，任何转换都可以用它，但他不能用于两个不相关的类型转换。
4. `bool、true、false`

`bool`即为布尔类型，属于基本类型中的整数类型，取值为真和假。`true`和`false`是具有布尔类型的字面量，为右值，即表示真和假。
注`：`字面量`：`用于表达源代码中一个固定值的表示法。
5. `break`、`cotinue`、`goto` 
   `break`用于跳出`for`、`while`循环或`switch`语句。`continue`用于调到一个循环的起始位置。goto用于无条件跳转到函数内得标号处。一般情况不建议使用`goto`，风险较大。

6. `switch`、`case`、`default`
   `switch`分支语句的起始，根据`switch`条件跳转到`case`标号或`defalut`标记的分支上。

7. `catch`、`throw`、`try`
   用于异常处理。`try`指定`try`块的起始，`try`块后的`catch`可以捕获异常。异常由`throw`抛出。`throw`在函数中还表示动态异常规范。
8、`char`、`wchar_t`
   表示字符型和宽字符型这些整数类型（属于基本类型），但一般只专用于表示字符。`char`（和`signed char`、`unsigned char`一起）事实上定义了字节的大小。`char`表示单字节字符，`wchar_t`表示多字节字符。
9. `const`、`volatile`
   `const`和`volatile`是类型修饰符，语法类似，用于变量或函数参数声明，也可以限制非静态成员函数。`const`表示只读类型（指定类型安全性，保护对象不被意外修改），`volatile`指定被修饰的对象类型的读操作是副作用（因此读取不能被随便优化合并，适合映射I/O寄存器等）。
  * `volatile`:
        * 当读取一个变量时，为提高存取速度，编译器优化时有时会先把变量读取到一个寄存器中，以后再取变量值时，就直接从寄存器中取值。
        * 优化器在用到`volatile`变量时必须每次都小心地重新读取这个变量的值，而不是使用保存到寄存器里的备份。
        `volatile`适用于多线程应用中被几个任务共享的变量。
10. `struct`、`class`、`union`
  用于类型声明。`class`是一般的类类型。`struct`在C++中是特殊的类类型，声明中仅默认隐式的成员和基类访问限定与`class`不同（`struct`是`public`，`class`是`private`）。`union`是联合体类型。满足特定条件类类型——`POD struct`或`POD union`可以和C语言中的`struct`和`union`对应兼容。
注：POD类型（Plain Old Data）,plain---代表普通类型，old---代表可以与C语言兼容。
11. `new`、`delete`
   `new`、`delete`属于操作符，可以被重载。`new`表示向内存申请一段新的空间，申请失败会抛出异常。`new`会先调用`operator new`函数，再在`operator new`函数里调用`malloc`函数分配空间，然后再调构造函数。`delete`不仅会清理资源，还会释放空间。`delete`县调用析构函数，其次调用`operator delete`函数，最后在`operator delete`函数里面调用`free`函数。`malloc`申请内存失败会返回空。`free`只是清理了资源，并没有释放空间。
12. `do`、`for`、`while`
  循环语句的组成部分，C和C++都支持这3种循环。
13. 数值类型，如 `int`、`double`、`float`、`short`、`long`、`signed`、`unsigned`
　　`signed`和`unsigned`作为前缀修饰整数类型，分别表示有符号和无符号。`signed`和`unsigned`修饰`char`类型，构成`unsigned char`和`signed char`，和`char`都不是相同的类型；不可修饰`wchar_t`、`char16_t`和`char32_t`。其它整数类型的`signed`省略或不省略，含义不变。`signed`或`unsigned`可单独作为类型，相当于`signed int`和`unsigned int`。
　　`double`和`float`专用于浮点数，`double`表示双精度，精度不小于`float`表示的浮点数。`long double`则是C++11指定的精度不小于`double`的浮点数。
14. `if`和`else`
   条件语句的组成部分。if表示条件，之后else表示否定分支。
15. `enum`
  构成枚举类型名的关键字。
16. `explicit`
    该关键字的作用就是避免自定义类型隐式转换为类类型。
17. `export`
　　使用该关键字可实现模板函数的外部调用。对模板类型，可以在头文件中声明模板类和模板函数；在代码文件中，使用关键字export来定义具体的模板类对象和模板函数；然后在其他用户代码文件中，包含声明头文件后，就可以使用该这些对象和函数。
18. `extern`
  当出现`extern "C"`时，表示 `extern "C"`之后的代码按照C语言的规则去编译；当`extern`修饰变量或函数时，表示其具有外部链接属性，即其既可以在本模块中使用也可以在其他模块中使用。
19. `friend`
  友元。使其不受访问权限控制的限制。例如，在1个类中，私有变量外部是不能直接访问的。可是假如另外1个类或函数要访问本类的1个私有变量时，可以把这个函数或类声明为本类的友元函数或友元类。这样他们就可以直接访问本类的私有变量。
20. `inline`
     内联函数，在编译时将所调用的函数代码直接嵌入到主调函数中。各个编译器的实现方式可能不同。
21. `mutable`
　　`mutable`也是为了突破`const`的限制而设置的。被`mutable`修饰的变量，将永远处于可变的状态，即使在一个`const`函数中。
22. `namespace`
　　C++标准程序库中的所有标识符都被定义于一个名为`std`的`namespace`中。命名空间除了系统定义的名字空间之外，还可以自己定义，定义命名空间用关键字`namespace`，使用命名空间时用符号`::`指定。
23. `operator`　　
   和操作符连用，指定一个重载了的操作符函数，比如，operator+。
24. `public`、`protected`、`private`
   这三个都为权限修饰符。`public`为公有的，访问不受限制；`protected`为保护的，只能在本类和友元中访问；`private`为私有的，只能在本类、派生类和友元中访问。
25. `register`
　　提示编译器尽可能把变量存入到CPU内部寄存器中。
26. `return`：`return`表示从被调函数返回到主调函数继续执行，返回时可附带一个返回值，由return后面的参数指定。return通常是必要的，因为函数调用的时候计算结果通常是通过返回值带出的。如果函数执行不需要返回计算结果，也经常需要返回一个状态码来表示函数执行的顺利与否（-1和0就是最常用的状态码），主调函数可以通过返回值判断被调函数的执行情况.
27. `static`：可修饰变量（静态全局变量，静态局部变量），也可以修饰函数和类中的成员函数。static修饰的变量的周期为整个函数的生命周期。具有静态生存期的变量，只在函数第一次调用时进行初始化，在没有显示初始化的情况下，系统把他们初始化微0.
28. `sizeof`
   返回类型名或表达式具有的类型对应的大小。
29. `template`
    声明一个模板，模板函数，模板类等。模板的特化。
30. `this`
    每个类成员函数都隐含了一个`this`指针，用来指向类本身。`this`指针一般可以省略。但在赋值运算符重载的时候要显示使用。静态成员函数没有`this`指针。
31. `typedef`
    `typedef`声明，为现有数据类型创建一个新的名字。便于程序的阅读和编写。
32. `virtual`
    声明虚基类，虚函数。虚函数=0时，则为纯虚函数，纯虚函数所在的类称为抽象类。
33. `typeid`
    `typeid`是一个操作符，返回结果为标准库种类型的引用。
34. `typename`
    `typename`关键字告诉编译器把一个特殊的名字解释为一个类型。
35. `using`
     (1)、在当前文件引入命名空间，例`using namespace std`;
     (2)、在子类中使用，`using`声明引入基类成员名称。
36. `void`
    特殊的"空"类型，指定函数无返回值或无参数。

### 复合类型
C++中的复合类型是指基于其他类型定义的类型；C++语言中基本的复合类型有：引用(&)和指针(*);

引用(&)主要是为对象起了另外一个名字；注意引用类型的初始值必须是一个对象。
#### 指针
指针(*)也是间接指向另外一种类型的复合类型；但其相对引用有一下不同点：
    * 指针本身是一个对象，允许对指针赋值和拷贝;而且在指针的声明周期内它可以先后指向几个不同的对象
    * 指针无需在定义时赋值。和其它的内置类型一样，在块作用域内定义的指针如果没有初始化，也将拥有一个不确定的值。
指针操作中`&`操作符，表示取地址作用
```c++
  int ival=42;
  int *p=&ival;//p存放变量ival的地址,即p指针指向ival;

```
指针的值：
1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，意味着指针没有指向任何对象
4. 无效指针，上述情况之外的其它值。
注意：
1. 如果指针指向了一个对象；则允许使用解应用符`*`来访问对象。
2. 对于指针变量，初始化时可以使用NULL来方便内存分配判断；但是在C++11标准中对象指针使用nullptr;对于未初始化的int 等基本数据类型可以使用NULL;

#### void* 指针
void* 指针是C语言中的保留项目，它是一种特殊的指针类型；可以用于存放任意对象的地址；
但是因为void* 指针的不确定性，也意味着我们无法确定能够在这个对象上进行哪些操作。
注意：
```c++
  int* p1,p2;//p1指向int的指针；p2是int类型 

  int** pi//一个指向int指针的指针
```
#### const 关键字
##### const * int 和int *const、const int * cosnt、const int &
_参考链接：_[const int、const int *、int *cosnt、const int * const、const int &的区别](https://blog.csdn.net/itworld123/article/details/78967080);

- `const int *`:该指针变量指向的是常量，即该指针变量的内容可以改变，但是该内容指向的内容不可改变！;即底层const(常量指针)；（其与`const int *`相同）；
- `int *const`:声明该指针变量为常变量，即指针变量里面的内容不可改变，但是该内容指向的内容可以改变;即为常指针。
- `const int * cosnt`:指向一个内容不可变的指针，且指向对象地址不能变；
- `const int &`:在引用前面加上const，代表该引用为常引用，即被引用的对象不可改变。若是在形参中使用，则不可达到在函数里面修改变量值的目的。

`const`关键字修饰的变量会在编译的时候将定义的字符串替换掉，为了提高编译效率和防止文件冲突，默认状态下const对象仅在文件内有效；
注意：

 1. `const`是变量的值无法改变（有待商榷）；`static`是指变量直接在堆上分配内存，内存不会销毁，但是值可以改变；
 2. 当某一个文件中的const变量希望它能够在其它文件之间共享的时候；即在一个问价中定义const，而在其它多个文件中使用它，需要在`const`关键字前添加`extern`关键字；
 
##### constexpr和常量表达式
**常量表达式:（const expression）**是指不会改变并且在编译过程中就能得到计算结果的表达式；一个对象/表达式是不是常量表达式；由它的数据类型和初始值共同决定。例：
```c++
const int max_files=20;//max_files 是常量表达式

const int limit=max_files+1;//limit 是常量表达式

int staff_size=27;//staff_size 不是常量表达式

const int sz=get_size();//运行时才知道值，因此不是常量；
```
**constexpr变量**
C++11允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量移动是一个产量，而且必须用常量表达式初始化：
```c++
constexpr int mf=20;//20是常量表达式

constexpr int limit=mf+1;//mf+1是常量表达式

constexpr int sz=size();//只有当size是一个constexpr函数时才是一条正确的声明语句
```
**指针和constexpr**
在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指对象无关；
```c++
const int *p=nullptr;//p是一个指向整型常量的指针

constexpr int *q=nullptr;//q是一个指向整数的常量指针；constexpr把她所东一的对象置为了顶层const
```

#### 类型别名typedef关键字
- `typedef int my_int`:将`int `取别名为`my_int`;
- `typede 函数`：定义函数类型(常用语C语言中；C++慎用)；例：

```c++
typedef long SetStringPtr(char *);//预定于函数输入输出类型

typedef long GetStringPtr(char *, long);//预定于函数输入输出类型

typedef struct {
   SetStringPtr * SetString;//初始化函数指针

   GetStringPtr * GetString;//初始化函数指针
   DWORD          count;
   char           buffer[80];
} IExample;
//实例化函数
long SetString(char * str)
{
   return(0);
}

IExample * example;//使用结构体对象

example->SetString = SetString;//使用函数；
```

#### auto关键字；
auto关键字在C++11中得到了广泛使用；但是他是基于C++模板类型推断的，因此需要慎重使用；多用于循环迭代中；例：
```c++
#include <iostream>
#include <vector>
using namespace std;
int main(int arc,char const *argv[])
{
    std::vector<int> v={1,1,12,3};
    for(auto temp : v){
        std::cout<<temp<<'\t'<<std::endl;;
    }
    return 0;
}
```

#### decltype类型指示符
decltype 是C++11新引入的关键字，帮助从表达式推断定义的变量的类型。
注意：
1. decltype 处理顶层const和引用的方式与auto有些许不同；
2. 如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型，当有时返回一个引用类型的时候；表达式的结果对象，能够作为一条赋值语句的左值。
3. dectype((variable))(注意是双层括号)的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是。

```c++
const int ci=0,&cj=ci;
decltype(cj) x=0;//x 类型是const int

decltype(cj) y=x;//y的类型是const int&,y绑定到变量x

decltype(cj) z;//错误，z是一个引用必须初始化

//decltype 的结果可以是引用类型

int i=42，*p=&i,&r=i;
decltype(r+0) b;//加法的结果是int，因此b是一个（未初始化的）int

decltype(*p) c;//错误：c是int&,必须初始化

```

## 第三章 字符串、向量和数组

### 使用using name space
c++中使用`using name space ` 来进行命名空间的选择，但是一般不建议直接在声明中使用。建议使用`spacename:: function`的格式；例如`std::cout`;并且头文件中，不应该包括`using`声明。

### 标准库类型 string
下面展示string的常用初始化方法：

```c++
    std::string s1; //默认初始化，s1市一个空字符
    std::string s2=s1; //s2是s1的副本
    std::string s3="hiya";//s3市该字符串字面值的副本
    std::string s5("hiya");//s3是字面值“value”的副本，除了字面值最后的那个空字符除外
    std::string s4(10,'c'); //s4 的内容是cccccccccc
```
`os<<s`、`is>>s`；从字符串的输入，输出流。例如：

```c++
#include <iostream>
using namespace std;
int main(int argc, char const *argv[])
{
    string s;
    cin>>s; //将string 对象读入s,遇到空白停止
    cout<<s<<endl;//输出
    return 0;
}
```
`getline()`:读取函数整行，直到遇到换行符为止。
注意`string 对象的size()`函数返回值类型是`string::size_type`;当他与一个具有负号的n比较时，肯定为true，因此建议使用`auto`来进行返回值的定义。防止`int`和`unsigned`可能带来的问题。

#### 标准库string重点字符处理--<cctype>头文件

|函数名称|功能|
|:---:|:---|
|`isalnum(c)`|当c是字母或数字时为真|
|`isalpha(c)`|当c是字母时为真|
|`iscntrl(c)`|当c是控制字符时为真|
|`isdigit(c)`|当c是数字时为真|
|`isgraph(c)`|当c不是空格但可以打印时为真|
|`isalower(c)`|当c是小写字母时为真|
|`isprint(c)`|当c是可打印字符时为真|
|`ispunct(c)`|当c是标点符号时为真|
|`isspace(c)`|当c是空白时为真（空格，制表符、回车符、换行符、进纸符中的一种）|
|`issupper(c)`|当c是大写字母时为真|
|`isxdigit(c)`|当c是十六进制数字时为真|
|`tolower(c)`|转换字母为小写|
|`toupper(c)`|转换字母为大写|

使用示例：

```c++
string s("hello word !!!");
decltype(s.size()) punct_cnt=0;
for (auto c : s)//注意这里auto是拷贝无法改变其中的char的值，可以使用&c进行值的改变。
{
    if(ispunct(c))
    {
        ++punct_cnt;//标点负号计数值加1；
    }
    cout<<punct_cnt
        <<"punctuation characters in"<<s<<endl;
}
//输出结果
3 punctuation characters in hello word!!!
```
将输入十进制数字转化为十六进制：

```c++
#include <iostream>
#include <stack>
#include <sstream>
#include <string>
using namespace std;

int main(int argc, char const *argv[]) {
    const string test="0123456789ABCDEF";
    cout<<"please input number between 0 and 15"<<endl;
    string::size_type n, temp;//用于保存从输入流读取的数;
    while((cin.peek()!=EOF)&&(cin.peek()!='\n'))
    {
        cin>>n;
        string result;//用于保存十六进制的字符串
       //else if(n>test.size()){
            for(int i=n;i>0;){
                temp=i%16;
                auto s1 = test[temp];//转化为十六进制
                result=s1+result;
                i=i>>4;
            }
        printf("%X\n",n);
        std::cout<<"this result is :"<<result<<std::endl;
        //result.clear();
    }
    printf("hello word");
    return 0;
}
```
### vector 向量介绍
#### 迭代器(iterator)介绍
迭代器类似于指针但是不同于指针；利用地址进行一次间接的迭代访问。
标准迭代器的运算符：

|运算符|功能|
|:---:|:---:|
|*iter|返回迭代器iter所指元素的引用|
|iter->mem|解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem|
|++iter|令iter指示容器的下一个元素|
|--iter|令iter指示容器的上一个元素|
|iter1==iter2|判断是否指向同一个元素|
|iter1!=iter2|判断是否指向同一个元素|

```c++
string s("some string ");
if(s.begin()!=s.end())
{
    auto it=s.begin();//it表示s的第一个字符
    *it=toupper(*it);//当前字符改写成大写格式
}
```
注意：
1. c++中定义了箭头运算符：(`->`)把解引用和成员访问两个操作结合在一起，`it->mem`和`(*it).mem`表达的意思相同。
2. 两个迭代器相减结果是它们之间的距离。迭代器加整数还是迭代器。

### 数组

使用数组下标的时候，通常将其定义为`size_t`类型；
```c++
unsigned scores[11]={};//11个分数段，全部初始化为0
unsigned grade;
while(cin>>grade) {
    /* code */
    if (grade<=100)
    {
        /* code */
        ++scores[grade/10];//将当前分数段的计数值加1
    }
}
```
注意：
1. 数组中的 `int *parr[10]`表示含有10个整型指针的数组;`int (*parr)[10]`表示指向含有10个整数的数组的指针。`int *(&array)[10]`表示含有10个int型指针的数组的引用。

#### c 风格字符串
c++中支持c风格字符串，但是在c++程序中最好还是不要使用他们。因为字符串使用起来不太方便，而且极易产生程序内存泄露
c++中string对象使用c_str()函数，实现string对象到 char*[]的转换。
尽量使用标准类库而非数组。

#### 多维数组的初始化：
```c++
int ia[3][4]={
    //内嵌`{`并不是必须的但是，可以似的文件更加整洁，代码更加规范
    {0,1,2,3},
    {4,5,6,7},
    {8,9,10,11}
}
```

## 第四章 表达式
### 左值和右值问题
_参考链接_：[理解C和C++中的左值和右值](https://blog.csdn.net/xuwqiang1994/article/details/79924310);[C++11 左值、右值、右值引用详解](https://blog.csdn.net/hyman_yx/article/details/52044632);

左值：代表一个在内存中占有确定位置的对象(存在地址);例如`int a=0;`中`a`就是一个左值
右值：通过排他性来定义，每个表达式不是lvalue就是rvalue。因此从上面的lvalue的定义，rvalue是在不在内存中占有确定位置的表达式。

**左值引用**就是对一个左值进行引用的类型。**右值引用**就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。

右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。

左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。

```c++
int &a = 2; // 左值引用绑定到右值，编译失败 
int b = 2; // 非常量左值 
const int &c = b; // 常量左值引用绑定到非常量左值，编译通过 
const int d = 2; // 常量左值 
const int &e = c; // 常量左值引用绑定到常量左值，编译通过 
const int &b =2; // 常量左值引用绑定到右值，编程通过
```
右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值，例如：

```c++
int a;
int &&r1 = c;             # 编译失败
int &&r2 = std::move(a);  # 编译通过
```
![可引用类型值](https://img-blog.csdn.net/20160727131907698)

```c++
 // lvalues:
  //
  int i = 42;
  i = 43; // ok, i is an lvalue
  int* p = &i; // ok, i is an lvalue
  int& foo();
  foo() = 42; // ok, foo() is an lvalue
  int* p1 = &foo(); // ok, foo() is an lvalue

  // rvalues:
  //
  int foobar();
  int j = 0;
  j = foobar(); // ok, foobar() is an rvalue
  int* p2 = &foobar(); // error, cannot take the address of an rvalue
  j = 42; // ok, 42 is an rvalue
```

### 运算符优先级顺序

运算符优先级顺序如下表所示：

|运算符|功能|用法|
|:---:|:---:|:---:|
|`+`|一元正号|`+ expr`|
|`-`|一元负号|`- expr`|
|`*`|乘法|`expr * expr`|
|`/`|除法|`expr / expr`|
|`%`|求余|`expr % expr`|
|`+`|加法|`expr + expr`|
|`-`|减法|`expr - expr`|

注意

1. 使用数据类型赋值的时候不要超出类型的上界；例如：
```c++
short short_value=32767；//short类型占16位，则能表示的最大值是32767
short_value+=1;//该计算导致溢出，实际值：-32768
```
2. 如果`m%n`不等于0，则它的负号和`m`相同
3. 赋值运算符`=`的左侧运算对象必须是一个可以修改的左值。

### 位运算符
位运算符主要使用方法如下表：

|运算符|功能|用法|
|:---:|:---:|:---:|
|`~`|位求反|`~ expr`|
|`<<`|左移，相当于乘`2^n`|`expr1 >> expr2`|
|`>>`|右移，相当于除`2^n`|`expr1 >> expr2`|
|`&`|位与|`expr & expr`|
|`^`|位异或|`expr ^ expr`|
|`"|"`|位或|`"expr|expr"` |


### `sizeof`运算符

`sizeof`来进行对象或者类型名称所占用的字节数目

### 类型转换
_参考链接：_ [C++强制类型转换：static_cast、dynamic_cast、const_cast、reinterpret_cast](https://www.cnblogs.com/chenyangchun/p/6795923.html);[C++ 类型转换（C风格的强制转换）](https://www.cnblogs.com/Allen-rg/p/6999360.html);

c++中的隐式类型转换，已经在之前介绍过了，同时c++中还存在显示的强制类型转换`cast-name<type>(expression)`；其中`cast-name`是指：`static_cast`、`dynamic_cast`、`const_cast`和`reinterpret_cast`

|名称|区别|
|:---:|:---:|
|`static_cast`|静态强制转换，编译时就转换|
|`dynamic_cast`|动态强制转换，运行时转换|
|`const_cast`|编译时进行检查，强制消除对象的常量性|
|`reinterpret_cast`|编译时进行检查，是特意用于底层的强制转型，主要用于二进制的强制类型转换|

* `static_cast` 

`static_cast`相当于传统的C语言里的强制转换，该运算符把expression转换为new_type类型，用来强迫隐式转换，例如non-const对象转为const对象，编译时检查，用于非多态的转换，可以转换指针及其他，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：
  1. 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。
      - 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；
      - 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。
  2. 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
  3. 把空指针转换成目标类型的空指针。
  4. 把任何类型的表达式转换成void类型。

注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。

* `dynamic_cast`

主要用于执行“安全的向下转型(safe downcasting)”，也就是说，要确定一个对象是否是一个继承体系中的一个特定类型。支持父类指针到子类指针的转换，这种转换时最安全的转换。它 是唯一不能用旧风格语法执行的强制类型转换，也是唯一可能有重大运行时代价的强制转换。
  1. 其他三种都是编译时完成的，`dynamic_cast`是运行时处理的，运行时要进行类型检查。
  2. 不能用于内置的基本数据类型的强制转换。
  3. `dynamic_cast`转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。
  4. 使用`dynamic_cast`进行转换的，基类中一定要有虚函数，否则编译不通过。B中需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表（关于虚函数表的概念，详细可见<Inside c++ object model>）中。只有定义了虚函数的类才有虚函数表。
  5. 要求<>内部所描述的目标类型必须为指针或引用。
  6. 在类的转换时，在类层次间进行上行转换时，`dynamic_cast`和`static_cast`的效果是一样的。在进行下行转换时，`dynamic_cast`具有类型检查的功能，比`static_cast`更安全。
    - 向上转换，即为子类指针指向父类指针（一般不会出问题）；向下转换，即将父类指针转化子类指针。
    - 向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。
    - 在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。Dynamic_cast操作符则可以在运行期对可能产生问题的类型转换进行测试。

* const_cast
  
 而`const_cast`则正是用于强制去掉这种不能被修改的常数`const`特性，但需要特别注意的是`const_cast`不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。
 1. 该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。
 2. 常量指针被转化成非常量指针，并且仍然指向原来的对象；
 3. 常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。
 4. const_cast强制转换对象必须为指针或引用
 5. const_cast一般用于修改底指针。如const char *p形式

* reinterpret_cast

是特意用于底层的强制转型，导致实现依赖（就是说，不可移植）的结果，例如，将一个指针转型为一个整数。这样的强制类型在底层代码以外应该极为罕见。操作 结果只是简单的从一个指针到别的指针的值得二进制拷贝。在类型之间指向的内容不做任何类型的检查和转换。
new_type必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，再把该整数转换成原类型的指针，还可以得到原先的指针值）。

##### 运算符优先级表格如下


<table>
    <thead>
        <tr>
            <th>优先级 </th>
            <th>运算符 </th>
            <th>说明  </th>
            <th>结合性 </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>1</td>
            <td>::</td>
            <td>范围解析</td>
            <td rowspan="6">自左向右</td>
        </tr>
        <tr>
            <td rowspan="5">2</td>
            <td>++ - - </td>
            <td>后缀自增/后缀自减</td>
        </tr>
        <tr>
            <td>()</td>
            <td>括号</td>
        </tr>
        <tr>
            <td>[]</td>
            <td>数组下标</td>
        </tr>
        <tr>
            <td>.</td>
            <td>成员选择(对象)</td>
        </tr>
        <tr>
            <td>-&gt;</td>
            <td>成员选择(指针)</td>
        </tr>
        <tr>
            <td rowspan="9">3</td>
            <td>++ - -</td>
            <td>前缀自增/前缀自减</td>
            <td rowspan="9">自右向左</td>
        </tr>
        <tr>
            <td>+ -</td>
            <td>加减</td>
        </tr>
        <tr>
            <td>! ~</td>
            <td>逻辑非/按位取反</td>
        </tr>
        <tr>
            <td>(type)</td>
            <td>强制类型转换</td>
        </tr>
        <tr>
            <td>*</td>
            <td>取指针指向的值</td>
        </tr>
        <tr>
            <td>&amp;</td>
            <td>某某的地址</td>
        </tr>
        <tr>
            <td>sizeof</td>
            <td>某某的大小</td>
        </tr>
        <tr>
            <td>new,new[]</td>
            <td>动态内存分配/动态数组内存分配</td>
        </tr>
        <tr>
            <td>delete,delete[]</td>
            <td>动态内存分配/动态数组内存释放</td>
        </tr>
        <tr>
            <td>4</td>
            <td>.* -&gt;* - -</td>
            <td>成员对象选择/成员指针选择</td>
            <td rowspan="12">自左向右</td>
        </tr>
        <tr>
            <td>5</td>
            <td>* / %</td>
            <td>乘法/除法/取余</td>
        </tr>
        <tr>
            <td>6</td>
            <td>+ -</td>
            <td>加号/减号</td>
        </tr>
        <tr>
            <td>7</td>
            <td>&lt;&lt; &gt;&gt;</td>
            <td>位左移/位右移</td>
        </tr>
        <tr>
            <td rowspan="2">8</td>
            <td> &lt; &lt;=</td> 
            <td>小于/小于等于</td>
        </tr>
        <tr>
            <td> &gt; &gt;=</td> 
            <td>大于/大于等于</td>
        </tr>
        <tr>
            <td>9</td>
            <td>== !=</td>
            <td>等于/不等于</td>
        </tr>
        <tr>
            <td>10</td>
            <td>&amp;</td>
            <td>按位与</td>
        </tr>
        <tr>
            <td>11</td>
            <td>^</td>
            <td>按位异或</td>
        </tr>
        <tr>
            <td>12</td>
            <td>|</td>
            <td>按位或</td>
        </tr>
        <tr>
            <td>13</td>
            <td>&amp;&amp;</td>
            <td>与运算</td>
        </tr>
        <tr>
            <td>14</td>
            <td>||</td>
            <td>或运算</td>
        </tr>
        <tr>
            <td>15</td>
            <td>?:</td>
            <td>三目运算符</td>
            <td rowspan="7">自右向左</td>
        </tr>
        <tr>
            <td rowspan="5">16</td>
            <td>=</td>
            <td>赋值</td>
        </tr>
        <tr>
            <td>+= -=</td>
            <td>相加后赋值/相减后赋值</td>
        </tr>
        <tr>
            <td>*= /= %=</td>
            <td>相乘后赋值相值/取余后赋值</td>
        </tr>
        <tr>
            <td>&lt;&lt;= &gt;&gt;=</td>
            <td>位左移赋值/位右移赋值</td>
        </tr>
        <tr>
            <td>&amp;= ^= |=</td>
            <td>位与运算后赋值/位异或运算后赋值/位或运算后赋值</td>
        </tr>        
        <tr>
            <td>17</td>
            <td>throw</td>
            <td>抛出异常</td>
        </tr>        
        <tr>
            <td>18</td>
            <td>,</td>
            <td>逗号</td>
            <td>自左向右</td>
        </tr>
    </tbody>
</table>

## 第五章 语句
没什么好写的。

## 第六章 函数

###  函数基础

在函数中可以使用`static`来进行静态局部变量的全局作用域。使得局部变量的生存周期可以一直持续到程序结束。
注意当使用指针作为函数传入参数的时候，函数内部会拷贝传入参数指针，指针不同但是指向的地址和变量相同。当使用引用时，是传给函数使用对象的另外一个名字。因此在函数参数传递时应该，尽量使用引用参数。如下：

```c++
bool isShorter(const string &sl;const string &s2)
{
    return s1.size()<s2.size();
}

int  main(int argc,char *argv[])
{

}

//第二个形参argv是一个数组，它的元素是指向c风格字符串的指针；因为第二个形参是数组，所以main函数也可以定义成：

int main(int argc, char const **argv) {
    /* code */
    return 0;
}


```


### initialzer_list 形参

当函数的实参数量未知；但是全部实参的类型相同，我们可以使用initializer_list类型的形参。详细描述如下表：

|操作|解释|
|:---|:---|
|`initializer_list <T> lst`|默认初始化；类型的空列表|
|`initializer_list <T> lst {a,b,c...}`|lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中的元素是const|
|`lst2(lst) or lst2=lst`|拷贝复制一个元素|
|`lst.size()`|列表中的元素数量|
|`lst.begin()`|返回指向lst中首元素的指针|
|`lst.end()`|返回指向lst中尾元素下一位置的指针|


下面是代码示例：
```c++
void error_msg(initializer_list<string> il)
{
    for(auto beg=il.begin();beg!=il.end();++beg)
    {
        cout<<*beg<<" ";//连续输出错误的函数信息
    }
    cout<<endl;

}

```

#### 省略符形参

为了方便c++程序访问某些特殊的c代码而设置的，这些大妈使用了名为`varargs`的c标准库功能。

```c++

void foo(parm_list,...);
void foo(...);

```
#### 值是如何被返回的
返回复制一个临时变量，该临时变量就是函数调用的结果。
注意：
1. 不要返回局部对象的引用或者指针，因为局部变量的引用和指针会随着局部变量的结束而终止，因此，返回的引用和指针会不在有效的内存区域内。
2. 函数的返回类型决定函数是否是左值，调用一个返回引用的函数得到左值，其它返回类型得到右值。
3. 数组不能被返回，但是函数可以通过返回数组指针来进行返回操作。
4. c++11新标准，允许使用尾置返回类型；或者使用`decltype`声明返回指针的类型；例如：
    
```c++
    //func 接受一个int类型的实际参数，返回一个指针，该指针指向含有10个整数的数组
    
    auto funct(int i) -> int(*)[10];
    int odd[]={1,3,5,7,9};
    int odd[]={2,4,6,8,10};

    decltype(odd) *arrPtr(int i)
    {
        return (i%2)?&odd:&even;//返回一个指向数组的指针

    }
```

#### 函数重载(overloaded 和over)

_参考链接：_ [C++的重载(overload)与重写(override)](https://www.cnblogs.com/luxiaoxun/archive/2012/08/09/2630751.html)；[C++中 overload 、override、overwrite 之间的区别](https://blog.csdn.net/qq_34793133/article/details/80938099);

因为c++是强类型语言，因此当相同函数名称处理不同的输入数据时需要设置多个函数，实现相同函数名称的查找匹配最佳值。这一点c++中的模板很好的解决了这个问题，但是函数的重载也很好的解决了这个问题。例如：

```c++
//定义重载函数

void print(const char *cp);//函数1

void print(const int *beg,const int *end);//函数2

void print(const int ia[],size_t size);//函数3

//接受参数不同，使用也不相同

int j[2]={0,1};

print("Hello word ");//调用函数1

print(j,end(j),-begin(j));//调用函数2

print(begin(j),end(j));//调用函数3

```
注意：

1. `main`函数不能重载。
2. c++中函数名字查找发生在类型检查之前。因此建议，函数重载，针对不同输入直接取名不同。
3. 当函数传入参数是拷贝传递时`const int a`与`int a`是同一个函数，即重写了前一个函数。当使用`&`作为引用参数时，使用`const`为新参数。例如`int &a`与`const int &a`是两个不同的函数。
4. 注意当查找同名函数时，编译器首先查找当前作用域(局部作用域)内的同名函数。

##### overload 、override、overwrite 之间的区别

##### Overload  重载
在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数不同（包括类型、顺序不同），即**函数重载**。条件：

- 相同的范围(在同一个类中)
- 函数名字相同
- 参数不同
- 重载解析中不考虑返回类型，而且在不同的作用域里声明的函数也不算是重载。重载可以理解为一个类内部的函数重载

#####  Override 覆盖
是指派生类函数覆盖基类函数，实际上是c++多态的衍生品；特征是：

- 不同的范围(分别位于派生类与基类)
- 函数名字相同；
- 参数名字相同
- 基类函数必须有`virtual`关键字。

示例：

```c++
#include <iostream>
using namespace std;
class base
{
  public:
  virtual void Fun1()
    {
        
        cout<<"Base Fun1..."<<endl;
     }
 
      virtual void Fun2()
     {
         cout<<"Base Fun2..."<<endl;
     }
 
      void Fun3()
    {
        
        cout<<"Base Fun3..."<<endl;
     }
};
 
class Derived:public Base
{
   public:
   void Fun1()
    {
        
        cout<<"Derived Fun1..."<<endl;
     }
 
    void Fun1()
    {
        
        cout<<"Derived Fun2..."<<endl;
     }
 
      void Fun3()
    {
        
        cout<<"Derived Fun3..."<<endl;
     }
};
 
 
int main()
{
  Base* p;
  Derived d;
  p=&d;
 
 p->Fun1();  //因为Fun1是虚函数，所以调p指向的对象的Fun1

 p->Fun2();   //同Fun1
 
 p->Fun3();   //Fun3不是虚函数，所以根据指针的类型，是基类指针，调基类的Fun3
  
return 0;
}
/*
结果：
Derived Fun1...
Derived Fun2...
Base Fun3...
*/
```
#####  overwrite：重定义
是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
    
- 如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无`virtual`关键字，基类的函数将被隐藏。
- 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有`virtual`关键字。此时，基类的函数被隐藏（注意别与覆盖混淆)
- 重定义分两种：
    + 对基类数据成员的重定义：不改变基类的数据成员，改变派生类的数据成员。
    + 对基类成员函数的重定义
        * 派生类的成员函数与基类完全相同；基类中的函数被隐藏
        * 派生类的成员函数与语言基类成员函数名相同但参数不同；使用派生类的函数，如果要方位基类方法使用`<class_name>.Base::<function>`或者`<class_name>.Base::<成员变量名>`；


#### 特殊用途语言实参
c++中存在特殊用途的语言实参：

##### 默认实参
函数可以使用默认初始值，这点称为默认实参例如：`string function1(int hz=24,int wid=80,char backgrnd='n');`
注意：

1. 默认实参最好放在头文件中
2. 已经给予初始值的默认实参不得再定义初始值，只能给未定义的给予初始值；重复声明会发生错误。

##### 内联函数和`constexpr`函数

内联函数说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求，在编译时将其替换。可以多次定义

`constexpr`函数用于指示常量表达式。

##### 帮助调试
c++中有许多帮助调试的信息；其中包括`assert`预处理宏；在`<assert>`头文件中定义。`assert(expr)`中判断表达式为假时，函数终止。
同时还存在NDEBUG预处理变量;使用静态预处理变量，说明当前文件信息。

|关键字|作用|
|:---:|:---|
|`__FILE__`|存放文件名字的字符串字面值|
|`__LINE__`|存放当前行号整形字面值|
|`__TIME__`|存放编译时间字符串字面值|
|`__DATE__`|存放编译日期字符串字面值|

例如：

```c++

#include <iostream>
using namespace std;

int main(void)
{
    std::cout<<"function name"<<__func__<<"\n";
    std::cout<<"file name "<<__FILE__<<"\n";
    std::cout<<"line "<<__LINE__<<"\n";
    std::cout<<"time"<<__TIME__<<"\n";
    return 0;
}
/*输出：
function namemain
file name test.cpp
line 8
time20:39:05
*/

```
#### 函数指针
指针的实质是指向内存的地址的一个变量，函数存在于堆栈中，因此指针也可以指向函数，成为函数指针。例如：

```c++

//定义函数function2

bool function2(const string &,const string &);
//定义指针指定输入参数的指针

bool *pf(const string &,const string &);

pf=function2;//将指针pf指向lengthCompare的函数

auto b1=pf("hello","goodbye");//调用函数

auto b2=(*pf)("hello","goodbye");//一个等价的调用

//使用指针函数，方便我们在某些状况下使用指定的重载函数，避免产生隐式转换的错误

void ff(int* )//重载函数1

void ff(unsigned int)//重载函数2

//定义函数指针，并初始化
void (*pf1)(unsigned int )=ff;

```
我们也可以使用函数指针，作为函数返回值，指向一个函数；只要返回类型写成指针形式。使用类型别名可以声明一个返回函数指针的函数。

```c++
using F=int(int*,int);//F是函数类型，不是指针

using PF=int(*)(int *,int);//PF是指针类型


PF f1(int);//正确：PF是指向函数的指针，f1返回指向函数的指针

F f1(int); //错误：F是函数类型，f1不能返回一个函数

F *f1(int)；//正确：显式地指定返回类型是指向函数的指针

```
## 类

### 定义抽象数据
c++中类的实质就是数据的抽象实现和封装。抽象数据依赖于接口和实现，分离的编程技术；**定义在函数内部的函数是隐式的inline函数**

#### 类中的this关键字
_参考链接：_ [C++类中this指针的理解](https://www.cnblogs.com/liushui-sky/p/5802981.html); [C++ this 指针](https://www.runoob.com/cplusplus/cpp-this-pointer.html);[关于this指针](https://blog.csdn.net/shidantong/article/details/80104710);

首先声明`this`指针是c++为了方便管理类中的函数而产生的，每个对象的`this`指针都指向对象本身，可以使用对象的非静态方法。`this`指针是编译器给予的每个成员函数的隐含参数，用来指向调用对象。
注意：

1. 友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。
2. this指针其本身的内容是不能被改变的，其类型为：**类类型 * const**
3. this指针不是对象本身的一部分，不影响该对象的大小
4. this指针的作用域在类的 **非静态成员函数**的内部，只能在其内部进行使用，其他任何函数都不能，静态成员函数内部无this指针，后面会详述。
5.  this指针是类中非静态成员函数的第一个默认隐含参数，编译器自动传递和维护，用户不可显示传递
6.  this指针可以为空但是类内部的成员变量数据不能为空，因此当调用使用成员变量时，请确保成员变量不为空。

函数调用约定如下：

![函数调用约定表](https://img-blog.csdn.net/20180426163408707?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaWRhbnRvbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

_thiscall关键调用：

- 它只能用在类的成员函数上
- 参数从右向左进行压栈
- 若参数个数确定，this指针通过ecx寄存器传递给被调用者；若参数不确定，this指针在所有参数被压栈后压入堆栈
- 对于参数不确定的函数，调用者清理堆栈，否则函数自己清理堆栈。

##### 构造函数
构造函数主要是c++中对于类对象的实例化的函数,这里需要强调一下c++中`new A`、`new A()`与`new A[]`的区别；

_参考链接：_ [C++中new 一个对象的时候加括号和不加括号的区别](https://blog.csdn.net/ywending/article/details/51096547);[C++ new A 和 new A() 的区别详解以及引申的各种初始化类型](https://blog.csdn.net/qq_34228570/article/details/79549958);

先说结论：

-  加括号调用没有参数的构造函数，不加括号调用默认构造函数或唯一的构造函数，看需求。
-  **C++在new时的初始化的规律可能为：对于有构造函数的类，不论有没有括号，都用构造函数进行初始化；如果没有构造函数，则不加括号的new只分配内存空间，不进行内存的初始化，而加了括号的new会在分配内存的同时初始化为0。**

POD(Plain old data):它是一个struct或者类，且不包含构造函数、析构函数以及虚函数。POD class没有用户定义的析构函数、拷贝构造函数和非静态的非POD类型的数据成员。而且，POD class必须是一个aggregate，没有用户定义的构造函数，没有私有的或者保护的非静态数据，没有基类或虚函数。它只是一些字段值的集合，没有使用任何封装以及多态特性。

对于`[new] T [object] {};`初始化一般有三种处理方式：

- 如果T有用户定义的缺省构造函数，直接调用；
- 如果T有编译器生成的缺省构造函数，先0值初始化再调用；
- 如果T根本不是类，直接0值初始化。

对于`[new] T object;`如果T是非class类型，则给出非确定值（不赋值），比如：`int i; double d; bool b;`；
0值初始化也单独作用于静态(或者线程局部）变量：`static T object;`

五种初始化类型：

- list initialization (since C++11) 
- aggregate initialization 这是list initialization对aggregate类型的特例 
- value initialization 值初始化 
- default initialization 缺省初始化 
- zero initialization 0值初始化

示例代码：

```c++
#include <iostream>  

using namespace std;

class A { public:int m; }; // POD  

class B { public:~B() {}; int m; }; // non-POD, compiler generated default ctor  

class C { public:C() :m() {}; ~C() {}; int m; }; // non-POD, list-initialising m

class D { public:D() {}; ~D() {}; int m; };  // non-POD，default-initialising m

int main()
{
    A *aObj1 = new A;
    A *aObj2 = new A();
    cout << aObj1->m << endl;
    cout << aObj2->m << endl;

    B *bObj1 = new B;
    B *bObj2 = new B();
    cout << bObj1->m << endl;
    cout << bObj2->m << endl;

    C *cObj1 = new C;
    C *cObj2 = new C();
    cout << cObj1->m << endl;
    cout << cObj2->m << endl;

    D *dObj1 = new D;
    D *dObj2 = new D();
    cout << dObj1->m << endl;
    cout << dObj2->m << endl;

    delete aObj1;
    delete aObj2;
    delete bObj1;
    delete bObj2;
    delete cObj1;
    delete cObj2;

    getchar();
    return 0;
}
/*result


-842150451
0
-842150451
0
0
0
-842150451
-842150451
注意不同编译器可能产生不同的结果，GCC中结果：
0
0
38158368
0
0
0
38158400
0
结论（以GCC为准）：
new A：0

new A()：0

new B：不确定的值

new B()：0

new C：0

new C()：0

new D：不确定的值

new D()：0

*/


```

注意：
1. 只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。
2. 可以在构造函数之后添加`=default`来要求编译器生成默认构造函数。

### 访问控制与封装
访问说明符`public`、`private`、`protect`来加强类的封装性。注意`struct`关键字中定义第一个访问说明符之前的成员是`public`，如果使用`class`关键字，成员是`private`的。因此当希望所有的类成员是`public`时使用`struct`；希望是`private`时使用`class`。

**友元(friend)**:类允许其他类或者函数访问它的非公有成员，将函数成为友元只需要增加一条`friend`关键字就可以了。注意友元函数，必须在友元声明之外再专门对函数进行一次声明。

定义类型的成员必须先定义后使用例如：

```c++
class Screen
{
public:
    //使用类型别名等价地声明一个类型名字

    typedef std::string::size_type pos;
    Screen();
    ~Screen();
private:
    pos cursor=0;
    pos height=0,width=0;
    std::string contents;
    
};
```
类的友元使用示例如下

```c++
//screen.cpp

class Screen
{
public:
    //使用类型别名等价地声明一个类型名字

    typedef std::string::size_type pos;
    Screen();
    ~Screen();
    //定义友元

    //Windows类可以访问Screen类的私有部分

    friend class Windows;
    //成员函数作为友元

    friend void Windows::clear(ScreenIndex);

private:
    pos cursor=0;
    pos height=0,width=0;
    std::string contents;
    
}

//windows.cpp

class Windows
{
public:
    //窗口中每个屏幕的编号

    using ScreenIndex=std::vector<Screen>::size_type;
    //按照编号将指定的Screen重置为空白
private:
    
    std::vector<Screen> screen{screen(24,80,'')};

public:
    void clear(ScreenIndex i)
    {
        //s是一个Screen的引用，指向我们想清空的那个平米

        Screen &s=screen[i];

        //将那个选定的Screen重置为空白

        s.contents=string(s.height*s.width,'');
    }
}

```
注意：

1. 友元的函数未声明直接出现时，我们隐式的假定该名字在当前作用域中是可见的，要想正常使用，该函数必须先被定义过。


**`mutable`**关键字： 类成员变量使用`mutable`关键字即便是`const`对象也能更改类的成员变量。

类的成员函数后添加`const`关键字，表示不会修改类中的成员变量；并且有一下几点规则：

1. 在类中被const声明的成员函数只能访问const成员函数，而非const函数可以访问任意的成员函数，包括const成员函数
2. 在类中被const声明的成员函数不可以修改对象的数据，不管对象是否具有const性质，它在编译时，以是否修改成员数据为依据，进行检查。
3. 加上mutable修饰符的数据成员，对于任何情况下通过任何手段都可修改，自然此时的const成员函数是可以修改它的

**向前声明：** 仅仅声明类而不去定义它。对于类而言，当类的名字出现过后，它就被认为是声明过了（但是尚未定义），因此类允许包含指向它自身类型的引用或者指针。例如：

```c++
class Link_screen
{
    Screen windows;
    Link_screen *next;
    Link_screen *prev;
}

```

**类中普通块作用域的名字查找**

- 首先，成员函数内查找该名字的声明，只有在函数使用之前出现的声明才被考虑。
- 如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑
- 如果类内也没有找到该名字的声明，在成员函数定义之前的作用域内继续查找。
- 类作用域之后，在外围的作用域中查找；如果编译器在函数和类的作用域中都没有找到名字，它将接着在外围的作用域中查找

### 构造函数再探

如果成员是是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。最好令构造函数初始值的顺序与成员声明的顺序保持一致；而且如果有可能的话，尽量避免使用某些成员变量初始化其他成员。

注意：成员的初始化顺序与他们在类中定义的出现顺序一致；第一个成员先被初始化，然后第二个

```c++
class X
{
    int i;
    int j;
public:
    X(int val):j(val),i(j){}

    //错误：i在j之前被初始化，因此初始化i之前发生错误，j未定义。
}

```

#### 委托构造函数

C++中可以使用委托构造函数，即预定义一个基础的构造函数其它的构造函数可以调用这个构造函数。

#### 隐式的类类型转换与转换避免。
c++语言之间存在隐式的转换规则；构造函数实际上也定义了转换为此类类型的隐式转换机制。我们将这种构造函数称之为 **转换构造函数**；隐式转换，相当于构造了一个临时的变量对象。再给类一个临时成员变量。但是这种转换只允许一步类型转换，并且类型转换并不是总有效。
为了防止这种状况的发生，我们在单参数构造函数前面添加`explicit`关键字使得构造函数只能直接初始化。但是使用`static_cast`强制类型转化可以使用带有`explicit`关键字的构造函数。

#### 聚合类
聚合类中可以使得用户直接访问其成员，并且具有特殊的初始化语法形式。聚合类的特征：

- 所有成员都是public的
- 没有定义任何构造函数
- 没有类内初始值
- 没有基类，也没有`virtual`函数

例如：

```c++
struct Data
{
    int ival;
    string a;
};
//这就是一个聚合类
```

注意：显示地初始化类的对象的成员存在三个明显的缺点

- 要求类的所有成员都是`public`的。
- 将正确初始化每个对象的每个成员的重任交给了类的用户。因为用户很容易忘掉某个初始值，或者提供一个不恰当的初始值，所以这样的初始化过程冗长乏味且容易出错。
- 添加或者删除一个成员之后，所有的初始化语句都需要重新更新。

#### 字面常量类

要求：

- 数据成员都必须是字面类型值
- 类必须至少含有一个`constexpr`构造函数
- 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；如果成员属于某种类型，则初始值必须使用成员自己的`constexpr`构造函数。
- 类必须使用析构函数的默认定义，该成员负责销毁类的对象。

#### `constexpr`构造函数

首先需要明确构造函数不能是`const`的，因为const修饰函数表示该函数的返回值是const类型的，改返回值只能赋值给同类型的const变量，不符合类的构造函数的需求。const是可以修饰类的成员函数，但是该函数不能修改数据成员。构造函数也属于类的成员函数，但是构造函数是要修改类的成员变量，所以类的构造函数不能申明成const类型的。

但是字面常量类的构造函数时可以`constexpr`的函数，实际上一个字面值常量类必须至少提供一个`constexpr`构造函数。并且该构造函数一般是空的。因为它必须符合构造函数的要求--不能存在返回值；又符合`constexpr`函数要求--能拥有的唯一可执行语句就是返回语句。示例如下;

```c++
class Debug {
private:
    /* data */
public:
    constexpr Debug(bool b=true):hw(b),io(b),other(b){};
    constexpr Debug(bool h,bool i,bool o):hw(h),io(i),other(o){};
    constexpr bool any(){return hw || io || other;}
    //.....
};

```

#### 类的静态成员

##### c++中的内存分配
_参考链接：_ [C/C++程序内存的分配](https://blog.csdn.net/cherrydreamsover/article/details/81627855)；[【C++】动态内存分配详解（new/new[]和delete/delete[]）](https://blog.csdn.net/qq_40416052/article/details/82493916);

首先c/c++中内存分为以下几种类型

- 栈(stack):由编译器自动分配与释放，存放为运行时函数分配的局部变量、函数参数、返回数据、返回地址等。其操作类似于数据结构中的栈。
- 堆区（heap）：一般由程序员自动分配，如果程序员没有释放，程序结束时可能有OS回收。其分配类似于链表。
- 全局区（静态区static）：存放全局变量、静态数据、常量。程序结束后由系统释放。全局区分为已初始化全局区（data）和未初始化全局区（bss）。
- 常量区（文字常量区）：存放常量字符串，程序结束后有系统释放。
- 代码区：存放函数体（类成员函数和全局区）的二进制代码。

具体的内存分配如下：

![程序内存分配](https://img-blog.csdn.net/20180813110942795?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXJyeWRyZWFtc292ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70);

注意：栈的地址由高到低，堆的地址由低到高。

**内存分配的方式**

1. 从静态存储区分配：内存在程序编译的时候已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。
2. 在栈上创建：在执行函数时，函数内局部变量的存储单元可以在栈上创建，函数执行结束时，这些内存单元会自动被释放。栈内存分配运算内置于处理器的指令集，效率高，但是分配的内存容量有限。
3. 从堆上分配： 亦称为动态内存分配。
 - 程序在运行的时候使用malloc或者new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。
 - 动态内存的生命周期有程序员决定，使用非常灵活，但如果在堆上分配了空间，既有责任回收它，否则运行的程序会出现内存泄漏，频繁的分配和释放不同大小的堆空间将会产生内存碎片。
4. 在 C 语言中，全局变量又分为初始化的和未初始化的（未被初始化的对象存储区可以通过 void* 来访问和操纵，程序结束后由系统自行释放），在 C++ 里面没有这个区分了，他们共同占用同一块内存区。

**堆和栈的区别**

1. **管理方式不同**：栈是由编译器自动申请和释放空间，堆是需要程序员手动申请和释放；
2. **空间大小不同**：栈的空间是有限的，在32位平台下，VC6下默认为1M，堆最大可以到4G；
3. **能否产生碎片**：栈和数据结构中的栈原理相同，在弹出一个元素之前，上一个已经弹出了，不会产生碎片，如果不停地调用malloc、free对造成内存碎片很多；
4. **生长方向不同**：堆生长方向是向上的，也就是向着内存地址增加的方向，栈刚好相反，向着内存减小的方向生长。
5. **分配方式不同**：堆都是动态分配的，没有静态分配的堆。栈有静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。
6. **分配效率不同**： 栈的效率比堆高很多。栈是机器系统提供的数据结构，计算机在底层提供栈的支持，分配专门的寄存器来存放栈的地址，压栈出栈都有相应的指令，因此比较快。堆是由库函数提供的，机制很复杂，库函数会按照一定的算法进行搜索内存，因此比较慢。

**静态全局变量、全局变量区别**

- 静态全局变量和全局变量都属于常量区 
- 静态全局区只在本文件中有效，别的文件想调用该变量，是调不了的，而全局变量在别的文件中可以调用。
- 如果别的文件中定义了一个该全局变量相同的变量名，是会出错的。

**静态局部变量、局部变量的区别**

- 静态局部变量是属于常量区的，而函数内部的局部变量属于栈区
- 静态局部变量在该函数调用结束时，不会销毁，而是随整个程序结束而结束，但是别的函数调用不了该变量，局部变量随该函数的结束而结束； 
- 如果定义这两个变量的时候没有初始值时，静态局部变量会自动定义为0，而局部变量就是一个随机值
- 静态局部变量在编译期间只赋值一次，以后每次函数调用时，不在赋值，调用上次的函数调用结束时的值。局部变量在调用期间，每调用一次，赋一次值。

通过以上基础知识我们知道c++的静态成员都是直接在静态全局区域分配内存。因此在编译时就已经内存就已经开始分配成功了，因此不需要实例化类并且解引用，可以直接使用。
# 第II部分 C++ 标准库

## 第8章 IO库

C++中没有直接的输入和输出库，而是使用标准库的IO库来进行IO操作，下面让我们进入IO的世界吧

### 8.1 IO类
IO基本类和头文件如下表：

IO库的类型和对应头文件

|头文件|类型|
|:---|:---|
|`iostream`|`istream,wistream` 从流读取数据；`ostream,wostream` 从流输出数据；`iostream,wiostream`读写流|
|`fstream`|`ifstream,wifstream` 从文件读取数据；`ofstream,wofstream` 从文件写入数据；`fstream,wfstream` 读写文件；|
|`sstream`|`istringstream,wistringstream`从`string`读取数据;`ostringstream,wostringstream`向`string`写入数据;`stringstream,wstringstream` 读写`string`|

注意：

- IO对象无拷贝或者赋值--通过重载拷贝构造函数和赋值操作，禁止拷贝和赋值；或者**将拷贝构造函数与赋值函数，声明为private，并且不给出实现**
- 在函数后面使用`=delete`；例如：`NoCopyable(const NoCopyable&) = delete;`;其中
delete表明函数已删除。使用会报错："尝试使用已删除的函数";（参考：[C++禁止对象拷贝](https://blog.csdn.net/qqqqqqqqqq1qqqqqqqqq/article/details/46006791)）

**c++中的浅拷贝和深拷贝**

_参考链接：_ [C++本质：类的赋值运算符=的重载，以及深拷贝和浅拷贝](https://www.cnblogs.com/zsq1993/p/5791130.html)；[C++的拷贝构造函数、operator=运算符重载，深拷贝和浅拷贝、explicit关键字](https://blog.csdn.net/shine_journey/article/details/53081523)；

c++默认的拷贝构造函数和赋值运算符都是简单的浅拷贝，直接使用其它变量初始化对象，并没有重新分配内存，**但是如果实行浅拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。**因此类的成员变量需要动态开辟堆内存，此时，深拷贝尤为重要。默认类的缺省函数都是浅拷贝函数。简单示例如下：

```c++
//原始浅拷贝

#include <iostream>
using namespace std;

class Data {
public:
    Data() {}
    Data(int _data) :data(_data)
    {
        cout << "constructor" << endl;
    }
    //简单赋值浅拷贝

    Data& operator = (const int _data)
    {
        cout << "operator = (const int _data)" << endl;
        data = _data;
        return *this;
    }
private:
    int data;   
};

int main()
{
    Data data1(1);
    Data data2, data3;
    data2 = 1;
    data3 = data2;//调用编译器提供的默认的赋值运算符重载函数，当自定义析构函数的时候会存在问题
 
    return 0;
}

//深拷贝

#include <iostream>
#include <string>
using namespace std;

class MyStr {
public:
    MyStr() {}
    MyStr(int _id, char *_name)
    {
        cout << "constructor" << endl;
        id = _id;
        name = new char[strlen(_name) + 1];
        strcpy_s(name,strlen(_name) + 1,_name); 
    }
    //深拷贝构造函数

    MyStr(const MyStr &str)
    {
        cout << "copy constructor" << endl;
        id = str.id;
        if (name != NULL)
            delete name;
        name = new char[strlen(str.name) + 1];
        //拷贝数据

        strcpy_s(name,strlen(str.name) + 1,str.name);
    }

    MyStr& operator=(const MyStr& str)
    {
        cout << "operator=" << endl;
        if (this != &str)
        {
            if (name != NULL)
                delete name;
            this->id = str.id;
            name = new char[strlen(str.name) + 1];
            //拷贝字符长度

            strcpy_s(name,strlen(str.name) + 1,str.name);

            return *this;
        }
    }
    ~MyStr() 
    {
        cout << "deconstructor" << endl;
        delete name;
    }
private:
    char *name;
    int id;
};

void main()
{
    MyStr str1(1,"Jack");
    MyStr str2;
    str2 = str1;
    MyStr str3 = str2;
    return;

}


```

IO库条件状态：

|状态|含义|
|:---|:---|
|`strm::iostate`|strm是一种IO类型。iostream是一种机器相关的整型提供了表达条件状态的完整功能|
|`strm::badbit`|`strm::badbit`用来指出流已崩溃|
|`strm::failbit`|`strm::failbit`用来指出一个IO操作失败了|
|`strm::eofbit`|`strm::eofbit`用来指出流达到了文件结束|
|`strm::goodbit`|`strm::goodbit`用来指出流未处于错误状态。此值保证为零|
|`s.eof()`|流 s 的 `eofbit` 置位，则返回 `true`|
|`s.fail()`|流 s 的 `failbit` 或 `badbit` 置位，则返回 true|
|`s.bad()`|流 s 的 badbit 置位，则返回 true|
|`s.good()`|若流 s 处于有效状态，则返回 true|
|`s.clear()`|将流 s 中的所有条件状态位复位，将流的状态设置为有效。返回void|
|`s.clear(flag)`|根据给定的 flags 标志位，将流 s 中对于条件状态位复位。 flag 的类型是`strm::iostate`。返回 void|
|`s.setstate(flag)`|根据给定的 flags 标志位，将流 s 中对于条件状态位置位。 flag 的类型是strm::iostate。返回 void|
|`s.rdstate()`|返回流 s 的当前条件，返回值类型为 `strm::iostate`|

**四种条件状态**

|状态|含义|数值|`good()`|`eof()`|`bad()`|`fail()`|`rdstate()`|
|:---|:---|:---|:---|:---|:---|:---|:---|
|`ios::goodbit`|流状态完全正常|0|1|0|0|0|`goodbit`|
|`ios::eofbit`|已达到文件结束|2|0|1|0|0|`eofbit`|
|`ios::badbit`|输入（输出）流出现非致命错误，可挽回|1|0|0|1|0|`badbit`|
|`ios::failbit`|输入（输出）流出现致命错误，不可挽回|4|0|0|0|1|`failbit`|

**文件结束**

|状态|解释|
|:---|:---|
|`strm::eofbit`|`strm::eofbit`用来指出流达到了文件结束|
|`s.eof()`|流 s 的 `eofbit` 置位，则返回 `true`|

注意：

- 一个流一旦发生错误，其上后续的IO操作都会失败。因此一般使用`while(cin>>word)`来检测是否成功。

iostate 类型用来表示流状态的完整功能。使用示例如下：

```c++
auto old_state=cin.restate(); //记住cin的状态

cin.clear();//使得cin有效

process_input(cin); //使用cin

cin.setstate(old_state);//设置cin为原有状态。

cin.clear(cin.rdstate() & ~cin.failbit & ~cin.badbit);//复位failbit和badbit,保持其他标志位不变。

```

#### 管理输出缓冲

每个输出流都管理一个缓冲区，用来保存程序读写的数据；例如`os<<"Please enter a value:";`中文本串可能被立即打印出来，但也有可能被操作系统保存在缓冲区中，随后打印。

注意：如果程序异常崩溃，输出缓冲区不会更新，数据很可能停留在缓冲区中等待打印。因此当程序崩溃后，需要确定已经输出的数据确实已经刷新了，否则可能将大量时间浪费在追踪代码为什么没有执行上面。

输入和输出流也是可以正常关联的：利用`ostream`的`tie`实现相关操作。`tie()`当前关联到的输出流，`tie(&o)`关联到o输出流。多个流可以关联到同一个`ostream`;下面是使用示例：

```c++
cin.tie(&cout); //将标准cin与cout关联在一起。

ostream *old_tie=cin,tie(nullptr);//关联空流

cin.tie(&cerr); //读取cin会刷新cerr而不是cout

cin.tie(old_tie); //重建cin和cout间的正常关联。

```

#### 文件输入输出
_参考链接:_ [fstream参考](http://www.cplusplus.com/reference/fstream/fstream/)；

fstream特有操作：

|名称|操作|
|:---|:---|
|`fstream fstrm`|创建一个未绑定的文件流|
|`fstream fstrm（s）`|创建一个fstream，并打开名为s的文件。默认的文件模式mode依赖于fstream的类型|
|`fstream fstrm（s，mode）`|与前一个构造函数类似，但按指定mode打开文件|
|`fstrm.open(s)`|打开名为s的文件，并将文件与fstrm绑定，默认的文件mode依赖于fstream的类型，返回void|
|`fstrm.close()`|关闭与fstrm绑定的文件，返回void|
|`fstrm.is_open()`|返回一个bool值，指出与fstrm关联的文件是否成功打开且尚未关闭|

文件的打开有两种方式：

-  在初始化输入输出对象时，直接构建；如： `ifstream in(ifile)`
-  先声明，再使用`open`函数关联文件；例如：

```c++
std::string ifile="c:/Windows/assembly/test";
ifstream in(ifile); //构筑一个ifstream并打开给定文件

ofstream out; //输出文件流未与任何文件相关联。

out.open(ifile+".txt");//打开指定文件

in.close(); //关闭文件


```

注意： 
- 当一个`fstream`对象呗销毁时,`close`会自动被调用。
- 默认模式打开文件进行输出将自动打开文件的长度截为零，即 **删除已有内容**。 （细节！！） 

文件读写模式：

|模式|作用|
|:---|:---|
|`in`|读方式打开|
|`out`|写方式打开|
|`app`|每次写操作前均定位到文件末尾|
|`ate`|打开文件后立即定位到文件末尾|
|`trunc`|截断文件|
|`binary`|二进制方式进行io|

注意：以`out`模式打开文件会丢弃已有数据，因此常需要附加`app`模式；例如：

```c++
ofstream out("file1");// 输出模式打开文件并截断文件

ofstream out2("file1",ofstream::out);//隐含第截断文件

ofstream out3("file1",ofstream::out | ofstream::trunc);
//保留文件内容显式指定app模式。

ofstream app("file2",ofstream::app);
//隐含为输出模式 

ofstream app2("file2",ofstream::out | ofstream::app);
```

每次使用open函数都可以再次更改文件模式。
文件流使用示例：

```c++
# include<iostream>
# include<fstream>
# include<string>
using namespace std;
 
int main()
{
    //读取初始文件内容，并输出显示
    
    ifstream in;
    in.open("guest.txt");
    char ch;
    if (in.is_open())
    {
        cout << "Here are the current contents of thepeople.text's file:" <<endl;
        while (in.get(ch))
            cout << ch;
        cout << endl;
        in.close();
 
    }
 
    // 添加内容到文件
    
    ofstream out;
    out.open("D:guest.txt", ofstream::app);  
    //out.open("people.txt", ios_base::app);
    
    if (!out.is_open())
    {
        cout << "failed to open file" << endl;
    }
    cout << "Please enter content:";
    string str;
    while (getline(cin, str) && str.size() > 0)
    {
        out << "\n"<<str << endl;
    }
    out.close();
    //读取修改后的文件内容，并输出显示

    in.open("guest.txt");
    if (in.is_open())
    {
        cout << "Here are the revised contents of the people.text's file:" << endl;
        while (in.get(ch))
            cout << ch;
        cout << endl;
        in.close();
    }
 
    return 0;
 
}

```

### string 流

string相关流继承关系如下图：

![相关继承关系](http://www.pconline.com.cn/pcedu/empolder/gj/c/0504/pic/08cppios01.gif)

stringstream的特有操作

|操作|含义|
|:---|:---|
|`sstream strm`|定义字符串头文件类型|
|`sstream strm(s)`|保存string s的一个拷贝|
|`strm.str()`|返回strm所保存的`string`的拷贝|
|`strm.str(s)`|将`string s` 拷贝到`strm`中。返回`void`|

## 第 9 章顺序容器

容器是一些特定类型对象的集合。顺序容器为程序员提供了控制元素存储和访问顺序的能力。下面是简介表

|类型|特点|
|:---|:---|
|`vector`|可变大小数组。支持快速随机访问。在尾部之外的位置插入或者删除元素|
|`deque`|双端队列。支持快速随机访问。在头尾插入/删除速度很快|
|`list`|双向链表。只支持双向顺序访问。在`list`中任何位置进行插入/删除操作速度都很快|
|`forward_list`|单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快|
|`array`|固定大小数组。支持快速随机访问。不能添加或者删除元素|
|`string`|与`vector`相似的容器，但是专门保存字符。随机访问快。在尾部插入/删除速度很快|

下面是一些选择容器的基本原则：

- 除非有很好的理由，否则应使用`vector`
- 如果你的程序有很多小元素，且额外开销很重要，则不要使用`list`或者`forward_list`。
- 如果程序要求随机访问元素，应该使用`vector`或者`deque`。
- 如果程序要求在容器的中间插入或者删除元素，应该使用`list`或者`forward_list`。
- 如果程序需要在头尾位置插入或者删除元素，但不会在中间位置进行插入，则使用`deque`。
- 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则：
    + 首先，确定是否真的需要在容器中间位置添加元素，当处理输入数据时，通常可以很容易地向`vector`追加数据，然后再调用标准库`sort`函数来重新排列容器中的元素，从而避免在中间位置添加元素。
    + 如果必须在中间位置插入元素，考虑在输入阶段使用`list`，一旦输入完成，将`list`中的内容拷贝到一个`vector`中。

容器操作：


|类型别名|操作|
|:---|:---|
|`iterator`|此容器类型的迭代器类型|
|`const_iterator`|可以读取元素，但不能修改元素的迭代器类型|
|`size_type`|无符号整数类型，足够保存此种容器类型最大可能容器的大小|
|`difference_type`|带符号整数类型，足够保存两个迭代器之间的距离|
|`value_type`|元素类型|
|`reference`|元素的左值类型；与`value_type&`含义相同|
|`const_reference`|元素的`const`左值类型(即，`const value_type&`)|


|构造函数|操作|
|:---|:---|
|`C c`|默认构造函数，构造空容器(array)|
|`C c1(c2)`|构造`c2`的拷贝`c1`|
|`C c(b,e)`|构造`c`,将迭代器`b`和`e`指定的范围内的元素拷贝到`c`|
|`C c{a,b,c ...}`|列表初始化`c`|


|赋值与`swap`|操作|
|:---|:---|
|`c1=c2`|将`c1`中的元素替换为`c2`中元素|
|`c1={a,b,c...}`|将`c1`中的元素替换为列表中元素(不适用于array)|
|`a.swap(b) or swap(a,b) `|交换a和b的元素|


|大小|操作|
|:---|:---|
|`c.size()`|c中元素的数目(不支持`forward_list`)|
|`c.max_size()`|c可保存的最大元素数目|
|`c.empty()`|若`c`中存储了元素，返回`fasle`,否则返回`true`|

|添加/删除元素|操作|
|`c.insert(args)`|将`args`中的元素拷贝进`c`|
|`c.emplace(inits)`|适用`inits`构造`c`中的一个元素|
|`c.clear()`|删除`c`中所有的元素，返回`void`|

|关系运算符|解释|
|:---|:---|
|`==,!=`|所有容器都支持相等(不等)运算符|
|`<,<=,>,>=`|关系运算符(无序关联容器不支持)|

|获取迭代器|解释|
|:---|:---|
|`c.begin(),c.end()`|返回指向`c`的首元素和尾元素之后位置的迭代器|
|`c.cbegin(),c.cend()`|返回`const_iterator`|

|反向容器的额外成员(不支持`forward_list`)|解释|
|:---|:---|
|`reverse_iterator`|按逆序寻址|
|`const_reverse_iterator`|不能修改元素的逆序迭代器|
|`c.rbegin(),c.rend()`|返回指向cz的尾元素和首元素之前位置的迭代器|
|`c.crbegin(),c.crend()`|返回`const_reverse_iterator`|

**迭代器**

迭代器范围是标准库的基础，标砖库的很多操作都是基于迭代器产生的。`begin`迭代器迭代器指向迭代器开头的元素；`last`迭代器指向尾元素之后的元素；即不是指向尾部元素，元素范围为**左闭右开**

代码示例：

```c++
list<string> a={"string1","string2","string3"};
auto it1=a.begin(); //lsit<string>::iterator;

auto it2=a.rbegin();//list<string>::reverse_iterator;

auto it3=a.cbegin(); //list<string>::const_iterator;

auto it4=a.crbegin();//list<string>::const_reverse_iterator
```

注意：

- 顺序容器不需要写访问时，应该尽量使用`cbegin`和`cend`；
- 只有顺序容器不包括(array)的构造函数才能接受大小参数
- 拷贝构造只有当容器类型匹配时才能成立，
- 当将一个容器初始化为另外一个容器的拷贝的时候，两个容器的容器类型和元素类型都必须相同。

**标准库array具有固定大小**
与内置数组一样，标准库array的大小也是类型的一部分。当定义一个`array`时，除了指定元素类型，还要指定容器大小；使用array类型，也必须指定元素类型的大小；array初始化会自动给与0值。内置数组不允许拷贝，但是array类型允许拷贝。

```c++
array<int ,42>; //类型为：保存42个int的数组

array<string,10>; //类型为：保存10个 string的数组

array<int,10>::size_type i;//数组类型包括元素类型和大小

array<int>::size_type j; //错误:array<int>不是一个类型

```

**替换操作 `assign`**

|函数|功能|
|:---|:---|
|`seq.assign(b,e)`|将seq中的元素替换为迭代器b和e所示到范围中的元素。迭代器b和eb不能指向seq中的元素|
|`seq.assign(li)`|将seq中的元素替换为初始化列表li中的元素|
|`seq.assign(n,t)`|将seq中的元素替换为n个值为t的元素|

使用：`vector<int > b(10,5);vector<int> a;a.assgin(b.cbegin(),b.cend());`

注意：赋值运算会导致指向左边容器内部的迭代器、引用和指针失效。而`swap`操作将容器内容交换不会导致容器的迭代器、引用和指针失效(容器类型为array和string的情况除外)；例如，假定`iter`在`swap`之前指向`svecl[3]`中的string,那么在`swap`之后它指向`svec2[3]`的元素。但是array会真正交换他们的元素。因此交换两个array所需的时间与array中元素的数目成正比。

##### 关系运算符
每个容器类型都支持相等运算符(==和!=)除了无序关联容器外，都支持关系运算符(>、>=、<、<=)。关系运算符两边必须是相同类型的容器，且必须保存相同类型的元素。元素相等比较规则如下：

1. 如果两个容器具有相同大小且所有元素都两两对应相等，则这个容器相等，否则不相等。
2. 如果两个容器大小不相同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器
3. 如果两个容器都不是另外一个容器的前缀子序列，则他们的比较结果取决于第一个不相等的元素的比较结果。
4. 只有当其元素类型也定义了相应的比较运算符的时候，我们才可以使用关系运算符来，比较两个容器。

##### 向顺序容器中添加元素

|操作名称|作用|
|:---|:---|
|`c.push_bcak(t)`|在c的尾部创建并插入一个元素|
|`c.push_back(t)`|在c的头部创建并插入一个元素|
|`c.insert(p,t)`|在迭代器p指向的元素之前创建插入一个元素，返回指向新添加元素的迭代器|
|`c.insert(p,n,t)`|在迭代器p指向的元素之前创建插入n个元素，返回指向新添加元素第一个元素的迭代器|
|`c.insert(p,b,e)`|将迭代器b和e指定的范围内的元素插入到迭代器p指向的元素之前，返回指向新添加元素第一个元素的迭代器；若p为空则返回p|
|`c.insert(p,il)`|il是一个花括号包围的元素值列表。将这些给定值插入到迭代器p指向的元素之前，返回指向新添加的第一个元素的迭代器|

注意： 

- 向一个`vector`、`string`或者`deque`插入元素会使所有指向容器的迭代器、引用和指针失效。
- 容器元素插入和初始化都是拷贝
- 使用插入`insert`的时候会返回插入的值

**使用emplace操作**

新标准中引入了三个新成员函数-`emplace_front`、`emplace`和`emplace_back`它们与`insert`系列操作相同，
注意：

- `emplace`函数在容器中直接构造元素，传递给`emplace`函数的参数必须与元素类型的构造函数相匹配。

例如：
```c++
c.emplace_back("99999",25,15.99);//错误没有接受三个参数的`push_back`版本

c.push_back("99999",25,15.99);//正确创建一个临时的`push_back`版本
```

##### 顺序容器中访问元素操作

|操作|含义|
|:---|:---|
|`c.back()`|返回c中尾元素的引用。若c空，函数行为未定义|
|`c.front()`|返回c中首元素的引用。若c空，函数行为未定义|
|`c[n]`|返回c中下标为n元素的引用。若c空，n>=c.size()函数行为未定义|
|`c.at(n)`|返回c中下标为n元素的引用。若越界抛出异常|

建议：尽量使用at函数，避免下标越界


##### 顺序容器中删除元素操作

|操作|含义|
|:---|:---|
|`c.pop_back()`|删除c中尾部元素，若c空，函数行为未定义|
|`c.pop_front()`|删除c中首元素的引用。若c空，函数行为未定义|
|`c.erase(n)`|删除迭代器p所指的元素，返回一个指向被删除元素之后元素的迭代器|
|`c.erase(b,e)`|删除迭代器b和e所指定范围内的元素。返回指向最后一个被删除元素之后元素的迭代器|
|`c.clear()`|删除c中所有元素。返回`void`|

注意对于单链表而言有许多不同之处

![链表操作](http://wangpengcheng.github.io/img/fowrd_list_insert.png)

当在forword_list中添加或者删除元素时，我们必须关注两个迭代器-一个指向我们要处理的元素，另外一个指向其前驱元素。例如：

```c++
forward_list<int> flst={0,1,2,3,4,5,6,7,8,9}；
auto prev=flst.before_begin(); //表示flst的首前元素

auto curr=flst.begin();   //表示flst中的第一个元素

while(curr!=flst.end()) {
    if(*curr%2){
        curr=flst.erase_after(prev); //删除并移动curr

    }else{
        prev=curr;//移动迭代器curr,指向下一个元素，prev指向curr之前的元素
        
        ++curr;
    }
}


```
##### 容器操作可能会使迭代器失效

_参考链接：_ [C++迭代器失效的几种情况总结](https://www.cnblogs.com/fnlingnzb-learner/p/9300073.html)；[C++之迭代器失效及解决](https://blog.csdn.net/Yinghuhu333333/article/details/80744440)；

在向容器中添加元素之后：

- 如果容器是`vector`或者`string`，且存在存储空间被重新分配，则指向容器的迭代器、指针和引用内存都会失效。如果没有重新分配内存，指向插入位置之前的元素的迭代器、指针和引用仍然有效，但是指向插入之后的元素迭代器、指针和引用都会失效
- 对于`deque`插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但是指向存在的元素的引用和指针不会失效。
- 对于`list`和`forward_list`指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效。

在删除一个元素后

- 对于`list`和`forward_list`指向容器其它位置的迭代器、引用指针任然有效。
- 对于`deque`如果在首尾之外的任何位置删除元素，那么指向被删除元素之外其它元素的迭代器、引用或者指针也会失效。如果删除的是尾部元素，则尾后的迭代器也会失效，但其它迭代器、引用和指针不受影响；如果删除首尾元素，这些也不会受影响。
- 对于`vector`和`string`,指向被删除元素之前元素的迭代器、引用和指针仍然有效。注意当我们删除元素时，尾后迭代器总是会失效。

因为添加删除原来的元素后，`end`迭代器总是会失效，因此尽量不要保存`end`返回的迭代器

vector和string 的容器大小管理操作
`capacity()`容器在不扩张内存空间的情况下可以容纳多少个元素，`reserve`允许我们通知容器它应该准备保存多少个元素


|操作|含义|
|:---|:---|
|`c.shrink_to_fit()`|将`capacity（）`减小为和`size`相同大小|
|`c.capacity()`|不重新分配内存空间的话，c可以保存多少元素|
|`c.reserve(n)`|分配至少能容纳n个元素的内存空间|

注意： reserve并不改变容器元素中的数量，它仅仅影响vector预先分配多大的内存空间。


##### 额外的string操作

|操作|含义|
|:---|:---|
|`s.insert(pos,args)`|在迭代器pos之前插入args指定的字符|
|`s.erase(pos,len)`|删除从位置`pos`开始的`len`个字符。如果len 被省略则删除从`pos`开始至s末尾的所有字符。返回一个指向`s`的引用|
|`s.assign(args)`|将`s`中的字符串替换为`args`指定的字符。返回一个指向`s`的引用|
|`s.append(args)`|将`s`后添加`args`指定的字符。返回一个指向`s`的引用|
|`s.replace(range,args)`|删除`range`范围内的字符，替换为`args`指定的字符，返回`s`的引用|


**string搜索操作**

|操作|含义|
|:---|:---|
|`s.find(args)`|查找`s`中第一次出现的位置|
|`s.rfind(args)`|查找`s`中最后一次出现的位置|
|`s.find_frist_of(args)`|在`s`中查找`args`中任何一个字符，第一次出现的位置|
|`s.find_last_of(args)`|在`s`中查找`args`中任何一个字符，最后一次出现的位置|
|`s.find_frist_not_of(args)`|在`s`中查找第一个不在`args`中的字符|
|`s.find_last_not_of(args)`|在`s`中查找最后一个不在`args`中的字符|

```c++
//循环查找下一个数

string::size_type pos=0;
while((pos=name.find_frist_of(number,pos))!=string::npos) {
    cout<<"found number at index: "<<pos
        <<"element is "<<name[pos]<<endl;
        ++pos;//移动到下一个字符    
}

```

`compare`比较字符串；`to_string()`将数字转化为字符串。

**string和数值之间的转换**

|操作|含义|
|:---|:---|
|`to_string(val)`|将任意一种算术类型`val`转化为`string`|
|`stoi(s,p,b)`|返回s的起始字符子串(整数内容)的数值 `int`,b是转换基数，p是`size_t`指针|
|`stol(s,p,b)`|返回s的起始字符子串(整数内容)的数值 `long`,b是转换基数，p是`size_t`指针|
|`stoul(s,p,b)`|返回s的起始字符子串(整数内容)的数值 `unsigned long`,b是转换基数，p是`size_t`指针|
|`stoll(s,p,b)`|返回s的起始字符子串(整数内容)的数值 `long long`,b是转换基数，p是`size_t`指针|
|`stoull(s,p,b)`|返回s的起始字符子串(整数内容)的数值 `unsigned long long`,b是转换基数，p是`size_t`指针|
|`stof(s,p)`|返回s的起始字符子串(整数内容)的数值 `float`,b是转换基数，p是`size_t`指针|
|`stod(s,p)`|返回s的起始字符子串(整数内容)的数值 `long long`,b是转换基数，p是`size_t`指针|
|`stold(s,p)`|返回s的起始字符子串(整数内容)的数值 `long double`,b是转换基数，p是`size_t`指针|

### 容器适配

出来标准容器外还有三个顺序容器适配器： `stack`、`queue`和`proiority_queue`。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。例如`stack`适配器接受一个顺序容器，并使其操作像一个stack一样。下面是使用示例：

```c++
stack<int> stk(deq);//从deq拷贝元素到stk

stack<string ,std::vector<string> > str_stk;//在vector上实现的空栈

stack<string ,vector<string > > str_stk2(svec);//str_stk2在vector上实现，初始化时保存svec的拷贝

```
## 泛型算法

泛型算法是指使用迭代器为媒介的通用型算法；泛型算法本身不会执行容器的操作，他们只会运行于迭代器智商，执行迭代器的操作--算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素值。

**`accumulate` 求和**

```c++

int sum =accumulate(vec.cbegin(),vec.cend(),0);//对元素求和初值是0

string sum=accumulate(v.cbegin(),v.cend(),string(''));//字符串求和

equal(roster1.cbegin(),roster1.cend(),rosterl2.cbegin());//比较元素，数量相同且一样多的时候才返回`true`

fill(vec.begin(),vec.begin()+vec.size()/2,10);//将容器的一个子序列设置为10

back_inserter();//插入元素，检查是否存在

copy(begin(a1),end(a1),a2);//把a1的内容拷贝给a2

replace(ilist.begin(),ilist.end(),0,42);//查找所有元素为0的值，并将它更改为42

replace_copy(ilis.cbegin(),ilist.cend(),back_inserter(ivec),0,42);//ilist指出调整序列之后的保存位置。

sort(word.begin(),word.end());//按照字典排序

auto end_unique=unique(words.begin(),words.end());//除去重复单词

``` 

注意：
 
- 算法不检查写操作
- 向目的位置迭代器写入数据的算法，假定目的位置足够大，能容纳要写入的元素。

### 定制操作
许多算法的默认关键操作符，并不能满足我们的需求，因此，需要我们来重载`sort`的默认行为。

#### 向算法传递函数
sort可以接受第三个参数，即谓词--一个可用的表达式，其返回结果是一个能用作条件的值。标准库中分为
**一元谓词**(只接受单一参数)和**二元谓词**(他们有两个参数)。例如下面的代码，重载了sort函数的基础比较操作

```c++
//排序函数

bool isShorter(const string &s1,const string &s2){
    return s1.size()<s2.size();
}
//按照长度由短到长排序
sort(words.begin(),words.end(),isShorter);

elimDups(words);//将words按照字典重新排序，并消除重复单词

stable_sort(words.begin(),words.end(),isShorter)；//按照长度重新排序，长度相同的单词维持字典序

//无需拷贝字符串

for (const auto &s :words)
{
    cout<<s<<"";//打印每个元素，以空格分割

}
cout<<endl;

```
### lambda 表达式

_参考链接：_ [c++11 lambda 表达式](https://www.cnblogs.com/DswCnblog/p/5629165.html);[c++ lambda表达式](https://www.cnblogs.com/jimodetiantang/p/9016826.html);

**lambda表达式的声明**

`[capture list] (params list) mutable exception-> return type { function body }`
各项含义如下：

1. `capture list`: 捕获外部变量列表
2. `params list`: 形参列表
3. `mutable`:用来说明是否可以修改捕获的变量
4. `exception`:异常设定
5. `return type`:返回类型
6. `function body`:函数体

省略的常见表达式有：

|序号|格式|
|:---|:---|
|1|`[capture list] (params list) -> return type {function body}`|
|2|`[capture list] (params list) {function body}`|
|3|`[capture list] {function body}`|

其中：

- 格式1声明了const类型的表达式，这种类型的表达式不能修改捕获列表中的值。
- 格式2省略了返回值类型，但编译器可以根据以下规则推断出Lambda表达式的返回类型： （1）：如果function body中存在return语句，则该Lambda表达式的返回类型由return语句的返回类型确定； （2）：如果function body中没有return语句，则返回值为void类型。
- 格式3中省略了参数列表，类似普通函数中的无参函数。

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

bool cmp(int a, int b)
{
    return  a < b;
}

int main()
{
    vector<int> myvec{ 3, 2, 5, 7, 3, 2 };
    vector<int> lbvec(myvec);

    sort(myvec.begin(), myvec.end(), cmp); // 旧式做法

    cout << "predicate function:" << endl;
    for (int it : myvec)
        cout << it << ' ';
    cout << endl;

    sort(lbvec.begin(), lbvec.end(), [](int a, int b) -> bool { return a < b; });   // Lambda表达式
    cout << "lambda expression:" << endl;
    for (int it : lbvec)
        cout << it << ' ';
}

```
lambde表达式的外部捕获

Lambda表达式通过在最前面的方括号[]来明确指明其内部可以访问的外部变量，这一过程也称过Lambda表达式“捕获”了外部变量。

值捕获方式：

|捕获形式  |  说明|
|:---|:---|
|`[]`| 不捕获任何外部变量|
|`[变量名, …]`    |默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&说明符）|
|`[this]` | 以值的形式捕获this指针|
|`[=]`| 以值的形式捕获所有外部变量|
|`[&]`| 以引用形式捕获所有外部变量|
|`[=, &x]`| 变量x以引用形式捕获，其余变量以传值形式捕获|
|`[&, x] `| 变量x以值的形式捕获，其余变量以引用形式捕获|

注意：如果一个lambda体包含`return`之外的任何语句，则编译器假定lambda返回`void`；被推断`void`的lambda不能返回值。因此当重写排序等操作的时候，只能有一句`return`语句；例如：

```c++
transform(vi.begin(),vi.end(),vi.begin(),
    [](int i){
        return i<0?-i:i;//返回绝对值

    });

transform(vi.begin(),vi.end(),vi.begin(),
    [](int i){
        if(i<0){
            return -i;
        }else{
            return i;
        }
        //错误，有多余语句，判定返回void

    });

```

因此当我们使用一个lambda定义返回类型的时候，必须使用尾置返回类型，声明返回类型；例如：

```c++
transform(vi.begin(),vi.end(),vi.begin(),
    [](int i)->int 
    {
        if(i<0){
            return -i;
        }else{
            return i;
        }
        //返回绝对值

    });
```

#### lambda 参数绑定
lambda表达式，虽然可以进行简单的参数绑定，但是对于复杂的参数绑定而言，还是存在许多问题，因此可以利用函数对lambda表达式进行参数绑定。大致步骤如下：
 
 1. 使用`std:bind`函数对函数参数和函数进行绑定
 2. 使用`placeholderd`进行参数占位符的使用。

调用`bind`一般形式为：
`auto newCallable=bind(callable,arg_list);`

`newCallable`本身是一个可以调用对象，`arg_list`是一个逗号分隔的参数列表，对应给定的`callable`的参数，即调用的实际参数。
`arg_list`中的参数可能包含形如`_n`的名字，其中`n`是一个整数。表示占位符，数值`n`表示生成的可调用对象中参数的位置：`_1`为`newCallble`的第一个参数，`_2`为第二个参数。`_n`为第`n`个参数。
使用：
`auto g=bind(f,a,b,_2,c,_1);`
生成一个新的可调用函数对象，它有两个参数，分别使用占位符`_2`和`_1`表示。使得原本需要输入5个参数的函数变为，只需要2个参数的函数，对函数进行了再一次封装。`f(a,b,_1,c,_2)`等价于`g(_1,_2)`减少了函数的复杂程度。

`std::ref()`：传递给`bind`一个对象但是不拷贝它

例如：

```c++
//1. 定义比较string大小函数

bool check_size(const string &s,string::size_type sz){
    return s.size()>=sz;
}

//2. 使用bind绑定函数和参数
//将输入比较顺序颠倒，将单词长度由长至短排序

sort(words.begin(),words.end(),bind(isShorter,_2,_1));

//使用lambda表达式，输出表达式，os是一个局部变量，引用一个输出流

for_each(word.begin(),words.end(),[&os,c](const string &s){
    os<<s<<c;
});
//bind相同的效果 

ostream &print(ostream &os,const string &s,char c){
    return os<<s<<c;
}
//ref返回一个对象，包含给定的引用，此对象是可以拷贝的

for_each(words.begin(),words.end(),
        bind(print,std::ref(os),_1,' '));


``` 

#### 再探迭代器

##### 插入迭代器
插入迭代器有三种基本类型

- `back_inserter`: 创建一个使用`push_back`的迭代器。
- `front_inserter`:创建一个使用`push_front`的迭代器。 
- `inserter`:创建一个使用`inserter`的迭代器。此函数接受第二个参数，这个参数必须是一个指向容器的迭代器。元素将被插入到给定迭代器所表示的元素制之前。

注意： 只有在容器支持`push_front/push_back`的情况下，我们才可以使用`front_inserter/back_inserter`。

使用示例：

```c++

*it=val;
it=c.insert(it,val);//it指向插入的新元素

++it;//递增it使它指向原来的元素

list<int> lst={1,2,3,4};
list<int> lst2，lst3;//空list
//拷贝完成之后，lst3包含1 2 3 4

copy(lst.cbegin(),lst.cend(),front_inserter(lst2));
//拷贝完成之后，lst3包含1 2 3 4

copy(lst.cbegin(),lst.cend(),inserter(lst3,lst3.begin()));

```

##### iostream 迭代器

- `istream_iterator`:读取输入流。
- `ostream_iterator`:向输出流写数据。

**`istream_iterator`操作** 

|操作|含义|
|:---|:---|
|`istream_iterator<T> in(is)`|`in`从输入流`is`读取类型为`T`的值|
|`istream_iterator<T> end`|读取类型为`T`的值的`istream_iterator`迭代器，表示尾后位置|
|`in1=(!)=in2`|`in1`和`in2`必须读取相同类型。如果他们都是尾后迭代器，或绑定到相同输入，则二者相等|
|`*in`|返回从流中读取的值|
|`in->mem`|与`(*in).mem`的含义相同|
|`++in,in++`|使用元素类型所定义的`>>`运算符从输入流中读取下一个值，并且前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值|

操作示例：

```c++
istream_iterator<int > int_it(cin); //从cin读取int

istream_iterator<int> int_eof; //尾后迭代器

ifstream in("afile");  
istream_iterator<string> str_it(in); //从"afile"读取字符串

//读入数据并存储到vector向量组

while(int_it!=eof) {
    //后置递增运算读取流，返回迭代器的旧值
    //解引用迭代器，获得从流读取的前一个值

    vec.push_back(*in_iter++);
}
//循环读取其中的int值存储在vec中

//使用算法操作流迭代器

istream_iterator<int > in(cin),eof;
cout<<accumulate(in,eof,0)<<endl;
//输入：23 109 45 89 6 34 12 90 34 23 56 23 8 89 23

//输出：664


```
注意：当我们将一个`istream_iterator`绑定到一个流时，标准库并不保证迭代器立即从流中读取数据。直到使用迭代器时才正真读取。标准库中的实现所保证的是，我们第一次解引用迭代器之前，从六中的数据操作已经完成了。

##### `ostream_iterator`操作

|操作|含义|
|:---|:---|
|`ostream_iterator<T> out(os)`|`out`将类型为`T`的值写入到流`os`中|
|`ostream_iterator<T> out(os,d)`|将类型为`T`的值写到输出流`os`中，每个值后面都输出一个`d`。`d`指向一个空字符结尾的字符数组|
|`out=val`|`out`和`val`必须类型兼容。用运算符`<<`将`val`写入到`out`输出流中|
|`*out,++out,out++`|这些运算符是存在的，但是不对`out`做任何事情。每个运算符都返回`out`|

### 泛型算法结构
对于向一个算法传递错误类别的迭代器的问题，很多编译器不会给出任何警告或者提示。因此需要迭代器类型的支持和认证。

**迭代器类别**

|类别|含义|
|:---|:---|
|输入迭代器|只读，不写；单遍扫描，只能递增|
|输出迭代器|只写，不读；单遍扫描，只能递增|
|前向迭代器|可读写；多遍扫描，只能递增|
|双向迭代器|可读写；多遍扫描，可递增递减|
|随机访问迭代器|可读写；多遍扫描，支持全部迭代运算|

## 第11章 关联容器

关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是`map`和`set`；关联容器不支持顺序容器的位置相关的操作。也不支持构造函数或者插入操作这些接受一个元素值和一个数量值的操作。

使用示例：
```c++
std::map<string, size_t;> word_count;//空容器

set<string> exclude={"the","but","and","or","an","a"};

//三个元素；authors将姓映射为名

map<string ,string> authors={
    {"Joyce","James"},
    {"Austen","Jane"},
    {"Dickens","Charles"}
};
```

注意：一个`map`或者`set`中的关键字必须是唯一的。但是`multimap`和`multiset`没有这个限制。允许多个元素，拥有相同的关键字。

#### 11.2.2 关键字类型要求
传递给排序算法的可调用对象，必须满足于关联容器中关键字一样的类型要求。

#### 11.2.3 `pair`类型

`pair`主要保存，两个数据成员，必须提供2个类型名，`pair`的数据成员，将具有应对的类型。

```c++
pair<string ,string > anon; //保存两个string

pair<string ,size_t> word_count; //保存一个string和一个size_t

pair<string ,vector<int>> line; //保存string和vector<int>

```

**`pair`上的操作**

|操作|含义|
|:---|:---|
|`pair <T1,T2> p`|p是一个`pair`，两个类型分别为`T1`和`T2`的成员都进行了初始化|
|`pair <T1,T2> p(v1,v2)`|p是一个`pair`，两个类型分别为`T1`和`T2`的`v1`和`v2`都进行了初始化|
|`pair <T1,T2> p={v1,v2}`|意义同上|
|`make_pair(v1,v2)`|返回一个用`v1`,`v2`初始化的`pair`。`pair`的类型从`v1`和`v2`的类型中推断出来|
|`p.first`|返回`p`的名称为`first`的公有数据成员|
|`p1 relop p2`|关系运算符(<、>、<=、>=)按照字典序定义：例如对应成立时返回`true`|

### 11.3 关联容器操作

|操作类型|含义|
|:---|:---|
|`key_type`|此容器类型的关键字类型|
|`mapped_type`|每个关键字关联的类型；只适用于`map`|
|`value_type`|对于`set`,与`key_type`相同；对于`map`，为`pair<const key_type,mapped_type>`|

```c++
set<string>::value_type v1; //v1是一个string

set<string>::key_type v2; //v2是一个string

map<string,int>::value_type v3;//v3是一个pair <const string ,int>

map<string,int>::key_type v4; //v4是一个string

map<string,int>::mapped_type v5; //v5是一个int

```
注意：

- 一个`map`的`value_type`是一个`pair`,我们可以改变`pair`的值，但不能改变关键字成员的值。
- `set`的迭代器是`const`的，只能读取，不能修改。

#### 11.3.1 关联容器迭代器
使用示例：

```c++
auto map_it=word_count.begin();  //*map_it 是一个指向pair<const string,size_t>对象的引用

cout<<map_it->first; //打印此元素的关键字

cout<<""<<map_it->second; //打印此元素的值

map_it->first="new key"; //错误：关键字是const的

++map_it->second; //正确：我们可以通过迭代器改变元素

```
因为关联容器`set`的迭代元素是`const`的，`map`中的元素是`pair`，其第一个成员是`const`的，因此关联容器，通常用于值读取元素的算法,多为搜索排序。
同时使用`insert`来添加元素

```c++
vector<int> ivec={2,4,6,8,10};//ivec有8个元素

set<int> set2; //空集合

set2.insert(ivec.cbegin(),ivec.cend());//set2有4个元素

set2.insert({1,3,5,7,9});//set2现在有8个元素

```
关联容器操作：
`emplace(args)`:对于`map`和`set`,只有当元素的关键字不在`c`中时才插入(或者构造)元素。函数返回一个`pair`,包含一个迭代器，指向具体有指定关键字的元素，以及一个指示插入是否成功的bool值。

注意插入操作返回的是一个`pair`对象，第一个元素是差诶迭代器的坐标，第二个值是一个`bool`值，确定是否插入成功。

```c++
//统计每个单词在输入中出现的次数

map<string ,size_t> word_count;//从string到size_t的空map

string word;

while(cin>>word){
    //插入一个元素，关键字等于word，值为1；
    //若word已载word_count中，insert什么也不做
    auto ret=word_count.insert({word,1});

    if(!ret.second)  //word已经在word_count中

        ++ret.first->second; //递增计数器

/*

等价形式 ++((ret.first)->second);
ret 保存insert返回的值，是一个pair
ret.first 是pair的第一个成员，是一个map迭代器，指向具有给定关键字的元素
ret.first-> 解引用此迭代器，提取map中的元素，元素也是一个pair
ret.first->second; map中元素值的部分
++ ret.first->second; 递增此值
*/
}
```
#### 11.3.3 删除元素
使用`erase`函数来删除和释放元素;
```c++
auto cnt=authors.erase("Barth,Johns");
```

#### 11.3.4 map的下表操作

|操作|含义|
|:---|:---|
|`c[k]`|返回关键字为`k`的元素；如果`k`不在`c`中，添加一个关键字为`k`的元素，对其进行值初试化|
|`c.at(k)`|访问管家字为`k`的元素|

示例：
```c++
map <string ,size_t> word_count; //empty map

//插入一个关键字为Anna的元素，关联值进行值初试化；然后将1赋予它

word_count["Anna"]=1;

```
注意：

- 对一个`map`使用下表操作，使用一个不在容器中的关键字作为下表，会添加一个具有此关键字的元素到`map`中
- 与`vector`与`string`不同，`map`的下标运算符，返回的类型与解引用`map`迭代器得到的类型不同。
- `map`使用`find`代替下标操作
- `lower_bound`和`upper_bound`不适用于无序容器
- 下标和`at`操作只适用于非`const`的`map`和`unordered_map`

**关联容器中查找元素的操作**

|操作|含义|
|:---|:---|
|`c.find(k)`|返回一个迭代器，指向第一个关键字为`k`的元素，若`k`不在容器中则返回尾后迭代器|
|`c.count(k)`|返回关键字等于`k`的元素的数量。对于不允许重复关键字的容器，返回值永远是0或者1|
|`c.lower_bound(k)`|返回一个迭代器，指向第一个关键字不小于`k`的元素|
|`c.upper_bound(k)`|返回一个迭代器，指向第一个关键字不大于`k`的元素|
|`c.equal_range(k)`|返回一个迭代器`pair`，指向第一个关键字等于`k`的元素|

注意：
 
- 当我们遍历一个`multimap`或者`multiset`时，保证可以得到序列中所有具有给定关键字的元素。
- `lower_bound`返回的迭代器可能指向一个具有给定关键字的元素，但也可能不指向。如果关键字不在容器中，则`lower_bound`会返回关键字的第一个安全插入点--不影响容器中元素顺序的插入位置。
- 如果`lower_bound`和`upper_bound`返回相同的迭代器，则给定关键字不在容器中。

### 11.4 无序容器
无序关联容器总共有4个：`unordered_map`和`unordered_set`;

**桶管理**
无序容器在存储组织上为一组桶，每个桶保存0个或者多个元素。无序容器使用一个哈希函数将元素映射到桶。

**无序容器管理操作**

|操作|含义|
|:---|:---|
|**桶接口**|  |
|`c.bucket_count()`|正在使用的桶的数目|
|`c.max_bucket_count()`|容器能容纳的最多的桶的数量|
|`c.bucket_size(n)`|第n个桶中有多少个元素|
|`c.bucket(k)`|关键字为`k`的元素在那个桶中|
|**桶迭代**||
|`local_iterator`|可以用来访问桶中元素的迭代器类型|
|`const_local_iterator`|桶迭代器的`const`版本|
|`c.begin(n),c.end(n)`|与前两个函数类似，但返回`const_local_iterator`|
|**哈希策略**||
|`c.load_factor()`|每个桶的平均元素数量。返回`float`值|
|`c.max_load_factor()`|c维护桶的大小，返回`float`值。c会在需要时添加新的桶。以使得`load_factor<=max_load_factor`|
|`c.rehash(n)`|重组存储，使得`bucket_count>=n`且`bucket_count>size/max_load_factor`|
|`c.reserve(n)`|重组存储，使得c可以保存`n`个元素且不必`rehash`|

## 第 12 章 动态内存

### 12.1 动态内存与智能指针
在c++中动态内存管理是通过一对运算符来完成的：`new`和`delete`;同时为了更加安全的管理指针；标准库提供了两种 **智能指针** ：**shared_ptr**、**unique_ptr** ;前者允许多个指针指向同一个对象；后者独占所指对象。同时还有 **weak_ptr**的伴随类，他是一种弱引用，指向shared_ptr所管理的对象。三种类都定义在头文件memory中

当我们创建指针时，必须提供指针可以指向的类型。

```c++
shared_ptr<string> p1; //shared_ptr,可以指向string 

shared_ptr<list<int>> p2; //shared_ptr,可以指向int的list 
```

**shared_ptr和unique_ptr都支持的操作**

|操作|含义|
|:---|:---|
|`shared_ptr<T> sp unique_ptr<T> up`|空智能指针，可以指向类型为`T`的对象|
|`p`|将p用作一个条件判断，若`p`指向一个对象，则为`true`|
|`*p`|解引用p,获得它指向的对象|
|`p->mem`|等价于`(*p).mem`|
|`p.get()`|返回`p`中保存的指针，要小心使用；若智能指针释放了其对象，返回的指针所指向的对象也就消失了|
|`swap(p,q)/p.swap(q)`|交换`p`和`q`中的指针|

**share_ptr独有的操作**

|操作|含义|
|:---|:---|
|`make_shared<T>(args)`|返回一个`shared_ptr`,指向一个动态分配的类型为`T`的对象。使用`args`初始化此对象|
|`shared_ptr<T> p(q)`|p是`shared_ptr q`的拷贝；此操作会递增`q`中的计数器。`q`中的智能指针必须转化为`*T`|
|`p=q`|p和q都是`shared_ptr`，所保存的指针必须能够相互转换。此操作会递减`p`的引用计数，递增`q`的引用计数；若`p`的引用计数变为0，则将其管理的原内存释放|
|`p.unique()`|若`p.use_count()`为1，返回`true`;否则返回`false`|
|`p.use_count()`|返回与`p`共享对象的智能指针数量；可能很慢，主要用于调试|

注意：
- 我们通常使用`auto`作为`make_shared`指针函数所对应的值。
- 不要使用引用传递，在函数体内对智能指针`shared_ptr`进行赋值操作，计数会-1，离开函数作用域，局部变量销毁，计数可能为0.

计数递增情况：

- 一个`shared_ptr`初始化另外一个`shared_ptr`
- 作为参数传递给一个函数
- 作为函数的返回值

计数减少情况：

- `share_ptr`赋予一个新值
- `shared_ptr`被销毁--局部的`shared_ptr`离开其作用域。

注意：
- 如果将`shared_ptr`存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得`erase()`删除不再需要的那些元素。
- 使用动态内存的一个常见原因是允许多个对象，共享相同的状态。

#### 12.1.2 直接管理内存
c++可以使用`new`和`delete`直接管理内存；尽量在分配内存时，对动态分配内存的对象进行初始化操作。

```c++

int *p1=new int; //如果分配失败，new抛出std::bad_alloc;

int *p2=new (nothrow) int; //如果分配失败，new 返回一个空指针

delete p1,p2;
```
注意： 

- 我们传递给delete的指针必须指向动态分配的内存。或者是一个空指针。
- 不要随便删除一个空指针，可能在指针所指向的内存，被其它程序所使用，删除空指针，会造成极大的问题。
- 动态对象的生存周期是直到被释放为止。
- 由内置指针(而不是智能指针)管理的动态内存在被显式释放之前一直都会存在。
- 尽量坚持使用智能指针，防止内存分配错误
- 在删除指针之后使用`NULL/nullptr`使得指针悬空。
- 悬空只真对当前指针，对于和当前其它指向销毁内存对象的指针是没有作用的，尽量减少使用指针赋值和拷贝，或者直接使用shared_ptr智能指针。例如：

```c++
shared_ptr<int> p1=new int(1024); //错误；必须使用直接初始化形式。

shared_ptr<int> p2(new int(1024)); //正确：使用了直接初始化形式。

```

**定义和改变shared_ptr的其它方法**

|操作|含义|
|:---|:---|
|`shared_ptr<T> p(q)`|p管理内置指针q所指的对象；q必须指向`new`分配的内存，且能够转换为`T*`类型|
|`shared_ptr<T> p(u)`|p从unique_ptr u中接管了对象的所有权；将`u`置为空|
|`shared_ptr<T> p(q,d)`|p接管了内置指针q所指向的对象的所有权。q必须能转换为`T*`类型。p将使用可调用对象`d`来代替`delete`|
|`shared_ptr<T> p(p2,d)`|p是`shared_ptr p2`的拷贝,唯一的区别是`p`将使用可调用对象`d`来代替`delete`|
|`p.reset()`|若p是唯一指向其对象的`shared_ptr`，reset会释放此对象。|
|`p.reset(q)`|释放原有对象的同时，若传递了可选的内置参数指针`q`，会令`p`指向`q`，否则会将p置为空|
|`p.reset(q,d)`|若还传递了参数`d`,将会调用`d`而不是`delete`来释放`q`|

注意：

1. 不要混合使用普通指针和智能指针，很容易造成错误的析构
2. 不要使用get初始化另外一个智能指针或者为智能指针赋值，赋值给内置指针时，需要注意，不要让它管理的指针被释放。
3. 使用get返回指针的代码不能`delete`此指针。防止智能指针失效，成为野指针。
4. get用来将指针的访问权限传递给代码，只有确定代码不会delete指针的情况下，才能使用get。永远不要使用get初始化另外一个智能指针或者为另外一个智能指针赋值。
5. 智能指针指向新指针时，需要检查自己是否是当前对象仅有的用户。如果不是，在改变之前要制作一份新的拷贝。

```c++

if(!p.unique())
    p.reset(new string(*p)); //我们不是唯一的用户；分配新的拷贝

*p+=newVal; //可以改变对象的值

```
#### 12.1.4 智能指针和异常

注意，**智能指针陷阱**

基本规范：

- 不使用相同的内置指针值初始化(或reset)多个智能指针
- 不delete get()返回的指针
- 不使用 get()初始化reset另外一个指针
- 如果你使用get()返回的指针，记住，当最后一个指针对应的智能指针销毁后，你的指针就变为无效了
- 如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器。

#### 12.1.5 unique_ptr

**unique_ptr操作**

|操作|含义|
|:---|:---|
|`unique_ptr <T> u1`|空unique_ptr，可以指向类型为T的对象，u1会使用delete来释放它的指针|
|`unique_ptr <T,D> u2`|u2使用一个类型为D的可调用对象来释放它的指针|
|`unique_ptr <T,D> u(d)`|空unique_ptr，指向类型为T的对象，用类型为D的对象d代替delete|
|`u=nullptr`|释放u指向的对象，将u置为空|
|`u.release()`|u放弃对指针的控制权，返回指针，并将u置为空|
|`u.reset()`|释放u指针对象|
|`u.reset(q)/u.reset(nullptr)`|如果提供了内置指针q,令u指向这个对象；否则将`u`置为空|

unqiue_ptr不能共享所有权，但是可以将所有权，进行转移

```c++
//将所有权从一个unique_ptr转移给另一个unique

unique_ptr<string> p2(p1.release()); //release 将p1置为空

unique_ptr<string> p3(new string("Text"));
//将所有权从p3转移给p2

p2.reset(p3.release()); //reset释放了p2原来指向的内存

```

#### 12.1.6 weak_ptr

weak_ptr是一种不控制所指向兑现生存周期的智能指针，它指向一个由shared_ptr管理的对象。

**weak_ptr**

|操作|含义|
|:---|:---|
|`weak_ptr <T> w`|空`weak_ptr`可以指向类型为`T`的对象|
|`weak_ptr <T> w(sp)`|与`shared_ptr sp`指向相同对象的`weak_ptr`，T必须可以指向类型为`sp`的对象|
|`w=p`|p可以是一个`shared_ptr`或者一个`weak_ptr`。赋值后w与p共享对象|
|`w.reset()`|将w置为空|
|`w.use_count()`|与w共享对象的`shared_ptr`的数量|
|`w.expired()`|若`w.use_count()`为0，返回true，否则返回`false`|
|`w.lock()`|如果`expired`为`true`，返回一个空`shared_ptr`；否则返回一个指向`w`的对象的`shared_ptr`|

我们创建一个`weak_ptr`时，要用一个`shared_ptr`来初始化它：

```c++
auto p=make_shared<int>(42);

weak_ptr<int> wp(p);//wp 弱共享p;p的引用计数未改变，因此使用时必须使用函数lock()

if(shared_ptr<int> np=wp.lock()){//如果np不空则条件成立
    
    //在if中，np与p共享对象
}
```
### 12.2 动态数组

数组主要是为了更好的快速分配内存；大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且拥有更好的性能。

注意：

- 分配数组，会得到一个元素类型的指针。
- 动态分配一个空数组是合法的。
- 释放动态数组使用`delete []`,数组中的元素按逆序销毁。
- 数组指针需要使用`delete []`,单个对象需要使用`delete`,换用的行为都是未定义的。
- 未使用匹配的delete时，编译器很可能不会给出警告。程序可能在执行过程中没有任何警告的情况下行为异常。

初始化动态分配对象的数组

```c++
int *pia=new int[10]; //10个没有初始化的int

int *pia2=new int[10](); //10个初始化为0的int

string *psa=new string[10]; //10个空string

string *psa2=new string[10](); //10个空string

string *psa3=new string[10]{"a","an","the",sting(3,'x')}; //10个string初始化

```

**指针和动态数组**
```c++
unique_ptr<int []> up(new int[10]); //up指向10个未初始化int的数组

up.release(); //自动调用delete销毁其指针。
```

#### 12.2.2 allocator类

通常因为指针数组的定额分配可能产生内存浪费，因此需要`allocator`来进行内存分配。类似vector，allocator是一个模板，为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。当一个allocator对象分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位置：

```c++
allocator<string > alloc; //可以分配stringd allocator对象

auto const p=alloc.allocate(n); //分配n个未初始化的string
```
**标准库allocator类及其算法**

|算法|解释|
|:---|:---|
|`allocator <T> a`|定义了一个名为`a`的`allocator`对象，他可以为类型T的对象分配内存|
|`a.allocate(n)`|分配一段原始的、未构造的内存，保存n个类型为`T`的对象|
|`a.deallocate(n)`|释放从`T*`指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由`allocator`返回的指针，且n必须是p创建时所要求的大小。调用`dealocator`之前，用户必须对每个在这块内存中创建的对象调用`destroy`|
|`a.construct(p,args)`|p必须是一个类型为`T*`的指针，指向一块原始内存；arg被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象|
|`a.destroy(p)`|p为`T*`类型的指针，此算法对p指向的对象执行析构函数|

注意：

- allocator分配的内存时未构造函数的。我们按照需要在此内存中构造对象。
- 为了使用allocator返回的内存，我们必须使用construct构造对象。未使用构造的内存，其行为是未定义的。
- 我们只能对真正构造了的元素进行destory操作。

```c++
auto q=p;  // q指向最后构造的元素之后的位置

alloc.construct(q++);  //*q为空字符串

alloc.construct(q++,10,'c'); // *q为cccccccccc

std::cout<<*p<<endl; //正确：使用string 的输出运算符

cout<<*q<<endl;  // 灾难： q指向未构造的内存。

//使用完成必须对每个构造的元素调用destory来销毁它们

while (q!=p)
    alloc.destory(--q);  //释放我们真正构造的string，此时元素被销毁，可以重新使用这部分内存来保存其它string

alloc.deallocate(p,n);  //释放内存操作

```
**allocator 算法**

|算法|含义|
|:---|:---|
|`uninitialized_copy(b,e,b2)`|将迭代器b和e之间的输入，拷贝到迭代器b2指定的未构造的原始内存中，b2指向的内存必须足够大，能够容纳输入序列中元素的拷贝|
|`uninitialized_copy_n(b,n,b2)`|同上，从b开始拷贝n个元素到b2|
|`uninitialized_fill(b,e,t)`|在迭代器b和e指定的原始内存范围中创建对象，对象的值，均为t的拷贝|
|`uninitialized_fill_n(b,n,t)`|从b指向的内存地址开始创建n个对象，b必须指向足够大的内存|

使用示例：
```c++
//分配比vi中元素所占用空间大一倍的动态内存

auto p=alloc.allocate(vi.size()*2);
//通过拷贝vi中的元素来构造从p中开始的元素

auto q=uninitialized_copy(vi.begin(),vi.end(),p);
//将剩余元素初始值为42
uninitialized_fill_n(q,vi.size(),42);

```

# 第III 部分类设计者的工具

##第13 章拷贝控制
类的五种特殊成员函数:

- 拷贝构造函数
- 拷贝赋值构造函数
- 移动构造函数
- 移动赋值运算符
- 析构函数

注意：定义任何C++类的时候，拷贝控制操作都是必要部分。即使我们不显示定义这些操作，编译器也会为我们定义，但是编译器定义的版本的行为可能并非我们所想象。

### 13.1 拷贝、赋值与销毁

**合成拷贝构造函数**：用来阻止我们拷贝该类类型的对象。一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器给定对象中依次将每个非static成员拷贝到正在创建的对象中。

拷贝初始化发生情况：

- 使用`=`定义变量时会发生
- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用`{}`列表初始化一个数组中的元素或者一个聚合类中的成员
- 接收参数的构造函数，一般是explicit的
- 编译器可以绕过拷贝构造函数

```c++
vector<int> v1(10); //正确：直接初始化

vector<int> v2=10; //错误：接受大小参数的构造函数时explicit的

void f(vector<int>); //f的参数进行拷贝初始化

f(10); //错误；不能用一个explicit的构造函数拷贝一个实参

f(vector<int>(10));正确：从一个int直接构造一个临时的vector

string null_book="9-99-99";//拷贝初始化

string null_book("9-99-99"); //编译器略过了拷贝构造函数
//重载赋值运算符

class Foo{
public:
    Foo& operator=(const Foo&); //赋值运算符
    ...
}

Foo& Foo::operator=(const Sales_data &rhs){
    bookNo=rhs.bookNo;  //调用 string::opeator=

    units_sold=rhs.units_sold; //使用内置的int赋值

    ...
    return *this;
}
```
赋值运算符通常应该返回一个指向其左侧运算对象的引用

如果类没有定义自己的拷贝赋值运算符，编译器会为它生成一个 **合成拷贝赋值运算符**

析构函数调用情况

- 变量在理考作用域时被销毁
- 一个对象在被销毁时，其成员被销毁
- 容器(无论是标准库容器还是数组) 被销毁时，其元素被销毁
- 对于动态分配的对象，当对指向它的指针应用delete运算符进行销毁
- 临时对象，当创建它的完整表达式结束时被销毁。

注意：

- 析构函数调用时，先调用父类，再调用子类；与构造函数正好相反。
- 当指向一个对象的引用或者指针离开作用域时，析构函数不会执行。
- delete 删除指针，是删除指针指向的那块内存，指针本身仍旧存在，因此需要，键指针指向NULL防止错误

**三/五法则**
三个基本操作可以控制类的拷贝操作：

- 拷贝构造函数
- 拷贝赋值运算符
- 析构函数
- 如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数；反之亦然。
- 可以通过使用`=default`来显示地要求编译器生成合成的版本(默认构造函数)。
- 可以使用`=delete`来阻止默认的拷贝个赋值函数。
- 将拷贝和赋值拷贝设为私有函数，将使得用户代码不能拷贝这个类型的函数，用户代码在编译时错误，成员函数或者有元函数在连接诶时错误。
- 希望阻止拷贝的类应该使用`=delete`来定义他们自己的拷贝构造函数和拷贝赋值运算符，而不应该将他们声明为`private`的。

```c++
HasPtr HasPtr::operator=(const HasPtr &rhs)
{
    auto newp=new string(*rhs.ps) ;// 拷贝底层string

    delete ps; //释放旧内存

    ps=newp; //从右侧运算对象拷贝数据到本对象

    i=rhs.i;
    return this; //返回对象本身

}
```
当编写一个赋值运算符的时候，最好先将右侧运算对象拷贝到一个局部临时对象。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。

拷贝赋值运算符通常执行拷贝构造函数和析构函数也要做的工作，公共的工作应该放在`private`的工具函数中。

### 13.5 动态内存管理

简单标准库vector类的简化实现版本。

```c++
//stdvec.h
//类vector类内存分配策略的简化实现

class StrVec{
public:
    StrVec():
        elements(nullptr),first_free(nullptr),cap(nullptr){}
    StrVec(const StrVec&); //拷贝构造函数

    StrVec &operator=(const StrVec&); //拷贝赋值运算符

    ~StrVec();  //析构函数

    void push_back(const std::string&);  //拷贝元素

    size_t size() const {return first_free-elements;}
    size_t capacity() const {return cap-elements;}
    std::string *begin() const {return elements;}
    std::string *end() const {return first_free;}
    // ...
private:
    Static std::allocator<std::string> alloc; //分配元素
    //被添加元素的函数所使用
    
    void chk_n_alloc() {if(size()==capacity()) reallocate();}
    //工具函数，被拷贝构造函数、赋值运算符和析构函数所使用
    
    std::pair<std::string*,std::string*> alloc_n_copy(const std::string*,const std::string*);
    void free();  //销毁元素并释放内存

    void reallocate();  //获得更多内存并拷贝已有元素

    std::string *elemets;  //指向数组首元素的指针

    std::string *frist_free; //指向数组第一个空闲元素的指针

    std::string *cap; // 指向数组尾后位置的指针

};

//strvec.cpp

void Strvec::push_back(const string& s)
{
    chk_n_alloc();  //确保有空间容纳新元素

    //在frist_free指向的元素中构造s的副本
    
    alloc.construct(first_free++,s);
};

std::pair<std::string*,std::string*> alloc_n_copy(const std::string* b,const std::string* e)
{
    //分配空间保存给定范围中的元素
    
    auto data=alloc.allocate(e-b);
    //初始化并返回一个pair,该pair由data和uninitialized_copy的返回值构成
    
    return {data.uninitialized_copy(b,e,data)};
}

void StrVec::free()
{
    //不能传递给deallocate 一个空指针，如果elements为0，函数什么也不做
    
    if(elements){
        //逆序销毁旧元素
        
        for(auto p=first_free;p!=elements;)
        {
            alloc.destory(--p);
            alloc.deallocate(elements,cap-elements);
        }
    }
}

StrVec::StrVec(const StrVec &s)
{
    //调用alloc_n_copy 分配内存空间以容纳与s中一样多的元素
    
    auto newdata=alloc_n_copy(s.begin(),s.end());
    elements=newdata.frist;
    frist_free=cap=newdata.second;
}

StrVec::~StrVec(){free();}

StVec &StrVec::operator=(const StrVec &rhs)
{
    //调用alloc_n_copy 分配内存，大小与rhs中元素占用空间一样多
    
    auto data=alloc_n_copy(rhs.begin(),rhs.end());
    free();
    elements=data.first;
    frist_free=cap=data.second;
    return *this;
}

void StrVec::reallocate()
{
    //我们将分配当前大小两倍的内存空间
    
    auto newcapacity=size()?2*size():1;
    //分配新内存
    
    auto newdata=alloc.allocate(newcapacity);
    //将数据从旧内存移动到新内存
    auto dest=newdata;  //指向新数组中下一个空闲位置

    auto elem=elements; //指向旧数组中下一个元素

    for(size_t i=0;i!=size();++i)
    {
        alloc.construct(dust++,std::move(*elem++));
    }
    free(); //一旦我们移动完成元素就释放旧内存空间

    //更新我们的数据结构，执行新元素
    elements=newdata;
    first_free=dest;
    cap=element+newcapacity;

}
```

### 13.6 对象移动

注意：标准容器库、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。

使用`&&`来进行右值引用。右值引用--只能绑定到一个将要销毁的对象。**左值持久；右值短暂**。右值引用只能绑定到临时对象。

对于右值有：

- 所引用的对象，将要被销毁
- 该对象没有其他用户
- 使用右值引用的代码可以自由地接管所引用的对象的资源
- 变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型。
- 可以销毁一个移后对象，也可以赋予它新值，但不能够使用一个移后源对象的值。

使用move来获得绑定到左值上的右值引用`int &&rr3=std::move(rr1);`

注意：

- 不抛出异常的移动构造函数和移动赋值运算符必须标记为`noexcept`。
- 只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或者移动赋值时，编译器才会为它合成移动构造函数或者移动赋值运算符。
- 定义了一个移动构造函数或者移动赋值运算符符类，必须也定义自己的拷贝构造操作。否则，这些成员默认地被定义为删除的。
- 如果一个类有一个可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来“移动”的。拷贝赋值运算符和移动赋值运算符的情况类似。
- 移动赋值函数，相对拷贝构造函数，更减少资源的使用。
- 对象移动数据并不会销毁此对象，但有时在移动完之后，源对象会被销毁。编写移动操作时，必须保证源对象可以析构。
- 一个类集邮移动构造，又有拷贝构造，则移动是右值，拷贝是左值。
- 没有移动构造函数，右值也会被拷贝。但是编译器不会合成移动构造函数。即便是使用std::move也是调用的拷贝构造函数。
- 不要随意使用移动操作，一个移动源对象具有不确定的状态。当我们使用`move`时，必须绝对确认移后源对象没有其它用户。
- 移动接收`T&&`,拷贝接收`T&`

**左值和右值引用成员函数**
c++中允许右值进行赋值例如：

```c++
auto s1="hello";
auto s2="word";
s1+s2="wow!";
```
为了阻止这种情况的发生，使用 **引用限定符**：`&` 来强制指定左侧运算对象(即，this指向的对象)是一个左值。或者使用`&&`，强制指明，左侧运算对象是一个右值，例如：

```c++
class Foo{
public:
    Foo &operator=(const Foo&) &; //只能向可修改的左值赋值

}

class Foo{
public:
    Foo someMem() & const; //错误限定符const 必须在前
    
    Foo anotherMem() const &; //正确
}

Foo &retFoo();  //返回一个引用；retFoo调用时一个左值

Foo retVal();  // 返回一个值；retVal调用时一个右值

Foo i,j; //i,j均是左值

i=j; //正确：i是左值

retFoo()=j ;// 正确:retFoo()返回一个左值

retVal()=j; //错误:retVal()返回一个右值

i=retVal();  //正确：我们将一个右值作为赋值操作的右侧运算对象

//成员函数可以根据const区分其重载版本，引用也可以区分重载版本

class Foo{
public:
    Foo sorted() &&;  //可用于可改变的右值

    Foo sorted() const &; //可用于任何类型的Foo
}

//本对象为右值，因此可以原址排序

Foo Foo::sorted() &&
{
    sort(data.begin(),data.end());
    return *this;
}

//本对象是const或者是一个左值，不论何种情况我们都不能对其进行原址排序

Foo Foo::sorted() const & {
    Foo ret(*this);  //拷贝一个副本

    sort(ret.data.begin(),ret.data.end());  //排序副本

    return ret;  //返回副本

}

//这里编译器会根据sorted 的对象的左值/右值属性来确定使用那个sorted版本


```
注意： 如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。

## 第14 章 重载运算符与类型转换

重载的运算符是具有特殊名字的函数；他们的名字由关键字，operator和其后要定义的运算符共同组成。
注意：
- 一个类成员运算符函数，第一个运算对象绑定到隐式的`this`指针上。因此成员函数运算符函数的显示参数数量比运算符的运算对象，总少一个。
- 我们无法改版内置类型的运算符含义。
- 我们只能重载已有的运算符，而无权发明新的运算符号。例如我们不能提供operator**来执行幂操作。

**可重载运算符**

|运算符类型|运算符种类|
|:--|:---|
|双目算术运算符| `+ (加)，-(减)，*(乘)，/(除)，% (取模)`|
|关系运算符  | `==(等于)，!= (不等于)，< (小于)，> (大于>，<=(小于等于)，>=(大于等于)`|
|逻辑运算符  | `//(逻辑或)，&&(逻辑与)，!(逻辑非)`|
|单目运算符  | `+ (正)，-(负)，*(指针)，&(取地址)`|
|自增自减运算符 | `++(自增)，--(自减)`|
|位运算符 |   `/ (按位或)，& (按位与)，~(按位取反)，^(按位异或),，<< (左移)，>>(右移)`|
|赋值运算符  | `=, +=, -=, *=, /= , % = , &=, /(其实是竖着的)=, ^=, <<=, >>=`|
|空间申请与释放| `new, delete, new[ ] , delete[]`|
|其他运算符 |  `()(函数调用)，->(成员访问)，,(逗号)，[](下标)`|

**不可重载的运算符列表**

|运算符|含义|
|:---|:---|
|`.`|成员访问运算符|
|`.*, ->*`|成员指针访问运算符|
|`::`|域运算符|
|`sizeof`|长度运算符|
|`?:`|条件运算符|
|`#`| 预处理符号|

注意：

1. 运算重载符不可以改变语法结构。
2. 运算重载符不可以改变操作数的个数。
3. 运算重载符不可以改变优先级。
4. 运算重载符不可以改变结合性。

**类重载、覆盖、重定义之间的区别：**

重载指的是函数具有的不同的参数列表，而函数名相同的函数。重载要求参数列表必须不同，比如参数的类型不同、参数的个数不同、参数的顺序不同。如果仅仅是函数的返回值不同是没办法重载的，因为重载要求参数列表必须不同（发生在同一个类里）。

覆盖是存在类中，子类重写从基类继承过来的函数。被重写的函数不能是static的。必须是virtual的。但是函数名、返回值、参数列表都必须和基类相同（发生在基类和子类）

重定义也叫做隐藏，子类重新定义父类中有相同名称的非虚函数 ( 参数列表可以不同 ) （发生在基类和子类）。

操作符的等价调用：
```c++
data1+data2; //普通的表达式

operator+(data1,data2); //等价的函数调用

data1.operator+=(data2); //等价的函数调用

```

注意：尽量明智地使用运算符重载。只有当操作的含义对于用户磊说清晰明了时才能使用运算符。当其存在二意性时，最好不要使用。

### 14.2 输入和输出运算符

输出`<<`重载示例:

```c++
ostream &operator<<(ostream &os,const Sales_data &item)
{
    os<<item.isbn()<<" "<<item.units_sold<<""
    <<item.revenue<<" "<<item.avg_price();

    return os;
}
```
注意： 
- 输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。
- 输入输出运算符必须是非成员函数，不能是类的成员函数。否则，他们左侧运算对象将是我们的类的一个对象。

输入`>>`重载示例：

```c++
istream &opertaor>>(istream &is,Sales_data &item)
{
    double price;// 不需要初始化，因为我们将先读入数据到`price`,之后才使用它

    is>>item.bookNo>>iten.units_sold>>price;
    //检查输入是否成功

    if(is)
    {
        item.revenue=item.units_sold*price;
    }else{
        item=Sales_data(); //输入失败：对象呗赋予默认的状态

    }
    return is;


}
```
注意：

1. 当流含有错误类型的数据时，读取操作可能失败。之后的其他使用都将失败
2. 当读取操作达到文件末尾或者遇到输入流的其它错误时，也会失败
3. 当读取操作发生错误时，输入运算符应该负责从错误中恢复。

### 14.3 算术和关系运算符

注意：

- 如果同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。
- 如果某个类在逻辑上有相等性的含义，则该类应该定义`operator==`。
- 如果存在唯一一种可靠的`<`定义，则应该考虑为这个类定义`<`运算符。如果类同时还包含`==`，则当且仅当`<`的定义和`==`产生的结果一致时才睡定义`<`运算符。
- 重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。
- 赋值运算符必须定义为类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。

使用示例：

```c++
//重载赋值运算符
StrVec &StrVec::operator=(initializer_list<string> il)
{
    //alloc_copy分配内存空间，并从给定安慰内拷贝元素
    
    auto data=alloc_n_copy(il.begin(),il.end());
    free();  // 销毁对象中的元素并释放内存空间

    elements=data.frist;//更新数据成员，使其指向新空间

    first_free=cap=data.second; 
    return *this;  

} 

//重载复合赋值运算符

StrVec &StrVec::operator+=(initializer_list<string> il)
{
    unit_sold+=rhs.units_sold;
    revenue+=rhs.revenue;
    return *this;
}
```
### 14.5 下标运算符 `operator [] `
注意：

-  下标运算符必须是成员函数。
-  如果一个类包含下标运算符，则它通常会定义两个版本；一个返回普通引用，一个是类的常量成员并且返回常量引用。

使用示例:

```c++
class StrVec{
public:
    std::string& operator [](std::size_t n){return elements[n];}

    const std::string& operator[] (std::size_t n) const
    { return element[n];}

private:
    std::string *elements;  //指向数组首元素的指针
}

const StrVec cvec=svec;  //把svec的元素拷贝到cvec中

//如果svec中含有元素，对第一个元素运行string的empty函数

if(svec.size()&&svec[0].empty){
    svec[0]="zero";  //正确：下标运算符返回string的引用

    svec[0]="Zip";  //错误；对cvec取下标返回的是常量引用
}
```

### 14.6 递增和递减运算符

注意：

- 定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类的成员。
- 为了与内置版本保持一致，前置运算符应该返回递增或者递减后对象的引用。
- 为了与内置版本保持一致，后置运算符应该返回对象的原值(递增或者递减之前的值)，返回的形式是一个值而非引用。
- 因为我们不会用到`int`形参，所以无需为其命名。

```c++
//前置版本：返回递增/递减对象的引用

StrBlobPtr& StrBlobPtr::operator++()
{
    //如果curr已经指向了容器的尾后位置，则无法递增它
    
    check(curr,"xxxx");
    ++curr;  //将curr在当前状态下向前移动一个元素

    return *this;
} 

//后置版本:递增/递减对象的值，但是返回原值
StrBlobPtr StrBlobPtr::operator++(int)
{
    //此处无需检查有效性，调用前置递增运算时才需要检查
    
    StrBlobPtr ret=*this;  //记录当前的值

    ++*this   //向前移动一个元素，前置++需要检查递增的有效性

    return ret;  //返回之前记录的状态

}

```
**C++中 i++ 与++i 的区别**

- i++ 是指先使用i，只用之后再讲i的值加一，
- ++i 是将i的值先加一，然后在使用i；

如果i是一个整型变量那么i++ 与++i 几乎是没有区别的，在学习C++的后面会有迭代器，迭代器是一个对象，当i是迭代器时，那么++i的效率运行速度就比i++快；所以我们在一般的for循环语句中当i++与++i都可以使用时，可以考虑使用++i，养成一种良好的风格。

### 14.7 成员访问运算符

成员访问运算符，在 迭代器及智能指针类中常常见到解引用运算符`*`和箭头运算符`->`。我们以如下形式向`StrBlobPtr`类添加这两种运算符：

```c++
class StrBlobPtr{
public:
    std::string& operator*() const
    {
        auto p=check(curr,"dereference past end");
        return (*p)[curr];  //(*p)是对象所指的vector

    }
    std::string* operator->() const
    {
        //将实际工作委托给解引用运算符
        return& this->operator*();
    }
    //将两个运算符定义成了const成员，这是因为与递增和递减预算符不一样，获取一个元素并不会改变StrBlobPtr对象的状态
}
```
注意：

- 箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。
- 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象

### 14.8 函数调用运算符
如果类重载了函数调用运算符，则我们可以像使用函数一样灵活使用该类的对象。因为这样的类同时也能存储状态，所以与普通函数相比它们更加灵活。例如：

```c++
strcut absInt{
    int operator()(int val) const
    {
        return val<0?-val:val;
    }
};

//使用

int i=-42; 
absInt absObj;  // 含有函数调用运算符符对象

int ui=absObj(i);  //将i传递给absObj.operator()
```

注意：
- 函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或者类型上有所区别。
- 如果类定义了调用运算符，则该类的对象称作 **函数对象**。因为可以调用这种对象，所以我们说这些对象的“行为就像函数一样”。
- lambda是就是一个典型的函数对象。但是lambda表达式的类不含默认构造函数、赋值运算符及默认析构函数；它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定。
- 对于比较两个无关指针的内存地址，将产生未定义的行为，标准函数库提供了相关函数兑现进行定义。

**标准库函数对象**

|算术|关系|逻辑|
|:---|:---|:---|
|`plus<Type>`|`equal_to<Type>`|`logical_and<Type>`|
|`minus<Type>`|`not_equal_to<Type>`|`logical_or<Type>`|
|`multiplies<Type>`|`greater<Type>`|`logical_not<Type>`|
|`divides<Type>`|`greater_equal<Type>`||
|`modulus<Type>`|`less<Type>`||
|`negate<Type>`|`less_equal<Type>`||

```c++
vector<string  *> nameTable; //指针的vector
//错误会产生未定义的行为

sort(nameTable.begin(),nameTable.end(),[](string *a,string *b){return a<b;});
//正确：标准库规定指针的less是定义良好的

sort(nameTable.begin(),nameTable.end(),less<string *>());

```

**可调用对象与function**
c++中的可调用对象：

- 函数
- 函数指针
- lambda表达式
- bind创建的对象
- 重载了函数调用运算符的类

对于相似操作但是输入参数不同的情况，我们可以使用一个名为`function`的新标准库类型解决上述问题,`function`定义在`functional`头文件中。

**function的操作**

|操作|含义|
|:---|:---|
|`function<T> f`|f是一个用来存储可调用对象的空`function`,这些课调用对象的调用形式应该与`T`相同|
|`function<T> f(nullptr)`|显示构造一个空`function`|
|`function<T> f(obj)`|在f中存储可调用对象`obj`的副本|
|` f`|将f作为条件:当f含有一个可调用对象时为真；否则为假|
|`f(args)`|调用f中的对象，参数时`args`|

**定义为function<T>的成员类型**
|类型|含义|
|:---|:---|
|`result_type`|该function类型的可调用对象返回的类型|
|`argument_type`|当T有一个或者两个实参时定义的类型。T只有一个实参|
|`frist_argument_type`|当T有一个或者两个实参时定义的类型。T只有两个实参,第一个参数|
|`second_argument_type`|当T有一个或者两个实参时定义的类型。T只有一个实参,第二个参数|

使用示例：

```c++
function<int(int,int)> f1=add;  //函数指针

function<int(int,int)> f2=divide();  //函数对象类的指针

function<int(int,int)> f3=[](int i,int l){return i*j;};  //函数指针

cout<<f1(4,2)<<endl;  //打印

cout<<f2(4,2)<<endl;  //打印

cout<<f3(4,2)<<endl;  //打印8

//使用map映射

map<string,function<int(int,int)> > binops={
    {"+",add},  //函数指针

    {"-",std::minus<int>()},  //标准库函数对象

    {"/",divide()},  // 用户定义的函数对象

    {"*",[](int i,int j){return i*j;}},  //未命名的lambda

    {"%",mod} //已命名的lambda对象
};
```
注意：
新版本标准库中的`function`类与旧版本中的`unary_function`和`binary_function`没有关联，后两个类已经被更加通用的`bind`函数代替了。

### 14.9 重载、类型转换和运算符

**类类型转换：** 将实参类型对象隐式转换为类类型，转换构造函数和类型转换运算符共同定义类类型转换，也称作 **用户定义的类类型转换**。

例如：`double b=3.141516;int a=(int)b;`

**类型转换运算符：** 将一个类类型的值转换成其它类型。一般形式如下:
`operator type() const`


注意：

- 一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参类表也必须为空。类型转换函数通常应该是`const`。
- 类型转换运算符可能产生意外结果，例如bool类型转换，能被隐式地转换为int类型输出。
- 为了防止上一条情况发撒恒，c++11定义了显示的类型转换运算符；例如：

```c++
class SmallInt{
public:
    //编译器不会自动执行这一类型转换

    explicit operator int() const {return val;}
}
//显式地请求类型转换

SmallInt si=3;
static_cast<int>(si)+3;
```
- 向bool的类型转换通常用在条件部分，因此`operator bool`一般定义成`explicit`的。
- 通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或者转换目标是算术类型的转换。
- 当我们使用两个用户定义的类型转换时，如果转换函数之前或者之后存在标准类型转换，则标准类型转换将决定最佳匹配到底是哪个
- 除了显式向bool类型的转换为，应该尽量避免定义类型转换函数并尽可能地限制“显然正确”的非显式构造函数。
- 如果在调用重载函数时，需要构造函数或者强制类型转换来改变实参类型，则这通常意味着程序设计存在不足。
- 在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型不止一个，则该调用具有二义性。

#### 14.9.3 函数匹配与重载运算符

注意：

- 表达式中运算符的候选函数集即应该包括成员函数，也应该包括非成员函数。
- 如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到运算符与内置运算符符二义性问题。

例如：
```c++
class SmallInt{
    friend SmallInt operator+ (const SmallInt&,const SmallInt&);
public:
    SmallInt(int =0);  // 转换源为int的类型转换

    operator int() const {return val;} //转换目标为int的类型转换

private:
    std::size_t val;
};

SmallInt s1,s2;
SmallInt s3=s1+s2;   //使用重载的operator+

int i=s3+0;  //二义性错误

```

## 第15章 面向对象程序设计

### 15.1 oop:概述
面向对象程序设计的核心思想是数据抽象、继承和动态绑定。

**虚函数：** 基类希望它的派生类各自定义适合自身版本，将这些函数声明为**虚函数**；派生类必须通过派生类列表明确指明他是从那个基类继承而来的。即 **基类希望派生类能进行覆盖的函数**

**动态绑定**
通过**动态绑定**，我们能用同一段代码分别处理不同的对象。相同函数，根据动态绑定的对象实质进行区别。在运行时选择函数的版本，所以动态绑定有时又被称为 **运行时绑定**

注意：

- 在c++语言中，当我们使用基类的引用(或者指针)调用一个虚函数时将发生动态绑定。

### 15.2 定义基类和派生类

注意：

- 基类同城都应该定义一个虚析构函数，计时该函数不执行任何实际操作也是如此。
- 如果一个派生类没有覆盖其基类中的某个虚函数，则该函数的行为类似于其他成员，派生类会直接继承其在基类中的版本。
- 同一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的。

```c++
class Quote{
public:
    Quote()=default;
    Quote(const std::string &book,double sales_price):bookNo(book),price(sales_price){}
    std::string isbn() const {return bookNo;}
    //返回给定数量的书籍的销售总额
    
    //派生类负责改写并使用不同的折扣计算算法
    
    virtual double net_price(std::size_t n) const
    {return n*price;}

    virtual ~Quote()=default; //对析构函数进行动态绑定
private:
    std::string bookNo;  //书籍编号

protected:
    double price=0.0   //普通状态下不打折扣的价格 

}

```

可以将派生类的对象当成基类来使用，而且也能将基类的指针或者引用绑定到派生类对象中的基类部分上。

```c++
Quote item;  //基类对象

Bulk_quote bulk;  //派生类对象

Quote *p=&item;  //p指向Quote对象

p=&bulk; //p指向bulk的Quote的部分

Quote &r=bulk;  //r绑定到bulk的Quote部分

```
上述转换可以把派生类对象的指针用在需要基类指针的地方。
注意：

- 在派生类对象中含有与基类对应的组成部分，这一事实是继承的关键。
- 派生类不能直接初始化继承的基类成员，必须使用基类的构造函数来初始化它的基类部分；每个类控制它自己的成员初始化过程。
- 除非我们特别指出，否则派生类的基类部分会像数据成员一样执行默认初始化。如果需要使用基类的构造函数需要，使用`基类名(参数1，参数2)` 的形式进行显式调用。否则进行一般空参数的默认初始化。
- 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。
-  **c++中类，是在实例化时才会查找相关代码，没有使用就不会生成对应代码，函数无论使用都会生成。**
-  类会自动生成一个`namespace`,其中的静态成员和静态变量，相当于`namespace`中的变量和函数。
-  如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。
-  如果我们想要某个类用作基类，则该类函数必须已经定义而非仅仅声明。主要是构造函数和成员变量必须定义，因为子类的构造函数必须使用父类的构造函数。
-  在类后面添加关键字`final`可以有效防止类被继承。
-  和内置指针一样，智能指针类也支持派生类向基类的类型转换，意味着我们可以将一个派生类对象的指针存储在一个基类指针的只能指针内。

**基类和派生类**

不存在基类向派生类的隐式类型转换，但是当编译器无法确定某个特定的转换在运行时是否安全的时候，则可以，但这是很危险的，并且基类函数的析构函数最好是虚析构函数。([C++中虚析构函数的作用](https://www.cnblogs.com/lit10050528/p/3874703.html))

```c++
Bulk_quote bulk;
Quote *itemP=&bulk;  //正确；动态类型是Bulk_quote

Bulk_quote *bulkP=itemP;  //错误，不能将基类转换成派生类

```

派生类向基类的自动类型转换，支队指针或者引用类型有效，在派生类类型和基类类型之间不存在这样的转换。

当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。

存在继承关系的类型之间的转换规则

- 从派生类向基类的类型转换只对指针或引用类型有效
- 基类向派生类不存在隐式类型转换
- 和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。

### 15.3 虚函数

**虚函数的调用可能在运行时才被解析**

注意：

- 一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。
- 一个派生类的函数如果覆盖了继承来的虚函数，则它的形参类型必须被它覆盖的基类函数完全一致;返回类型也必须相同。形参列表不同时会产生新的函数，继承的基类函数仍旧有效。
- 使用`override`关键字可以明确重载，原函数中没有函数，或者参数不对应则都会产生错误。
- 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。

**回避虚函数的机制**

可以使用作用域运算符，实现虚函数的强行绑定，而非动态绑定；例如：

```c++
double undiscounted=baseP->Quote::net_price(42);
//强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么

```

通常情况下，只有成员函数(或者友元)中的代码才需要使用作用域运算符来回避虚函数的机制。通常是一个派生类的虚函数调用它覆盖的基类的虚函数版本时。

注意：如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。

### 15.4 抽象基类

含有纯虚函数的类是抽象基类；不能创建抽象基类的对象，只能被继承

重构：负责重新设计类的体系以便将操作或数据从一个类移动到另外一个类中。

### 15.5 访问控制与继承

protect:希望派生类分享但是不想被其他公共访问使用的成员。

- 受保护的成员对于类的用户来说是不可访问的。
- 受保护的成员，对于派生类的成员和友元来说是可以访问的
- 派生类或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类的受保护成员没有任何访问特权。

```c++
class Base{
protected:
    int prot_mem;  //protected 成员

};
class Sneaky:public Base{
    friend void clobber(Sneaky&);  //能访问Sneaky::prot_mem

    friend void clobber(Base&);  //不能访问Base::prot_mem

    int j;  
}
void clobber(Sneaky& s) {s.j=s.prot_mem=0;} //正确能访问Sneaky对象的private和protected成员

void clobber(Base& b){b.prot_mem=0;}//错误不能访问protected的成员

```
private 不影响派生类的访问权限，主要影响，相关函数的使用。

**派生类向基类转换的可访问性**

- 只有当D公有地继承B时，用户代码才能够使用派生类向基类的转换；如果D继承B的方式是保护的或者私有的，则用户代码不能使用该转换。
- 不论D以什么方式继承B,D的成员函数和友元都能使用派生类向基类的的转换；派生类向其会直接基类的类型转换对于派生类的成员和友元来说是永远可以访问的。
- 如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换；反之，如果D继承B的方式是私有的，则不能使用
- 对于代码中的某个给定节点来说，如果基类的公有成员是可以访问的，则派生类向基类的类型转换也是可访问的；反之则不行。

**友元与继承**

友元关系不能继承，友元关系也不能传递，基类的友元在访问派生类成员时，不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。-- **不能继承友元关系，每个类负责控制各自成员的访问权限**

**改变个别成员的可访问性**

通过`using`声明可以改变派生类继承的某个名字的访问级别。

```c++
class Base{
public:
    std::size_t size() const {return n;}
protected:
    std::size_t;
};

class Derived: private Base{
public:
    using Base::size;  //保持对象尺寸相关的成员的访问级别

protected:
    using Base::n; //使用using关键字改变成员变量的访问级别。

};

```

- `private using` 该名字能被类的成员和友元访问；
- `public using` 类的所有成员都能访问。
- `protectde using` 类的成员、友元和派生类是可访问的。

### 15.6 继承中的类作用域

每个类定义自己的作用域，；当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。如果一个名字在派生类的作用域内无法正常解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。例如：

```c++
Bulk_quote bulk;
cout<<bulk.isbn();

//查找步骤：先找自身作用域内函数，再找父类，和父类的父类

```
静态类型：在编译时总是已知的，它是变量声明时的类型或表达式生成的类型
动态类型：变量或表达式表示的内存中的对象的类型。

注意：

- 派生类的成员将隐藏同名的基类成员
- 可用通过作用域运算符来使用一个呗隐藏的基类成员
```c++
struct Derived:Base{
    int get_base_mem(){
        return Base::mem;
    }
}

```

- 除了覆盖继承而来的虚函数之外，派生类最好不要中庸其它定义在基类中的名字。

**关键概念:名字夜找与继承**

------

理解函数调用的解析过程刘一于理解C++的继承至关重要，假定我们调用`p->mem()`(或者obj.mem())，则依次执行以下4个步骤:

- 首先确定p(或obj)的静态类型因为我们调用的是一个成员，所以该类型必然是类类型    
- 在p(或。bj)的静态类型对应的类中查找mem如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端如果找遍了该类及其基类仍然找不到，则编译器将报错
- 一旦找到了mem,就进行常规的类型检查(参见6.1节，第183页)以确认对于当前找到的mem，本次调用是否合法
- 假设调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码:      一如果mem是虚函数且我们是通过引用或指针进行的调用，则编译器产生的代          码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型、      一反之，如果mem不是虚函数或者我们是通过对象(而非引用或指针)进行的          调用，则编译器将产生一个常规函数调用。

```c++
struct Base{      
int  memfcn();
};
struct DerivPd:Base{
    int memfcn(int);  //隐藏基类的memfn

};

Derived d;Base b;

b.memfcn();  //调用Base::memfn

d.memfcn(10);  //调用Derived::memfcn

d.memfcn();   //错误：参数列表为空的memfcn被隐藏了

d.Base::memfcn();  //正确：调用Base::memfcn()

```
**通过基类调用隐藏的虚函数**

```c++
class Base{
public:
    virtual int fcn();
};
class D1:public Base{
public:
    //隐藏基类的fcn,这个fcn不是虚函数
    
    //D1继承了Base::fcn()的定义

    int fcn(int);  //形参列表与Base中的fcn不一致

    virtual void f2();  //是一个新的虚函数，在Base中不存在
};

class D2:public D1{
public:
    int fcn(int);   //一个非虚函数，隐藏了D1::fcn(int)

    int fcn();    //覆盖了Base的虚函数fcn

    void f2();  // 覆盖了D1的虚函数f2
}



Base bobj;
D1 d1obj;
D2 d2obj;

Base *bp1=&bobj,*bp2=&d1obj,*bp3=&d2obj;

bp1->fcn();  //虚调用，将在运行时调用Base::fcn()

bp2->fcn();  //虚调用，将在运行时调用Base::fcn()

bp2->fcn();  //虚调用，将在运行时调用D2::fcn()

Base *pd=&d2obj;
D1 *p2=&d2obj;
D2 *p3=&d2obj;

p1->fcn(42);  //错误：Base中没有接受一个int的fcn

p2->fcn(42);  //静态绑定，调用D1::fcn(int)

p3->fcn(42);  //静态绑定，调用D2::fcn(int)

```

类内using声明的一般规则同样适用于重载函数的名字，基类函数的每个实例在派生类中都必须是可访问的，对派生类没有重新定义的重载版本的访问，实际上是对using 声明点的访问。

### 15.7 构造函数与拷贝控制

虚析构函数将阻止合成移动操作：
如果一个类定义了析构函数，即使它通过`=default`的形式使用了合成的版本，编译器也不会为这个类合成移动操作。

**派生类中删除的拷贝控制与基类的关系**

某此定义基类的万式也可能导致有的派产仁类成员成为被删除的函数：

- 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或艺不可访问，则派生类中对应的成员将是被删除的，原因是编译器小能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作。
- 如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认拷贝和构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。
- 和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用=default请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动，如果基类的析构函数是删除或不可访问的，则派牛类的移动构造函数也将是被删除的。

注意：

- 当派生类定义了拷贝或者移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。
- 在默认情况下，基类默认构造函数初始化派生类对象的基类部分如果我想拷贝(或移动)基类部分，则必须在派生类的构造函数初始值列表中显地使用基类的拷贝(或移动)构造函数。
- 如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。
- 构造函数的using 声明不会改变该构造函数的访问级别。
- 基类构造函数的默认实参，并不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。如果一个构造函数接收两个形参后一个由模式实参，则派生类将获得两个构造函数一个函数接受两个形参(没有默认实参)，另外一个构造函数只接受一个形参，它对应于基类中最左侧的没有默认值的那个形参。
- 如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承。定义在派生类中的构造函数将替换继承来的构造函数
- 继承的构造函数不会被作为用户定义的构造函数来使用，如果一个类只含有继承的构造函数，则他也将拥有一个合成的默认构造函数。

### 15.8 容器与继承

**当派生类对象被赋值给基类对象的时候，其中的派生部分将被“切掉”，因此容器和存在继承关系的类型无法兼容；因此最好在容器中放置(智能)指针而非对象**

**模拟拷贝**
给类添加一个虚拷贝函数，该函数将申请一份当前对象的拷贝。处理动态的内存分配

```c++
class  Quote{
public:
    //该虚函数返回当前对象的一份动态分配的拷贝
    
    virtual Quote* clone() const& {return new Quote(*this);} // const& 是对this的修饰,标明这个this是 const引用
    virtual Quote* clone() && {return new Quote(std::move(*this));}  // && 也是对this的修饰,表示由对象this指针生成的一个右值
}

```


## 第16章 模板与泛型编程

通用函数模板实现函数的泛化([函数模板的定义实现分别放在.h和cpp中将会遭遇symbol问题参考](https://blog.csdn.net/Raptor_2017/article/details/77689009))：
```c++
template <typename T>
int compare(const T &v1,const T &v2){
    if(v1<v2) return -1;
    if(v2<v1) return 1;
    return 0; 
}

cout<<compare(1,0)<<endl;// T为int

cout<<compare(vec1,vec2)<<endl;  // T 为vector<int >
```
注意： 在模板定义中模板参列表不能为空

当使用模板的时候，我们指定模板实参，将其绑定到模板参数上。
模板类型参数，可以像内置类型或者类类型说明符一样使用。

```c++
template <typename T,class u> T foo (T* p,u test)
{
    T tmp=*p;  //tmp的类型将是指针p指向的类型
    //...
    
    return tmp;
}
```
**非类型模板参数**

可以在模板中定义非类型模板参数。一个非类型模板参数表示一个值而非一个类型。

```c++
template <unsigned N,unsigned M>

int compare(const char (&p1)[N],const char (&p2)[M])
{
    return strcmp(p1,p2);
}

compare("hi","mom");
//编译器实例化版本

int compare(const char (&p1)[3],const char (&p2)[4]);
```
注意： 

- 非类型模板参数的模板实参必须是常量表达式。
- 模板程序应该尽量减少对实参类型的要求。
- 编译器遇到一个模板定义的时，并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。
- 保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能够正确工作，是调用者的责任。

**inline和constexpr的函数模板**

```c++
//正确：inline说明符跟在模板参数列表之后

template <typename T> inline T min(const T&,const T&);
//错误：inline说明符的位置不正确

inline template <typename T> T min(const T&,const T&);
```
#### 16.1.2 类模板
编译器不能为类模板推断模板参数类型，为了使用类模板，我们必须在模板名后的尖括号中提供额外的信息。用来代替模板参数的模板实参列表。这也决定了使用模板的时候需要我们提供 **显示模板实参**；

注意：

一个类模板的每个实例都形成了一个独立的类。类型`Blob<string>`与任何其他Blob类型都没有关联，也不会对任何其它Blob类型的成员有特殊访问权限。

```c++
//定义模板类

template <typename T> class Blob
{
public:
    typedef T value_type;
    typedef typename std::vector<T>::size_type size_type;
    Blob(std::initializer_list<T> il);
}


//模板类成员

template <typename T>
T& Blob<T>::back()
{
    check(0,"back on empty Blob");
    return data->back();
} 
template <typename T>
T& Blob<T>::operator[](size_type i)
{
    //如果i太大，check会抛出异常，阻止访问一个不存在的元素
    
    check(i,"subscript out of range");
    return (*data)[i];
}

```
默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化。如果成员函数没有被使用，则它不会被实例化。

**在类模板自己的作用域中，我们可以直接使用模板名而不提供实参**

**在类模板外使用类模板名时，我们并不在类的作用域中，直到遇到类名才表示进入类的作用域**

```c++
template <typename T>
BlobPtr<T> BlobPtr<T>::operator++(int)
{
    //此处无需检查；调用前置递增时会进行检查

    BlobPtr ret=*this;  //保存当前值

    ++*this; //推进一个元素；前置++检查递增是否合法

    return ret;  //返回保存的状态
}

```
在一个类模板的作用域内，我们可以指直接使用模板名而不必指定模板实参。

可以使用typedef来定义模板类的别名。
一个`static`成员函数只有在使用的时候才会实例化。

#### 16.1.3 模板参数
一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。模板参数会隐藏外层作用域中声明的相同的名字。与大多数其他上下文不同，在模板内不能重用模板参数名。

```c++
typedef double A;
template <typename A,typename B> void f(A a,B b)
{
    A tmp=a;// tmp的类型为模板参数A的类型，而非double

    double B; //错误： 重声明模板参数
}
```
**模板声明**

```c++
//声明但不定义compare和Blob

template <typename T> int compare(const T &,const T&)

template <typename T> class Blob;
```
一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现与任何使用这些模板的代码之前

注意：
当我们希望通知班一起一个名字表示类型的时候，必须使用关键字`typename`,而不能使用`class`；

对于static修饰的函数使用函数模板的时候，为了处理模板，编译器必须知道名字是否表示一个类型。默认情况下，c++语言假定通过作用域运算访问的名字不是类型。使用一个模板类型参数的类型成员，就必须显示告诉编译器该名字是一个类型，使用`typename`实现
```c++
template <typename T>
typename T::value_type top(const T& c)
{
    if(!c.empty())
        return c.back();
    else
        retrun typename T::value_type();
}

```
**默认模板实参**
c++11允许为函数和类模板提供默认实参。例如：

```c++
template <typename T,typename F=less<T> >
int compare(const T &v1,const T &v2, F f=F())
{
    if(f(v1,v2)) return -1;
    if(f(v2,v1)) return 1;
    return 0;
}
//compare 有一个默认模板实参 less<T> 和一个默认函数实参F()

template <class T=int> class Numbers{ //T 默认为int
    
public:
        Numbers(T v=0):val(v){}
}

```
#### 16.1.4 成员模板
一个类可以包含本身就是模板的成员函数。这种成员被称为 **成员模板**。成员模板不能是函数。

```c++
class DebugDelete{
public:
    DebugDelete(std::ostream &s=std::cerr):os(s){}
    //与任何函数模板相同，T的类型由编译器推断

    template <typename T> void operator() (T *p) const
    {os<<"deleting unique_ptr"<<std::endl;delete p;}

private:
    std::ostream &os;

}

```
#### 16.1.5 控制实例化
模板使用的时候会通过编译器推断，生成对应类型的函数。当两个或者多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个示例，使得相同模板的额外开销特别严重。在新标准中通过 **显示实例化**来避免这种开销。 先声明再实例化，但是`extern` 声明必须出现在任何使用实例化版本的代码之前。[参考链接](https://blog.csdn.net/Raptor_2017/article/details/77689009)

```c++
extern template declaration;  //示例化声明

template declaration;  //实例化定义

//下面的这些模板类型必须在程序其它位置进行实例化

extern template class Blob<string>;
extern template int compare(const int&.const int&);
Blob<string> sa1,sa2;  //示例化会出现在其它位置

Blob<int> a1={0,1,2,3,4,5,6,7,8,9};
Blob<int> a2(a1);  //拷贝构造函数在本文件中实例化

int i=compare(a1[0],a2[0]);  //实例化出现在其它位置

//templateBuild.cc

//实例化文件必须为每个在其它文件中声明为extern的类型和函数提供一个(非extern)的定义

template int compare(const int&,const int&);
template class Blob<string>;  
//实例化类模板的所有成员

```
当编译器遇到一个实例化定义(与声明相对)时，它为其生成代码。需要将生成的.o文件链接到一起。

注意： 
- 对每个实例化声明，在程序中某个位置必须有其显示的实例化定义。
- 一个类模板的示例化定义会实例化该模板的所有成员，包括内联的成员函数。
- 在一个类模板的实例化定义中，所用类型必须能用于模板的所有成员函数。

### 16.2 模板实参推断

编译器利用调用中的函数实参来确定其模板参数的过程被称为 **模板实参推断**。在模板实参推断过程中，编译器使用函数调用中的实参类型来寻找模板实参，用这些模板实参生成的函数版本与给定的函数调用最为匹配。

- 顶层`const`无论是在形参还是实参中，都会被忽略。
- const转换：可以将一个非const对象的引用（或指针）传递给一个const的引用(或指针)形参。
- 数组或函数指针转换：如果函数形参不是引用来兴，则可以对数组或者函数类型的实惨应用正常的指针转换。一个数组实参可以转化为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针。

**不能应用与函数模板的转换**

- 算术转换
- 派生类向基类的转换
- 用户定义的转换
使用示例：

```c++
template <typename T> T fobj(T,T); //实参拷贝

template <typename T> T fref(const T&,const T&); //引用

string s1("a value");

const string s2("nihao ");
fobj(s1,s2); //调用fobj(string，string)；const 被忽略

fref(s1,s2);//调用fref(const string&,const string&) 将s1转换为const是允许的

int a[10],b[42];

fobj(a,b);  //调用 f(int*,int*)

fref(a,b);  //错误：数组类型不匹配；如果形参是一个引用，则数组不会转换为指针，大小不匹配因此不合法。

```

注意： 
- 将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组或函数到指针的转换。
- 如果函数参数类型不是模板参数，则对实参进行正常的类型转换。

#### 16.2.2 函数模板显示实参

**指定显式模板实参**

定义返回类型的第三个模板参数，从而允许用户控制返回类型：

```c++

template <typename T1,typename T2,typename T3>
T1 sum(T2,T3); 
//编译器无法推断T1，它未出现在函数参数列表中

//显示指定T1帮助实参进行类型推断。

auto val3=sum<long long>(i,lng); // long long sum(int ,long)

//用户必须指定所有三个模板参数

template <typename T1,typename T2, typename T3>
T3 alternative_sum(T2,T1);
//错误：不能推断前几个模板参数

auto val3=alternative_sum<long long>(i,lng);
//正确： 显示指定了所有三个参数

auto val2=alternative_sum<long long ,int,long>(i,lng);


```
**显式模板实参按照由左至右的顺序与对应的参数模板匹配**

#### 16.2.3 尾置返回类型与类型转换

尾置返回允许我们在参数累彪之后声明返回类型；编译器会根据实例化的输入，动态判断返回类型。
```c++
template <typename It>
auto fcn(It beg,It end)->decltype(*beg)
{
    //处理序列

    return *beg; // 返回序列中一个元素的引用
}

template <typename It>
auto fcn2(It beg,It end)->
    typename remove_reference<decltype(*beg)>::type //获取元素类型

    //decltype(*beg)返回元素类型的引用类型
    
    //remove_reference::type 脱去引用，剩下元素类型本身

{
    //处理序列

    return *beg; // 返回序列中一个元素的拷贝
}

```
**标准类型转换模板**

|对`Mod<T>`,其中`Mod`为|若`T`为|则`Mod<T>::type`为|
|:---|:---|:---|
|`remove_reference`|`X&`或`X&&`|`X`|
||否则|`T`|
|`add_const`|`X&`或`const X`或函数|`T`|
||否则|`const T`|
|`add_lvalue_reference`|`X&`|`T`|
||`X&&`|`X&`|
||否则|`T&`|
|`add_rvalue_reference`|`X&`或`X&&`|`T`|
||否则|`T&&`|
|`remove_pointer`|`X*`|`X`|
||否则|`T`|
|`add_pointer`|`X&`或`X&&`|`X*`|
||否则|`T*`|
|`make_signed`|`unsigned X` |`X`|
||否则|`T`|
|`make_unsigned`|带符号类型|`unsigned X`|
||否则|`T`|
|`remove_extent`|`X[n]`|`X`|
||否则|`T`|
|`remove_all_extent`|`X[n1][n2]...`|`X`|
||否则|`T`|

#### 16.2.4 函数指针和实参推断
可以使用指针指向模板函数的实例;
```
template <typename T> int compare(const T&,const T&);
//指针pf1指向实例 int compare(const int&, const int&)

int (*pf1)(const int& ,const int&)=compare
//pf1中参数的类型决定了T的模板实参的类型


```

当参数是一个函数模板实例的地址时，程序上下文必须满足对每个模板参数，能唯一确定其类型或值。

#### 16.2.5 模板实参推断和引用

**从左值引用函数参数推断类型**
```c++

template <typename T> void f1(T&); //实参必须是一个左值
//实参类型为模板参数类型

f1(i); // i是int T是int

f1(ci);//ci 是const int;模板参数T是const int

f1(5); // 错误传递给&参数的实参必须是一个左值 

template <typename T> void f2(const T&); // 可以接受一个右值

//f2中的参数是const &;实参中的const 是无关的。

//在每个调用中，f2的函数参数都被推断为 const int&

f2(i);  //模板参数是int

f2(ci); // 模板参数是 int 

f2(5); //一个const &参数可以绑定到一个右值；T是int

```

**从右值引用函数参数推断类型**

类型推断过程类似普通左值引用函数参数的推断过程。

**引用折叠和右值引用参数**

- 当文将一个左值传递给函数的右值引用参数，且此右值引用指向模板类型参数(T&&)时，编译器推断模板类型参数为实参的左值引用类型。因此，当使用f3(i)时，编译器推断T的类型为int&,而非int
- 如果我们间接创建一个引用的引用，则这些引用形成了“折叠”。在所有情况下，引用会折叠成一个普通的左值引用类型。
- 特殊情况下，引用会折叠成右值引用：右值引用的右值引用。即，对于一个给定类型X:
    + X& &、X& &&和X&& &都折叠成类型X&
    + 类型X&& && 折叠成X&&
- 引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数。

折叠规则和右值引用的特殊类型推断规则结合在一起的时候，可以左值调用`f3`,编译器推断`T`为一个左值引用类型：

```c++
f3(i); //实参是一个左值；模板参数T是 int&

f3(ci); //实参是一个左值；模板参数T是一个const int&

void f3<int&>(int& &&); //当T是int&时，函数参数为int& &&

void f3<int&>(int&); //当T是int&时，函数参数折叠为 int& 

```
结果：

- 如果一个函数参数是一个指向模板类型参数的右值引用(如，T&&),则它可以被绑定到一个左值；可以传递给它任意类型的实参。
- 如果一个左值传递给这样的参数，则函数参数被示例化为一个普通的左值引用(T&)。 

接受右值引用参数的模板函数
```c++
template <typename T> void f3(T&& val)
{
    T t=val; //右值调用f3，f3(42),T为int ;左值i调用f3，T为int&；t类型为 int& .t的初始化值绑定到了val，对t赋值时，也改变了val的值。在下面的判断中永远得到true

    t=fcn(t);//当T为右值时，职高部t，当T为左值时，都改变

    if(val==t){
        /*
        若T是引用类型，则一直为true
        */

    }

}

template <typename T> void f(T&&);  //绑定到非const右值

template <typename T> void f(const T&);  //左值和const右值

```
#### 16.2.6 理解std::move

std::move的定义：

```c++

template <typename T>

typename remove_reference<T>::type&& move(T&& t)
{
    return static_cast<typename remove_reference<T>::type&& >(t);
}
// move的函数参数T&&是一个指向模板类型参数的右值引用。通过引用折叠，参数可以与任何类型的实参匹配。

//接下来使用remove_reference获取T的真实类型

//最后使用静态指针变量使得获得指针的右值引用。

```

#### 16.2.7 转发
- 如果一个函数参数是指向模板类型参数的右值引用(如T&&),它对应的实参的const属性和左值/右值属性将得到保持。
- 当用于一个指向模板参数类型的右值引用函数参数(T&&)时，forward会保持实参类型的所有细节。
- 与`std::move`相同，对`std::forward`不使用`using`声明是一个号主意。

对于模板函数，尽量使用右值引用，避免被使用时，末班类型的推导失去`&`符号，造成拷贝使用。相关参数不能使用。

### 16.3 重载与模板

函数匹配规则与影响：

- 对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例。
- 候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板
- 可行函数(模板与非模板)按照类型转换来排序；可以用于函数模板调用的类型转换是非常有限的。
- 如果存在多个匹配函数则：
    + 同样号的函数中只有一个是非模板函数，选择此函数
    + 没有非模板函数，其中一个模板比其它模板更特例话，则选择此模板
    + 不符合上述两条规则，此调用有歧义。

注意： 正确定义一组重载的函数模板需要对类型间的关系及模板函数允许的有限的实参类型转换有深刻的理解。

**编写重载模板**

例如:`debug_rep(const T&)`;本质上可以用于任何类型，包括指针类型。

注意：
- 当有多个重载模板对一个调用提供童颜好的匹配时，应该选择最特例化的版本。
- 对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选择非模板版本。

对于`cout<<debug_rep("hi word!")<<endl;`而言有：

- `debug_rep(const T&)` ,T被绑定到`char[10]`。
- `debug_rep(T*)` ,T被绑定到`const char`。
- `debug_rep(const string&)` ,要求从`const char*`到`string`的类型转换。

`T*`版本更加特例化，编译器会选择它。

注意:
在定义任何函数之前，记得声明所有重载的函数版本。这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个非你所需要的版本。

### 16.4 可变参数模板

**可变参数模板**：接受一个可变数目参数的模板函数或模板类。可变数目的参数被称为 **参数包**。

参数包分为两种：

- 模板参数包：表示0或者对个模板参数。
- 函数参数包：表示0或者多个函数参数。

使用`class...`或者`typename...`指出接下来的参数表示0个或者多个类型的列表；一个类型名后面跟一个省略号表示0或者多个给定类型的非类型参数的列表。例如：

```c++
//Args 是一个模板参数包；rest 是一个函数参数包

//Args 表示0个或多个模板类型参数

//rest 表示0个或者多个函数参数

template <typename T,typename... Args>
void foo(const T &t,const Args& ... rest);
//使用

int i=0;
double d=3.14;
string s="how now brown cow";
foo(i,s,42,d);//包中有三个参数

foo(s,42,"hi");//包中有两个参数

foo(d,s); //包中有一个参数

foo("hi"); //空包

//编译器会分别为他们实例化不同的版本。

//可以使用sizeof...运算符，计算包中有多少个元素

template<typename ... Args> void g(Args ...args){
    cout<<sizeof...(Args)<<endl; //类型参数的数目

    cout<<sizeof...(args)<<endl; //函数参数的数目
}

```
##### 16.4.1 编写可变参函数模板

可变参函数通常是递归的。第一步调用处理包中的第一个实参，然后用剩余实参调用自身。我们的print函数也是这样的模式，每次递归调用将第二个实参打印到第一个实参表示的流中。为了终止递归，我们还需要定义一个非可变参数的print 函数，它接受一个流和一个对象。

```c++
template <typename T>
//最后一次会优先调用它

ostream &print(ostream &os,const T &t)
{
    return os<<t; //包中最后一个元素之后不打印分隔符

}

//包中除了最后一个元素之外的其它元素都会调用这个版本的print

template <typename T,typename... Args>
ostream &print(ostream &os,const T &t,const Args&... rest)
{
    os<<t<<","; //打印第一个实参

    return print(os,rest...);//递归调用，打印其它实参

}
```
当定义可变参数版本的`print`时，非可变参数版本的声明必须在作用域中。否则，可变参数版本会无限递归。

#### 16.4.2 包扩展

包括展：将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。

```c++
template <typename T,typename... Args>
ostream &print(ostream &os,const T &t,const Args&... rest)//扩展Args

{
    os<<t<<",";
    return print(os,rest...);  //扩展rest

}


```
注意：

扩展中的模式会独立地应用与包中的每个元素。

##### 16.4.3 转发参数包
_参考链接：_ [std::forward](https://zh.cppreference.com/w/cpp/utility/forward);[c++11 完美转发 std::forward()](https://blog.csdn.net/coolwriter/article/details/80970718); [C++11 std::move和std::forward](https://blog.csdn.net/guoxiaojie_415/article/details/79902278)

使用可变参数模板与`forward`机制来编写函数，实现将实参不变地传递给其它函数。使用示例如下：
```c++
class StrVec{
public:
    template <class... Args> void emplace_back(Args&&...);
    ...
};
//函数实现

template <class... Args>
inline void StrVec::emplace_back(Args&&... args)
{
    chk_n_alloc(); //如果需要的话，重新分配StrVec内存空间

    alloc.construct(frist_free++,std::forward<Args>(args)...);
}

```

使用扩展`std::forward<Args>(args)...`它即扩展了模板参数包`Args`，也扩展了函数参数包`args`。生成如下形式元素：
    
    `std::forward<Ti>(ti)`

对于`std::forward<Ti>(ti)`;其中Ti表示模板参数包中第i个元素的类型，ti表示函数参数包中第i个元素。例如：
```c++
svec.emplace_back(10,'c'); //将c*10添加为新的尾部元素

```
construct调用中的模式会扩展出：
`std::forward<int>(10),std::forward<char>(c)`。

### 16.5 模板特例化

特例化版本就是模板的一个独立定义，在其中一个或多个模板参数被指定为特定的类型。
**定义函模板特例话**

特例话一个模板时，必须为原模板中的每个模板参数都提供实参。为了指出我们正在实例化一个模板，应使用关键字`template`后跟一个空尖括号对(`<>``)。指出我们将为原模板的所有模板参数提供实参：

```c++
//compare 的特殊版本，处理字符串数组的指针

template <>
int compare(const char* const &p1, const char* const &p2)
{
    return strcmp(p1,p2);
}
```
**在使用特例化版本时，函数参数类型必须与一个先前声明的模板中对应的类型匹配。**

```c++
template <typename T> int compare(const T&,const T&);
```
特例化版本的本质上是一个实例化模板，而非重载它。因此，特例化不影响函数匹配。
特例化版本主要是为了，提供特殊函数优先级，方便在使用函数时，优先搜索。
**类模板特例化**
示例：
```c++
namespace std{
    template <> //定义特例化版本，模板参数为Sales_data

    struct hash<Sales_data> //特例化模板名为hash

    {
        ...
    };
}

```

注意：特例化版本应该尽量在头文件中事先定义。

**类模板部分特例化**

我们只能部分特例化类模板函数，而不能部分特例化函数模板。

```c++
//原始的最通用版本

template <class T> struct remove_reference
{
    typedef T type;
};
// 部分特例化版本，将用于左值引用和右值引用

template <class T> struct remove_reference<T&> //左值引用

{
    typedef T type;
};

template <class T> struct remove_reference<T&&> //右值引用

{
    typedef T type;    
};

//使用

int i;
//decltype(42)为int,使用原始模板

remove_reference<decltype(42)>::type a;
//decltype(i)为int&,使用第一个(T&)部分特例化版本

remove_reference<decltype(i)>::type b;
//decltype(std::move(i))为int&& ,使用第二个(即 T&&)部分特例化版本

remove_reference<decltype(std::move(i)>::type c;

```
**特例化成员**

```c++
template <typename T> struct Foo
{
    Foo(const T &t=T()):mem(t) { }
    void Bar() {/*...*/}

    T mem;

    ...
    
};
//特例化模板函数

template <>
void Foo<int>::Bar()
{
    //进行应用于int的特例化处理

}
//实例化操作

Foo<string > fs; //实例化Foo<string>::Foo()

fs.Bar();  //实例化 Foo<string>::Bar()

Foo<int> fi; //实例化 Foo<string>::Foo()

fi.Bar();  //使用我们特例化版本的Foo<int>::Bar()

```

# 第IV部分高级主题

## 第17 章标准库特殊设施
标准库设施是:`tuple` 、`bittest`、随机生成数及正则表达式。

### 17.1 tuple 类型
tuple类似于pair是将一些数据组合成单一的对象。可以将其看做一个“快速随意”的数据结构

**tuple支持的操作**

|操作|含义|
|:---|:---|
|`tuple<T1,T2,...,Tn> t;`|t是一个tuple，成员数为n，第i个成员的类型为Ti。所有成员都进行值初始化|
|`tuple<T1,T2,...,Tn> t(v1,v2,...,vn);`|t是一个tuple，成员数为n，第i个成员的类型为Ti。所有成员都使用vi进行值初始化|
|`make_tuple(v1,v2,...,vn)`|返回一个给定初始值初始化的tuple。tuple的类型从初始值的类型推断|
|`t1=t2`|当两个tuple具有相同数量的成员且成员对应相等时|
|`t1!=t2`|当两个tuple具有相同数量的成员且成员对应相等时之外的情况|
|`t1 relop t2`|tuple的关系运算符使用字典序。两个tuple必须具有相同数量的成员。使用<运算符比较t1的成员和t2中的对应成员|
|`get<i>(t)`|返回t的第i个数据成员的引用；如果t是一个左值，结果是一个左值引用；否则，结果是一个右值引用。tuple的所有成员都是public的|
|`tuple_size<tupleType>::value`|一个类模板，可以通过一个tuple类型来初始化。它有一个名为value的public constecpr static 数据成员，类型为size_t,表示给定tuple类型中成员的数量。|
|`tuple_element<i,tupleType>::type`|一个类模板，可以通过一个整形常量和一个tuple类型来初始化。它有一个名为`type`的`public`成员，表示给定`tuple`类型中指定成员的类型。|

使用示例：

```c++
//定义和初始化

tuple<size_t,size_t,size_t> threeD;  //成员都初始化为0

tuple<string,vector<double>,int,list<int> > someVal("constants",{3.14,2.718},42,{0,1,2,3,4,5});

tuple<size_t,size_t,size_t> threeD2{1,2,3};

auto item=make_tuple("0-999-78345-X",x,20.00); 

//成员的访问

auto book=get<0>(item);  //返回第一个成员

//细节信息访问

typedef decltype(item) trans;  // trans 是item的类型

//返回trans类型对象中成员的数量

size_t sz=tuple_size<trans>::value; //返回3

//获取第二个成员的类型

tuple_element<1,trans>::type cnt=get<1>(item);  // cnt 是一个int

```

**tuple常见用法是，函数返回多个值**

### 17.2 bitset类型
标准库定义了`bitset`类，使得位运算的使用更为容易，并且能够处理超过最长整形类型大小的位集合。`bitset`类定义在头文件`bitset`中。`bitset`类是一个模板，它类似`array`类，具有固定的大小。可以在定义时声明：

```c++
bit<32> bitvec(1U);  // 32位；低位为1，其他位为0
```
**大小必须是一个常量表达式**

**初始化bitset方法**

|操作|含义|
|:---|:---|
|`bitset<n> b;`|b有n位；每位均为0.此构造函数是一个`constexpr`|
|`bitset<n> b(u);`|b是`unsigned long long`值u的低n位的拷贝。如果n大于`unsigned long long `的大小，则b中超出的高位被置为0.此构造函数是一个`constexpr`|
|`bitset<n> b(s,pos,m,zero,one);`|b是`string s`从位置`pos`开始m个字符符拷贝。s只能包含字符`zero`或`one`;如果s包含任何其它字符，构造函数会抛出`invalid_argument`异常。字符在b中分别保存为`zero`和`one`。pos默认为0，m默认为string::npos,zero 默认为`0`,`one`默认为`1`|
|`bitset<n> b(cp,pos,m,zero,one);`|与上一个构造函数相同，但从`cp`指向的字符串数组中拷贝字符，如果m未提供，则cp必须指向一个c风格字符串，如果提供了m,则从cp开始必须至少有m个zero或one字符|

使用示例:

```c++
// bitvec1初始值小；初始值中的高位被丢弃

bitset<13> bitvec1(0xbeef);  // 二进制位序列为 1111011101111

//比初始值大；高位被置为0

bitset<20> bitvec2(0xbeef); // 二进制位序列为 0000101111011101111

//64 位机中， long long 0ULL 是64个0比特，因此～0ULL是64个1

bitset<128> bitvec3(~0ULL); // 0~63 位为1; 63~127位为0

//string 初始化 bitset

bitset<32> bitvec4("1100"); //2、3 两位为1，剩余两位为0；高位被置为0。

```

注意：

string 的下标编号习惯与bitset恰好相反；string中下标最大的字符(最右字符)用来初始化`bitset`中的低位(下标为0的二进制位)。

```c++
string str("1111111000000011001101");

bitset<32> bitvec5(str,5,4); // 从str[5]开始的四个二进制位，1100

bitset<32> bitvec6(str,str.size()-4); //使用最后四个字符
```

![初始化流程](wangpengcheng.github.io/img/2019-06-09-bitset-string.png)

#### 17.2.2 bitset操作

**bitset操作表**

|操作|含义|
|:---|:---|
|`b.any()`|b中是否存在置位的二进制位|
|`b.all()`|b中所有位都置位了吗|
|`b.none()`|b中不存在位置的二进制位吗|
|`b.count()`|b中置位的位数|
|`b.size()`|一个`constexpr`函数，返回b中的位数|
|`b.test(pos)`|若pos位是置位的，则返回true,否则返回false|
|`b.set(pos,v)`|将位置pos处的位设置为bool值v。v默认为true。如果未传递实参，将b中所有位置复位|
|`b.set()`||
|`b.reset(pos)`|将位置pos处的位复位或将b中所有位复位|
|`b.reset()`||
|`b.flip(pos)`|改变位置`pos`处的位的状态或改变b中每一位的状态|
|`b.flip()`||
|b[pos]|访问b中位置pos处的位，如果b是const的，则当该位置位时b[pos]返回一个bool值true,否则返回`fasle`|
|`b.to_ulong()/b.to_ullong()`|返回一个unsigned long 或者一个unsigned long long值，其位模式与b相同。如果b中位模式不能放入指定的结果类型，则抛出一个`overflow_error`异常|
|`b.to_string(zero,one)`|返回一个string,表示b中的位模式。zero和one的默认值分别为0和1，用来表示b中的0和1|
|`os<<b`|将b中二进制位打印为字符1或者0，打印到流`os`|
|`is>>b`|从is读取字符存入b。当下一个字符不是1或者0时，或是已经读入b.size()个位时，读取过程停止|

**提取bitset的值**

```c++
unsigned long ulong=bitvec3.to_ulong();

cout<<"ulong ="<<ulong<<endl;

```
注意：

如果bitset中的值不能放入给定类型中，则这两个操作会抛出一个`overflow_error异常`

**bitset的IO运算符**

```c++
bitset<16> bits;
cin>> bits;  // 从cin读取最多16个0或1

cout<<"bits: "<<bits<<endl; //打印刚刚读取的内容

```
#### 17.3 正则表达式 

_参考链接：_ [regex](http://www.cplusplus.com/reference/regex/);

正则表达式是一种描述字符序列的方法，是一种极其强大的计算工具。本章重点介绍正则表达式库(RE)

**正则表达式库组件**

|组件|含义|
|:---|:---|
|`regex`|表示有一个正则表达式的类|
|`regex_match`|将一个字符序列与一个正则表达式匹配|
|`regex_search`|寻找第一个与正则表达式匹配的子序列|
|`regex_replace`|使用给定格式替换一个正则表达式|
|`sregex_iterator`|迭代适配器，调用`regex_sreach`来遍历一个`string`中所有匹配的子串|
|`smatch`|容器类，保存在`string`中搜索的结果|
|`ssub_match`|`string`中匹配的子表达式的结果|

**regex_search和regex_match的参数**

|参数|解释|
|:---|:---|
|`(seq,m,r,mft)`|在字符序列`seq`中查找`regex`对象r中的正则表达式。seq可以是一个string、表示范围的一对迭代器以及一个指向空字符皆为的字符数组的指针|
|`(seq,r,mft)`|m是一个match对应，用来保存匹配结果的相关细节，m和seq必须具有兼容的类型|
||mft是一个可选的`regex_constants::match_flag_type`值。他们会影响匹配过程|

正则表达式简单使用示例

```c++
//查找不在字符c之后的字符串ei

string pattern("[^c]ei");
//包含pattern的整个单词

pattern="[[:alpha:]]*"+pattern+"[[:alpha:]]*";
regex r(pattern); //构造一个用于查找模式的regex

smatch result;  //定义一个对象保存搜索结果

//定义一个string保存于模式匹配和不匹配的文本

string test_str="receipt freind theif receive";

//查找匹配的字符串

if(regex_search(test_str,result,r)){
    std::cout<<result.str()<<endl; //打印匹配的单词

}
```
**regex(和wregex)选项**

|选项|含义|
|:---|:---|
|`regex r(re)`|re表示一个正则表达式，它可以是一个`string`、一个表示字符范围的迭代器对、一个指向空字符结尾的字符数组的指针、一个字符指针和一个计数器或是一个花括符包围的字符列表。|
|`regex r(re,f)`|f是指出对象如何处理的标志。通过下面列出的值来设置。如果未指定f，其摩恩值为`ECMAScript`|
|`r1=re`|将r1中的正则表达式替换为`re`。`re`表示一个正则表达式，它可以是另外一个`regex`对象、一个`string`、一个指向空字符结尾的字符串数组的指针或是一个花括号保卫的字符串列表|
|`r1.assign(re,f)`|与使用赋值运算符(=)效果相同；可选的标志`f`也与`regex`的构造函数中对应的参数含义相同|
|`r.mark_count()`|r中子表达式的数目|
|`r.flags`|返回`r`的标志|

**定义regex时指定的标志**
定义则regex和regex_constants::syntax_option_type中

|选项|含义|
|:---|:---|
|`icase`|在匹配过程中忽略大小写|
|`nosubs`|不保存匹配的子表达式|
|`optimize`|执行速度优先于构造速度|
|`ECMAScript`|使用`ECMA-262`指定的语法|
|`basic`|使用POSIX基本的正则表达式语法|
|`extended`|使用POSIX扩展的正则表达式语法|
|`awk`|使用POSIX版本的awk语言的语法|
|`grep`|使用POSIX版本的grep的语法|
|`egrep`|使用POSIX版本的egrep的语法|

std::regex_match使用示例

```c++
// regex_match example

#include <iostream>
#include <string>
#include <regex>

int main ()
{


    if (std::regex_match ("subject", std::regex("(sub)(.*)") ))
        std::cout << "string literal matched\n";

    const char cstr[] = "subject";
    std::string s ("subject");
    std::regex e ("(sub)(.*)");

    if (std::regex_match (s,e))
        std::cout << "string object matched\n";

    if ( std::regex_match ( s.begin(), s.end(), e ) )
        std::cout << "range matched\n";

    std::cmatch cm;    // same as std::match_results<const char*> cm;
    
    std::regex_match (cstr,cm,e);
    std::cout << "string literal with " << cm.size() << " matches\n";

    std::smatch sm;    // same as std::match_results<string::const_iterator> sm;
    std::regex_match (s,sm,e);
    std::cout << "string object with " << sm.size() << " matches\n";

    std::regex_match ( s.cbegin(), s.cend(), sm, e);
    std::cout << "range with " << sm.size() << " matches\n";
    // using explicit flags:

    std::regex_match ( cstr, cm, e, std::regex_constants::match_default );

    std::cout << "the matches were: ";
    for (unsigned i=0; i<cm.size(); ++i) {
        std::cout << "[" << cm[i] << "] ";
    }

    std::cout << std::endl;

    return 0;
}

/*

result:

string literal matched
string object matched
range matched
string literal with 3 matches
string object with 3 matches
range with 3 matches
the matches were: [subject] [sub] [ject]


 */ 

```

注意：
一个正则表达式的语法是否正确是在运行时解析的。可以使用`regex_error`来抛出异常。

**异常类型表**

|异常类型|含义|
|:---|:---|
|`error_collate` |  The expression contained an invalid collating element name.|
|`error_ctype`| The expression contained an invalid character class name.|
|`error_escape` |   The expression contained an invalid escaped character, or a trailing escape.|
|`error_backref`|The expression contained an invalid back reference.|
|`error_brack`| The expression contained mismatched brackets ([ and ]).|
|`error_paren`| The expression contained mismatched parentheses (( and )).|
|`error_brace`| The expression contained mismatched braces ({ and }).|
|`error_badbrace`| The expression contained an invalid range between braces ({ and }).|
|`error_range`| The expression contained an invalid character range.|
|`error_space`| There was insufficient memory to convert the expression into a finite state machine.|
|`error_badrepeat`| The expression contained a repeat specifier (one of *?+{) that was not preceded by a valid regular expression.|
|`error_complexity` |The complexity of an attempted match against a regular expression exceeded a pre-set level.|
|`error_stack`| There was insufficient memory to determine whether the regular expression could match the specified character sequence.|

注意： 正则表达式的编译是一个非常慢的操作，特别是你在使用了扩展的正则表达式语法或者复杂的正则表达式的时候。应该尽量避免使用。

**正则表达式库类**

|如果输入序列类型|则使用正则表达式类|
|:---|:---|
|`string `|`regex、smatch、ssub_match和sregex_iterator`|
|`const char* `|`regex、smatch、ssub_match和cregex_iterator`|
|`wstring `|`wregex、wsmatch、wssub_match和wsregex_iterator`|
|`const wchar_t*`|`wregex、wsmatch、wcsub_match和wcregex_iterator`|

ECMAScript正则表达式语句基本特性

- `\{d}`表示单个数字而`\{d}{n}`则表示一个`n`个数字的序列。如，`\{d}{3}`匹配三个数组的序列。
- 在方括号中的字符集和表示匹配这些字符中任意一个。如`[-. ]`匹配一个`-`或`.`或` `。
- 后接'?'的组件是可以选的。如，`\{d}{3}[-. ]?\{d}{4}`匹配这样的序列：开始是三个数字，后接一个可选的短横线或点或空格，然后是四个数字。
- 使用反斜线`\`表示一个字符本身而不是其特殊含义。因此必须使用`\(`和`\)`来表示括号是我们模式的一部分而不是特殊字符。
- 由于反斜线是c++中的特殊字符，在模式中，每次出现`\`的地方，我们都必须使用一个额外的反斜线来告诉c++我们需要一个反斜线字符而不是特殊符号。例如`\\{d}{3}`来表示正则表达式`\{d}{3}`

一个正则表达式的字符串分析：
```c++
"(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ]?)(\\d{4})";
```
整个正则表达式包含一个字表达式： (ddd)分隔符ddd分隔符dddd。剥离子表达式：

1. `(\\()?`表示区号可选的左括号
2. `(\\d{3})`表示区号
3. `(\\))?`表示区号部分可选的右括号
4. `([-. ])?`表示区号部分可选的分隔符
5. `(\\d{3})`表示号码的下三位数字
6. `[-. ]?`表示可选的分隔符
7. `(\\d{4})`表示号码的最后四位数字

使用示例：

```c++
string phone="(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ]?)(\\d{4})";

regex r(phone); // regex对象，用于查找我们的模式

smatch m;
string s;

//从文件中读取每条记录
while (getline(cin,s)){
    //对每个匹配的电话号码
    
    for(sregex_iterator it(s.begin(),s.end(),r),end_it;it!=end_it;++it){
        //检查号码的格式是否合法
        
        if(valid(*it)){
            std::cout<<"valid:"<<it->str()<<endl;
        }else{
            cout<<"not valid:"<< it->str()<<endl;
        }
    }

}

```
##### regex_replace
_参考链接：_ [regex_replace](http://www.cplusplus.com/reference/regex/regex_replace/);

**正则表达式替换操作**

```c++
// regex_replace example
#include <iostream>
#include <string>
#include <regex>
#include <iterator>

int main ()
{
  std::string s ("there is a subsequence in the string\n");
  std::regex e ("\\b(sub)([^ ]*)");   // matches words beginning by "sub"
  // using string/c-string (3) version:

  std::cout << std::regex_replace (s,e,"sub-$2");
  // using range/c-string (6) version:
 
  std::string result;
  std::regex_replace (std::back_inserter(result), s.begin(), s.end(), e, "$2");
  std::cout << result;
  // with flags:
  
  std::cout << std::regex_replace (s,e,"$1 and $2",std::regex_constants::format_no_copy);
  std::cout << std::endl;

  return 0;
}
/*

result :
there is a sub-sequence in the string
there is a sequence in the string
sub and sequence

 */

```

**正则表达式匹配选项**

|flag* | effects| notes|
|:---|:---|:---|
|`match_default` |  Default| Default matching behavior. This constant has a value of zero**.|
|`match_not_bol`  | Not Beginning-Of-Line  | The first character is not considered a beginning of line ("^" does not match).|
|`match_not_eol`  | Not End-Of-Line| The last character is not considered an end of line ("$" does not match).|
|`match_not_bow`|   Not Beginning-Of-Word |  The escape sequence "\b" does not match as a beginning-of-word.|
|`match_not_eow` |  Not End-Of-Word| The escape sequence "\b" does not match as an end-of-word.|
|`match_any` |  Any match  | Any match is acceptable if more than one match is possible.|
|`match_not_null `| Not null  |  Empty sequences do not match.|
|`match_continuous` | Continuous | The expression must match a sub-sequence that begins at the first character.Sub-sequences must begin at the first character to match.|
|`match_prev_avail` |   Previous Available | One or more characters exist before the first one. (match_not_bol and match_not_bow are ignored)|
|`format_default` | Default formatting | Uses the standard formatting rules to replace matches (those used by ECMAScript's replace method). This constant has a value of zero**.|
|`format_sed`|sed formatting | Uses the same rules as the sed utility in POSIX to replace matches.|
|`format_no_copy`| No copy| The sections in the target sequence that do not match the regular expression are not copied when replacing matches.|
|`format_first_only`|  First only | Only the first occurrence of a regular expression is replaced.|

```c++

string fmt="$2.$5.$7"; //将号码格式改为 ddd.ddd.dddd

regex r(phone);  //用来寻找模式的regex对象

string number="(908) 555-1800";
cout<<regex_replace(number,r,fmt)<<endl;

```

### 17.4 随机数

_参考链接：_ [random](http://www.cplusplus.com/reference/random/);

c++中的随机数标准库定义在`random`头文件中。包含 **随机数引擎类(random-number engines)**和 **随机数分布类(random-number distribution)**。一个引擎类可以生成`unsigined`随机数序列，一个分布类使用一个引擎类生成指定类型的、在戈丁范围内的、服从特定概率分布的随机数。

注意：
c++程序不应该使用库函数`rand`,而应该使用`default_random_engine`类和恰当的分布类对象。

##### 17.4.1 随机数引擎和分布

注意:
- 使用随机数引擎应该使用`static`关键字修饰。从而每次都生成新的数，否则产生的两次数可能相同。
- 一个给定的随机数发生器一直会生成相同的随机数序列，一个函数如果定义了局部的随机数发生器，应该将其（包括引擎和分布对象）定义为static的。否则，每次调用函数都会生成相同的序列。

```c++
vector<unsigned> good_randVec()
{
    //定义为static的，从而每次调用都生成新的数
    
    static default_random_engine e;
    static uniform_int_distribution<unsigned> u(0,9);
    vector<unsigned> ret;
    for(size_t i=0;i<100;++i){
        ret.push_back(u(e));
    }
    return ret;
}
```
**随机数引擎基本操作**

|操作|含义|
|:---|:---|
|`Engine e`|默认构造函数；使用该引擎类型默认的种子|
|`Engine e(s)`|使用整型值s作为种子|
|`e.seed(s)`|使用种子s重置引擎的状态|
|`e.min()`|此引擎可生成的最大和最小值|

**设置随机数种子** 
通过设置随机数种子引擎可以产生不同的随机数结果。

```c++
default_random_engine e1; //使用默认的种子

default_random_engine e2(2147483646); //使用给定的种子值

default_random_engine e3;  
e3.seed(32767);
default_random_engine e4(32767);  //e3和e4种子相同将会产生相同的随机数。

default_random_engine e5(time(0));  //稍微随机些的种子

```

注意： 

- time生成的随机种子，作为一个自动的过程反复运行，将time的返回值作为种子的方式就无效了；它可能多次使用的都是相同的种子。
- 引擎必须在循环外，否则可能每步循环都产生相同的随机值。

可以使用`uniform_real_distribution`来实现函数的映射。使用示例如下：

```c++
default_random_engine e; //生成无符号的随机数

uniform_real_distribution<double> u(0,1); // 0到1(包含)的均匀分布

for(size_t i=0;i<10;++i){
    cout<<u(e)<<"";
}
```

**非均匀分布的随机数**

|函数方法|说明|
|:---|:---|
|`normal_distribution(a,b)`|标准随机分布，a为均值，b为标准差|
|`bernoulli_distribution(m)`|布尔分布,不接受任何额外的参数时，都是50/50的机会，当m为0.55时则双方机会不均等|

### 17.5 IO库再探

当操作符改变流的格式状态的时候，通常改变后的状态对所有后续IO都生效。

对于bool值的输出需要添加关键字`boolalpha`；如：

```c++
cout<<"default bool values: "<<true<<" "<<false
    <<"\nalpha bool values: "<<boolalpha
    <<true<<" "<< false<<endl;
/*

result:
default bool values: 1 0
alpha bool value: true false


*/
```
**指定整型的进制**

```c++


cout<<showbase;  //打印的时候显示进制

cout<<"default: "<<20<<" "<<1024<<endl;
cout<<"octal: "<<oct<<20<<" "<<1024<<endl;
cout<<"hex: "<<hex<<20<<" "<<1024<<endl;
cout<<"decimal: "<<dec<<20<<" "<<1024<<endl;

cout<<noshowbase; //恢复流状态
/*

default: 20 1024
octal: 024 2000
hex: 0x14 0x400
decimal: 20 1024

 */
```

**指定打印精度**

可以通过cout的`precision()`函数和`setprecision()`函数设置显示的精度。

**输入输出流中的格式控制符**

|控制符| 说明 | 示例|
|:---|:---|:---|
|`boolalpha`  | 设置 bool 类型在数据流中显示为 true 或 false。默认情况下，bool 类型变量显示为1或0。|  `cout << boolalpha` ; 或 `boolalpha (cout)`;|
|`noboolalpha` |设置 bool 类型在数据流中显示为 1 或 0 （恢复 bool 类型的显示状态至默认）。 | cout << noboolalpha ; 或 hex(noboolalpha );|
|`scientific` | 设置浮点数以科学计数法显示。 | cout << scientific ; 或 hex(scientific );|
|`fixed` |  设置浮点数以标准显示法显示。|  cout << fixed ; 或 hex(fixed );|
|`hex` |设置整数类型以十六进制显示。  |cout << hex; 或 hex(cout);|
|`dec` |设置整数类型以十进制显示（默认情况下，整数类型是以十进制显示）。 |   cout << dec; 或 dec(cout);|
|`cot` |设置整数类型以八进制显示   | cout << oct; 或 oct(cout);|
|`internal`  |  数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充。 | cout << internal ; 或 oct(internal );|
|`left`| 设置输出数值或文本的显示形式为左对齐。| cout << left ; 或 oct(left );|
|`right`  | 设置输出数值或文本的显示形式为右对齐。 |cout << right ; 或 oct(right );|
|`showbase`  |  设置数值前缀不显示  | cout << showbase ; 或 oct(showbase );|
|`noshowbase` | 将数值显示的形式恢复至默认状态。 |   cout << noshowbase ; 或 oct(noshowbase );|
|`showpoint` |  即使小数部分为零，也显示浮点数的整数部分和小数点右侧的数字 |  cout << showpoint ; 或 oct(showpoint );|
|`noshowpoint`| 仅显示数值的整数部分。| cout << noshowpoint ; 或 oct(noshowpoint );|
|`showpos` |显示正数值的 + 号。| cout << showpos ; 或 oct(showpos );|
|`noshowpos`  | 忽略正数值前面的 + 号。 |  cout << noshowpos ; 或 oct(noshowpos );|
|`skipws`  |使 cin 获取输入时忽略空格。   | cout << skipws ; 或 oct(skipws );|
|`noskipws`    |使输入流读取空格  |  cout << noskipws ; 或 oct(noskipws );|
|`unitbuf`| 每次执行输出操作后均会清空缓冲区。 |  cout << unitbuf ; 或 oct(unitbuf );|
|`nounitbuf`  | 将 unitbuf 复位至默认状态。 | cout << nounitbuf ; 或 oct(nounitbuf );|
|`uppercase`  | 设置十六进制数值和科学计数法中的指数以大写形式显示。 | cout << uppercase ; 或 oct(uppercase );|
|`nouppercase` |设置十六进制数字和科学计数法的指数以小写形式显示   | cout << nouppercase ; 或 oct(nouppercase );|
|`flush`| 刷新缓冲区  | cout << “str” << flush; 或 flush(cout);|
|`endl`| 刷新缓冲区并插入一个换行符 |  cout << “str” << endl; 或 endl(cout);|

**定义在iomanip中的操作符**

|操作符|含义|
|`setfill(ch)`|用`ch`填充空白|
|`setprecision(n)`|将浮点精度设置为n|
|`setw(w)`|读或写值的宽度为w个字符|
|`setbase(b)`|将整数输出为b进制|

##### 17.5.2 未格式化的输入/输出操作

标准库提供了一组低层操作，支持未格式化IO.这些操作允许我们将一个流当做一个无解释的字节序列来处理。

```c++
char ch;
while(cin.get(ch)) {
    cout.put(ch);
}
```

**单字节低层IO操作**

|操作|含义|
|:---|:---|
|`is.get(ch)`|从`istream is`读取下一个字节存入字符`ch`中。返回`is`|
|`os.put(ch)`|将字符`ch`输出到`ostream os`。返回`is`|
|`is.get()`|将`is`的下一个字节作为`int`返回|
|`is.putback(ch)`|将字符`ch`放回`is`。返回`is`|
|`is.unget()`|将`is`向后移动一个字节。返回`is`|
|`is.peek()`|将下一个字节作为`int`返回,但不从流中删除它|


**将字符放回输入流**

标准库提供了三种方法退回字符：

- `peek`: 返回输入流中一个字符的副本，但不会将它从流中删除，`peek`返回的值仍然留在流中。
- `unget`:输入流向后移动，从而最后读取的值又回到流中。即使我们不知道最后从流中读取什么值，仍然可以调用`unget`。
- `putpack`: 退回从流汇总读取的最后一个值，但它接受一个参数，此参数必须与最后读取的值相同。

这些函数返回整型的主要原因是可以返回文件尾标记符。
```c++
//检测是否达到文件尾部

int ch; //使用一个int,而不是一个char来保存get()的返回值

//循环读取并输出输入中的所有数据

while((ch==cin.get())!=EOF){
    cout.put(ch);
}
```

**多字节操作**

多字节操作要求我们自己分配管理用来保存和提取数据的字符组操作

**多字节低层IO操作**

|`is.get(sink,size,delim)`|从`is`中读取最多`size`个字节，并保存在字符数组中，字符数组的其实地址由`sink`给出。读取过程直至遇到字符`delim`或读取了`size`个字节或遇到文件末尾时停止。如果遇到了`delim`,则将其留在输入流中，不读取出来存入`sink`|
|`is.getline(sink,size,delim)`|与接受三个参数的get版本类似，但会读取并丢弃`delim`|
|`is.read(sink,size)`|读取最多`size`个字节，存入字符数组`sink`中。返回`is`|
|`is.gcount()`|返回上一个未格式化读取操作从is读取的字节数|
|`os.write(source,size)`|将字符数组`source`中的`size`个字节写入`os`。返回`os`|
|`is.ignore(size,delim)`|读取并忽略最多`size`个字节，包括`delim`。与其他未格式化函数不同，`ignore`有默认参数:size的默认值为1，`delim`的默认值为文件尾|

注意： 
- 一个常见的错误是本想从流中删除分隔符，但却忘了做。
- get和getline读取字符时，get将分隔符留作istream中的下一个字符，而getline则读取并丢弃分隔符。无论哪个函数都不会将分隔符保存在`sink`中

##### 17.5.3 流随机访问

**随机IO本质上是依赖于系统的。为了理解如何使用这些特性，必须查询系统相关文档**

**seek和tell函数**
一个函数通过将标记seek到一个给定位置来重定位它；另外一个函数tell我们标记的当前位置。后缀`g`表示正在"获得"，后缀`p`表示正在放入

|函数|定义|
|:---|:---|
|`tellg()/tellp()`|返回一个输入流中(tellg)或输出流中(tellp)标记的当前位置|
|`seekg(pos)/seekp(pos)`|根据标定的`pos`值，重定位到输入/输出流中的绝对地址|
|`seekp(off,from)/seekg(off,from)`|在一个输入流或输出流中将标记定位到from之前或之后`off`个字符，`from`可以是下列值之一：`beg`,偏移量相对于流开始位置，`cur`,偏移量相对于流当前结束位置；`end`,偏移量相对于流结尾位置 |

注意：由于只有单一的标记，因此只要我们在读写操作间切换，就必须进行`seek`操作来重定位标记。

使用示例：

```c++
#include <iostream>
#include <fstream>
using namespace std;

int main(){
    //以读写方式打开文档
    
    fstream inOut("copyout",fstream::ate|fstream::in|fstream::out);

    if(!inOut){
        cerr<<"Unable to open file"<<endl;
        return 0;
    }
    auto end_mark=inOut.tellg(); //记住原文件尾位置

    inOut.seekg(0,fstream::beg); //重定位带文件开始

    size_t cnt=0; //字节数累加器

    string line;  //保存输入中的每行

    // 还未遇到错误且未到末尾，持续读取
    while(inOut&& inOut.tellg()!=end_mark
        &&getline(inOut,line))
    {
        cnt+=line.size()+1; //+1表示换行

        auto mark=inOut.tellg(); //记住读取位置

        inOut.seekp(0,fstream::end); // 将写标记移动到问价尾

        inOut<<cnt;   //输出累计长度

        if(mark!=end_mark){
            inOut<<" ";
        }
        inOut.seekp(0,fstream::end); //定位到文件尾
    }

    inOut<<"\n";  //文件尾部输出换行符
    return 0;

}
```
## 第18章 用于大型程序的工具

### 18.1 异常处理

_参考链接：_ [C++异常处理（try catch）从入门到精通](http://c.biancheng.net/cplus/exception/);

注意： 

- 一个异常如果没有被捕获，则它将终止当前的程序
- 在钱展开的过程中，运行类类型的局部叶象的析构函数，因为这些析构函数是自动执行的，所以它们不应该抛出异常_一旦在钱展开的过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终止。
- 抛出指针要求在任何时应的处理代码存在的地方，指针所指的对象都必须存在。
- 通常情况下，如果catch接收的异常与额某个继承体系有关，则最好将该catch的参数定义成类型引用
- 如果在多个catch语句的类型之间存在着继承关系，则我们应该把继承链最底端的类(most derived type )放在前面，而将继承链最顶端的类(least derivedtype)放在后面。

异常类型和catch声明的类型是精确匹配的：

- 允许从非常量向常量的类型转换
- 允许派生类向基类的转换
- 数组被转换成指向数组(元素)类型的指针，函数被转换成指向该函数类型的指针。
- 处理构造函数初始值异常的唯一方法是讲构造函数写成try语句块

`catch(...)`可以匹配任意的异常类型。其通常与重新抛出语句一起使用，其中catch执行当前局部能完成的工作，随后重新抛出异常;当其与其它几个`catch`语句一起出现的时候，必须放在最后否则后面的语句永远不会被执行。

```c++
void manip(){
    try{
        //这里的操作将引发并抛出一个异常
    }
    catch (...){
        //处理异常的某些特殊操作
        
        throw;
    }
}
```

注意： 由于构造函数执行的时候，try语句可能还未能成功初始化，所以不能正常的抛出异常。我们必须将构造函数携程 **函数try语句块**的形式。才能正真使用。例：

```c++
temlate <typename T>
Blob<T>::Blob(std::initializer_list<T> il) try :
    data(std::make_shared<std::vector<T>>(il)){
        // 函数体
        
    } catch (const std:bad_alloc &e){handle_out_of_memory(e);}

```
##### 18.1.4 noexcept 异常说明

C++11新标准中，可以通过提供noexceot说明，指定某个函数不会抛出异常。使用时关键字紧跟函数的参数列表后面。

```c++
void recoup(int) noexcept; //不会抛出异常

void alloc(int);  //可能抛出异常

```

注意：

- 通常情况下，编译器不能也不必在编译时验证异常说明。
- noexcept有两层含义:当跟在函数参数列表后面时它是异常说明符;而当作为noexcept异常说明的bool实参出现时，它是一个运算符。

##### 18.1.5 异常类层次

![异常层次图](../img/error.png)

### 18.2 命名空间

#### 18.2.2 命名空间的定义
```
namespcae cplusplus_primer{
    ...
}
```

注意：

- 命名空间作用域后面无须分号；每个命名空间都是一个作用域
- 命名空间可以是不连续的
    + 命名空间的部分成员的作川是定义类，以及声明作为类接口的函数及对象，则这个 成员应该放置几头文件中，这namespace,头文件将被包含在使用了这些成员的文件中。
    + 命名空间成员的z义部分则置于另外的源文件中。
    + 在程序III某此实体只能定义一次:如非内联函数、静态数据成员、变量等。
- 定义多个类型不相关的命名空间应该使用单独的文件分别表示每个类型(或关联类型构成的集合)。
- 对于多个命名空间使用时可以使用`::spcaename::subspacename`的方式来寻找命名空间。
- 模板特例化必须定义在原始模板所属的命名空间中。
- 使用`::`全局作用域，隐式的将函数添加到全局作用域中。
- 未命名的命名空间仅仅在特定的文件内部有效，其作用范围不会横跨多个文件。

**内联命名空间**

内联命名空间和普通的嵌套命名空间不同，内联命名空间可以被外层命名空间直接使用。无需使用外层命名空间名字，就可以直接访问它。

```c++
inline namespace FifthEd{
    //使用内联命名空间
    
}

namespace FifthEd{ //隐式内联

    class Query_base{
        /**/

    };
    //其它相关命名
    
}
```

#### 18.2.2 使用命名空间成员

可以使用通用赋值给命名空间别名,例如：
```c++
namespace primer=cplusplus

namespace Qlib=cplusplus_primer::Querylib;
```
注意避免使用using 指示

#### 18.2.3 类、命名空间与作用域

对命名空间内部名字的查找遵循常规的查找规则:即由内向外依次查找每个外层作川域。外层作川域也可能是一个或多个嵌套的命名空间，直到最外层的个局命名空间查找过程终止。只有位于开放的块中且在使用点之前声的名字才被考虑:

可以从函数的限定名推断出查找名字时检查作用域的次序，限定名以相反次序指出被查找的作用域。

#### 18.2.4 重载与命名空间

 一个。using明引入的函数将重载声明语句所属作作用域已有的其他同名函数。如果using声明出现在局部作川域中，则引入的名字将隐藏外层作用域的相关声明。如果using声明所在的作用域中已经有一个函数与新引入的函数同名且形参列表相同，则该using声明将引发错误。除此之外，using声明将为引入的名字添加额外的重载实例，并最终扩充候选函数集的规模。

using指示将命名空间的成员提升到外层作用域中，如果命名空间的某个函数与该命名空间所属作用域的函数同名，则命名空间的函数将被添加到重载集合。

如果存在多个using指示，则来自每个命名空间的名字都会成为候选函数集的一部分。

### 18.3 多重继承与虚继承

注意：

- 如果从多个基类中继承了相同的构造函数（即形参列表完全相同），则程序将产生错误。
- 当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况、此时，不加前缀限定符直接使用该名字将引发二义性。

#### 18.3.4 虚继承

- 在默认情况下，派生类中含有继承链上每个类对应的f-部分.如果某个类派生类，中出现了多次，则派之卜类中将包含该类的多个子对象。
- 为了解决上述多次继承的情况，设置了 **虚继承**它的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为虚基类( virtual base class ) 。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生中都只包含唯一一个共享的虑基类子对象。
- 虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。
- 虚继承在后续的派生类中共享虚基类的同一份实例。
- 对于相同虚函数的继承，可能存在二义性，最好的办法是在派生类中自定义实例。

#### 18.3.5 构造函数与虚继承

含有虚基类的对象的构造书序与一般的顺序稍有叙别：首先使用提供给最低层派生类（最低层公共部分）构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生表中出现的次序从左向右对其进行初始化。

虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。


## 第 19 章 特殊工具与技术

### 19.1 控制内存分配

new 的过程：

- 分配内存空间
- 赋予初值。
- 指向该指针。

delete过程

- 执行指针所指对象的析构函数
- 调用标准函数库，释放指针。

**当只传入一个指针类型的实参时，定位new表达式构造对象但是不分配内存。**
**调用析构函数会销毁对象，但是不会释放内存。**

### 19.2 运行时类型识别

运行时类型识别(run-time type identification,  RTTI)的功能由两个运算符实现:

- typeid 运算符，用于返回表达式的类型；可以作用于任意类型的表达式。
- dynamic_cast 运算符，用于将基类的指针或引用安全的转换成派生类的指针或者引用。
- 在条件部分执行dynamic cast操作可以确保类型转换和结果检查在同一条表达式中完成。
- 当typeid作用于指针时(而非指针所指的对象)，返回的结果是该指针的静态编译时类型。

`type_info`类，用来鉴定类型是否相同。

type_info类在不同的编译器上有所区别。有的编译器提供了额外的成员函数以提供程序中所用类型的额外信息。读者应该仔细阅读你所用编译器的使用手册，从而获取关于type-info的更多细节。

### 19.3 枚举类型

C++包含两种枚举类型：限定作用域的和不限定作用域的。
限定作用域的枚举类型： enum class(struct) {...}。不限定枚举可以省略掉关键字class，枚举类型名字可选。

```c++
enum color {red,yellow,green};   //不限定作用域的枚举类型

enum stoplight {red,yellow,green};  //错误：重复定义了枚举成员

enum class peppers {red,yellow,green}; //正确：枚举成员被隐藏了

color eyes=green;  //正确： 不限定作用域的枚举类型位于有效的作用域中

pepper p=green;   // 错误：pepper的枚举成员不在有效的作用域中

color hair=color::red;  //正确：允许显式地访问枚举成员

peppers p2=pepper::red;  //正确：使用pappers的red

//指定序号

enum class intType{
    charTyp=8,shortTyp=16,intTyp=16,
    longTyp=32,long_longTyp=64
}

//利用冒号指定类型

enum intValues:unsigned long long {
    charType=255,shortTyp=65535,
    ......
}
```

注意： 

- 即使某个整型值恰好与枚举成员的值相等，它也不能作为函数的enum实参使用。
- 但是可以使用强制类型转换，将enum提升成int或更大的整型。

### 19.4 指针类成员

**成员指针** 是指可以指向类的排静态成员的指针。类的静态成员不属于任何对象。

我们令其指向类的某个成员，但是不指定该成员所属的对象；直到使用成员指针时，才提供成员所属的对象。

#### 19.4.1 数据成员指针

与普通指针不同的是成员指针必须包含成员所属的类

```c++
//pdata可以指向一个常量(非常量)Screen对象的string成员

const string Screen::*pdata;

pdata=&Screen::contents;//获取成员对象

auto pdata=&Screen::contents;
//使用成员指针

Screen myScreen,*pScreen=&myScreen;
//.*解引用pdata以获得myScreen对象的contents成员

auto s=primaryScreen.*pdata;
//->*解引用pdata以获得pScreen所指对象的contents成员

s=pScreen->*pdata;

```

#### 19.4.2 成员函数指针

```c++
//利用auto关键字指向一个常量成员函数
//前提是该函数不接受任何实参，并且返回一个char

auto pmf=&Screen::get_cursor;
//指向含有两个形参的get

char (Screen::*pmf2)(Screen::pos,Screen::pos) const;
pmf2=&Screen::get;
//成员函数的使用

Screen myScreen，*pScreen=&myScreen;
//通过pScreen 所指的对象pmf所指的函数

char c1=(pScreen->*pmf)();
//通过myScreen对象将实参0,0传给含有两个形参的get函数

char c2=(myScreen.*pmf2)(0,0);
//使用成员指针的类型别名

//Action 是一种可以指向Screen成员函数的指针，它接受两个pos实参，返回一个char

using Action=char (Screen::*)(Screen::pos,Screen::pos) const;

Action get=&Screen::get;  //指向Screen的get成员。

//使用函数指针成员表
class Screen{
public:
    Screen& home();  //光标移动函数

    Screen& forward();
    Screen& back();
    Screen& up();
    Screen& down();

    //Action 是一个指针，可以用任意一个光标移动函数对其赋值

    using Action=Screen& (Screen::*)();
    //具体移动方向指定
    
    enum Directions {HOME,FORWARD,BACK,UP,DOWN};
    Screen& move(Directions){
        //运行this对象中索引值为cm的元素
        
        return (this->*Menu[cm])();  //Menu[cm]指向一个函数成员

    };
private:
    static Action Menu[];  //函数表

}

Screen myScreen;

myScreen.move(Screen::HOME);  //调用myScreen.home

myScreen.move(Screen::DOWN);  //调用myScreen.down

//初始化函数表

Screen::Action Screen::Menu[]={
    &Screen::home,
    &Screen::forword,
    ...
};
```

#### 19.4.3 将成员函数用作可调用对象

**使用function生成一个可调用对象**

使用标准模板库function 可以凶函数指针获取可调用对象。

```c++
function<bool (const string&)> fcn=&string::empty;
find_if(svec.begin(),svec.end(),fcn);
```

**使用mem_fn生成一个可调用对象**

```c++
auto f=mem_fn(&string::empty);
```

**使用bind生成一个可调用对象**

```c++
auto it=find_if(svec.begin(),svec.end(),bind(&string::empty,_1));

```


### 19.5 嵌套类

一个类可以定义在另外一个类的内部。可以在类之外声明一个类内的嵌套类：
`class class1_name::class2_name{}`

- 在嵌套类在其外层类之外完成真正的定义之前，它都是一个不完全类型。
- 嵌套类的作用域查找，比一般类多了一个外层类作用域的查找。
- 外层类可以直接使用嵌套类的名字。
- 外层类和嵌套类相互独立，都各自只包含自己的成员名字。

### 19.6 union: 一种节省空间的类

 联合(( union )是一种特殊的类一个union 可以有多个数据成员，但是在仟愈时刻只有一个数据成员可以有直。当我们给union的某个成员赋值之后, 该union的其它成员就变成末定义的状态了。分配给一个union对象的存储空间至少要能容纳它的最大的数据成员。和其他类一样，一个union定义了一种新类型。

**匿名union**

是一个未命名的union,并且在符号之间没有任何声明。一旦我们定义了一个匿名union，编译器自动地位该union创建一个未命名的对象。在union的定义所在的作用域内该union的成员都是可以直接访问的。

注意：

- 匿名union不能包含受保护的成员或者私有成员，也不能定义成员函数。
- union中成员类中成员没有定义默认构造函数，则编译器删除类中的该成员。

### 19.7 局部类

定义在某个函数内部的类称为，局部类。局部类定义的类型只在定义它的作用域内可见。

注意：

- 局部类的所有成员(包括函数在内)都必须完整定义在类的内部。因此，局部类的作用与嵌套类相比相差很远。
- 局部类只能访问外层作用域定义的类型名、静态变量以及枚举成员。
- 局部类不能使用函数作用域中的变量。
- 常规的访问保护规则对局部类同样适用。

### 19.8 固有的不可移植的特性

是指因机器而异常的特性，当机器转移时，需要重新编写该程序。

#### 19.8.1 位域

**位域在内存中的布局是与机器相关的**

位域的类型必须是整型或枚举类型。因为带符号位域的行为是由具体实现确定的。
位域的声明形式是成员名字后紧跟一个冒号以及一个常量表达式，该表达式用于指定成员所占的二进制位数。

```c++
typedef unsigned int Bit;

class File{
    Bit mode: 2;  //mode占2位
    
    Bit modified:1;  //占1位
    
    ...

public:
    //文件类型以八进制表示
    
    enum modes{READ=01,WRITE=02,EXECUTE=03};
}
```
注意： 通常情况下最好将位域设为无符号类型，存储在带符号类型中的位域的行为将因具体实现而定。

#### 19.8.2 volatile 限定符

volatile的确切含义与机器有关，只能通过阅读编译器文档来理解、要想让使用了volatile的程序在移植到新机器或新编译器后仍然有效，通常需要对该程序进行某些改变。关键字volatile告诉编译器不应对这样的对象进行优化。

注意：

- 关键字volatile告诉编译器不应对这样的对象进行优化。
- 合成的拷贝对volatile对象无效。
- volatile 不能使用合成的拷贝/移动构造函数和赋值运算符初始化。

#### 19.8.3 链接指示: extern "C"

要想把c++代码和其他语言(包括c语言)编写的代码放在一起使用.要求我们必须有权访问该语言的编译器，并且这个编译器与当前的c++编译器是兼容的。

当一个#include指示被放置在复合链接指示的花括号中时，文件中的所有普通函数声明都被认为是由链接指示的语言编写的。链接指示可以嵌套，因此如果头文件包含自带链接指示的函数，则该函数的链接不受影响。

```c++
ectern "C"{
    #include <string.h>
}
```

**指向extern "C"函数的指针**

```c++
//pf指向一个c函数，该函数接受一个int返回void

extern "C" void (*pf)(int);

void (*pf1)(int);  //指向一个c++函数
```

注意：

- 有的C++编译器会接受之前的这种赋值操作并将其作为对语言的扩展，尽管从严格意义上来看它是非法的。
- 链接指示对整个声明都有效。当我们使用链接指示时，它不仅仅对函数有效，而且对作为返回内省或形参类型的函数指针也有效。

**导出C++函数到其他语言**
通过使用链接器指示对函数进行定义，我们可以令一个C++函数在其它语言编写的程序中使用

```c++
//calc 函数可以被C程序调用

extern "C" double calc(double dparm){
    /**/
}
```
**有时可以使用预处理器定义`__cplusplus`来有条件的包含代码**
```c++

#if defined(__cplusplus) || defined (c_plusplus)
extern "C"
{
#endif

#include <stdio.h>

#include <stdlib.h>

#include "libavcodec/avcodec.h"

#include "libavformat/avformat.h"
#include "libavutil/pixfmt.h"

#include "libavutil/mathematics.h"

#include "libavutil/time.h"

#include "libswscale/swscale.h"

#if defined(__cplusplus) || defined (c_plusplus)
}
#endif

```

注意：extern "..."的重载和链接与语言本身有关。


# 结束















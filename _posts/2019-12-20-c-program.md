---
layout: post
title:  C++学习笔记
subtitle:   C++ Primer 学习记录
date:   2019-12-20 15:17:00
author:  wangqiwen
categories: 编程语言
tags: C C++
excerpt: C/C++编程语言笔记
mathjax: true
header-img: img/post-bg-ios10.jpg
catalog: true
---

* content
{:toc}



# C++ Primer学习笔记

> 2019-4-17 [地址](https://github.com/wangpengcheng/wangpengcheng.github.io/tree/master/_posts)

## 第1章 开始
### std::cin 中的循环流使用
_参考链接：_[while(cin >> num)循环输入问题](https://bbs.csdn.net/topics/390809866)[C++ cin输入流 详细用法](https://blog.csdn.net/imkelt/article/details/51925479);

C++ 中可以使用`while(std::cin >> value){//Code }`的方式来进行循环数据的读入，直到没有输出为止；示例代码如下：
```c++
/*
输入样例： 3 4 5 6
输出 ： Sum is :18
 */

#inlude <iostream>
int main()
{
    int sum =0;value=0;
    //循环读取数据

    while(std::cin>>value){
        sm+=value;
    }
    std::out<<"Sum is:"<<sum<<std:endl;
    return 0;
}
```
注意：

* 当键盘向程序中输入数据时，对于文件结束；Windows是`Ctrl+Z`然后 `Enter`或者`Return`;UNIX 中是`Ctrl+D` 然后再加`enter`;
* 当缓冲区中有残留数据时，`std::cin`会直接去读取缓冲区的数据而不会请求键盘输入。重要的是，回车符也会被存在输入缓冲区中。
* 当程序中有多个等待循环输入时，需要使用`cin.clear()`来重置循环状态，方便再次输入; 

# 第二章 变量和基本类型

## C++变量和基本类型
### C++中的基本类型
_参考链接：_[C/C++中基本数据类型所占内存大小](https://blog.csdn.net/zcyzsy/article/details/77935651);[C/C++中基本数据类型在不同系统中所占空间大小](https://blog.csdn.net/yimingsilence/article/details/54730438);

C++中定义了算术类型(arithmetic type)和空类型(void)在内的基础数据结构算术类型表如下：

| 类型 | 含义 | 最小尺寸 |
|:------------:|:---------------:|:-----:|
| bool         | 布尔类型| 未定义 |
| char | centered | 8位 |
| wchart_t | 宽字符 | 16位 |
| chart16_t | Unicode字符 | 16位 |
| chart32_t | Unicode字符 | 32位 |
| short | 短整型 | 16位 |
| int | 整型 | 16位 |
| long | 长整型 | 32位 |
| long long | 长整型 | 64位 |
| float | 单精度浮点数 | 6位有效数字 |
| double | 双精度浮点数 | 10位有效数字 |
| long double | 扩展精度浮点数 | 10位有效数字 |

注意：

* 关于不同类型，字节内存分配的问题，不同的操作系统存在不同的内存分配策略；因此不一定按照上面的进行分配；详细内容参看参考链接。
* 对于C++中的字节对齐内容需要重点考虑([C++ 字节对齐的总结(原因和作用)](https://blog.csdn.net/sweetfather/article/details/78487563);[C/C++ 字节对齐](https://blog.csdn.net/chengonghao/article/details/51674166));
* c++中除去布尔类型和扩展的字符类型之外，其它类型可以划分为带符号的(signed)和无符号的(unsigned)两种；无符号仅能表示大于0的值。器字节内存分配也有所不同；（[C/C++ unsigned 详细探讨](https://blog.csdn.net/zhenlin123/article/details/81062635)）;

### C++中的声明和定义
C++中使用分离式编译机制，允许每个文件被单独编译；为了支持这种模式；C++语言将声明和定义区分开来；声明(declaration) 使得名字为程序所知；定义（definition）负责创建与名字关联的实体。
如果想要声明一个变量而非定义它，就在变量名字前添加关键字`extern`;而且不要显示的初始化变量：
```c++
extern int i ;//声明i 而非定义i

int j;//声明并定义j
```
### C++中的类型转换：
C++中的类型转换分为显式转换和隐式转换2种；显式转换直接在代码中注明其转换类型;如`double a=1.002;int i=(int)a;`将类型进行显式转换；同时也存在隐式转换；如`int i=10/1.0`;其中`10/1.0`即包含隐式的`int`到`double`的转换，`=`又进行了一次`double`到`int`的隐式转换；隐式转换在编码规范中不推荐；应该劲量使用显式转换；

```c++
bool b=42;      //b为真

int i=b;        //i的值为1

i=3.14;         //i的值为3

double pi=i;    //pi的值为3.0

unsigned char c=-1; //假设char占a比特，c的值为255

signed char c2=256; //假设char:占8比特，c2的值是未定义的
```
* 当数字加减超过数据类型的取值范围的时候，就会按照位运算进行取模，输出结果是取模之后的结果（[C++ 带符号和无符号char类型赋值超出表示范围的情况](https://blog.csdn.net/eastlhu/article/details/72809256)）；

例如：8比特大小的unsigned char可以表示0至255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256（总数）取模后所得的余数。
因此，把-1赋给8比特大小的unsigned char所得的结果是255，使用2种方法计算：

> 有整数a和b，a对b进行取模或取余运算
> 
> 1、求整数商：c=a/b
> 
> * 取模运算在计算商值向负无穷方向舍弃小数位
> * 取余运算在计算商值向0方向舍弃小数位
>
> 2、计算模或者余数：r=a-(c*b)
> 
> * 取模运算遵循尽可能让商小，取余运算遵循尽可能让余数的绝对值小。因此，取模和取余的结果不同。
> * mod为取模，rem为取余，取模和取余所得的结果在a和b(同为整数) 符号相同 的时候是相等的
> * 当a和b符号一致时，求模运算和求余运算所得的c的值一致，因此结果一致。但是当符号不一致的时候，结果不一样。
> * 具体来说，求模运算结果的符号和b一致，求余运算结果的符号和a一致

在本例中，将-1和256带入a和b，c=-1/256，向负无穷方向舍弃小数得-1，计算得r=255.
> 计算机中带符号的整数采用二进制的补码进行存储;
> 正数的补码等于其二进制编码;
> 负数的补码等于其绝对值的二进制编码，取反，再加1;
> 在本例中，-1的绝对值是1，二进制编码为0000 0001，取反加1就是1111 1111;
> unsigned是无符号数，会把1111 1111看成正数，刚好是255的二进制编码。

```c++

unsigned u=10;
int i=-42;
std::cout<<i+i<<std::endl; //正确：输出32

std::cout<<u+i<<std::endl; //如果int占32位，输出4294967264
//上面讲-42转化为unsigned int 负数转化为无符号函数，类似于直接给无符号数赋值一个负值；等于这个负数加上无符号数的模。  

unsigned ul=42,u2=10;
std::cout<<u1-u2<<std::endl;//正确：输出32；

std::cout<<u2-u1<<std::endl;//正确：不过，结果是取模后的值；

```

GCC编译器32位机和64位机各个类型变量所占字节数

|C类型| 32位机器(字节)| 64位机器(字节)|
|:---|:---|:---|
|`char` | 1 |1|
|`short`| 2| 2|
|`int`| 4 |4|
|`long int`|  4| 8|
|`long long`| 8| 8|
|`char *` | 4 |8|
|`float`| 4| 4|
|`double`|  8| 8|




### 字面常量值：
字面常量值就是常量；如`10/*十进制*/`；`014/*八进制*/`；`0x14/*十六进制*/`；包含整数和字符；C++11标准中允许使用`{}`进行数据对象的初始化，但是C++98中并不允许；例
```c++
vector<int > main_test={1,2,3};
```
### C++中的关键字
_参考链接：_ [C++关键字详解](https://blog.csdn.net/scmuzi18/article/details/53696778);

C++中存在预定义的关键字；如下图所示

![C++关键字表格](https://wangpengcheng.github.io/img/cplusplus_key_words.png)

注：上表中为C++98/03中的63个关键字，其中红色标注为C语言中的32个关键字。C++11中有73个关键字，新增加的10个为：`alignas、alignof、char16_t、char32_t、constexpr、decltype、noexpect、nullptr、static_assert、thread_local`

1. asm
   _asm是一个语句的分隔符。不能单独出现，必须接汇编指令。一组被大括号包含的指令或一对空括号。
例：
```c++
_asm
{
  mov al,2
  mov dx,0xD007
  out al,dx
}
```
    也可以在每个汇编指令前加`_asm`
```c++
  _asm mov al,2
  _asm mov dx,0xD007
  _asm out al,dx
```
2. auto 
   auto关键字会根据初始值自动推断变量的数据类型。不是每个编译器都支持auto。
   例：
```c++
    auto  x = 7;  //使用整数7对变量x进行初始化，可推断x为int型。

    auto  y=1.234;  //使用浮点数1.234对变量y进行初始化，可推断y为double型。
```

3. *_cast
   即 `const_cast`、`dynamic_cast`、`reinterpret_cast`、`static_cast`。
   C++类型风格来性转换。`const_cast`删除const变量的属性，方便赋值；`dynamic_cast`用于将一个父类对象的指针转换为子类对象的指针或引用；`reinterpret_cast`将一种类型转换为另一种不同的类型；`static_cast`用于静态转换，任何转换都可以用它，但他不能用于两个不相关的类型转换。
4. `bool、true、false`

`bool`即为布尔类型，属于基本类型中的整数类型，取值为真和假。`true`和`false`是具有布尔类型的字面量，为右值，即表示真和假。
注`：`字面量`：`用于表达源代码中一个固定值的表示法。
5. `break`、`cotinue`、`goto` 
   `break`用于跳出`for`、`while`循环或`switch`语句。`continue`用于调到一个循环的起始位置。goto用于无条件跳转到函数内得标号处。一般情况不建议使用`goto`，风险较大。

6. `switch`、`case`、`default`
   `switch`分支语句的起始，根据`switch`条件跳转到`case`标号或`defalut`标记的分支上。

7. `catch`、`throw`、`try`
   用于异常处理。`try`指定`try`块的起始，`try`块后的`catch`可以捕获异常。异常由`throw`抛出。`throw`在函数中还表示动态异常规范。
8、`char`、`wchar_t`
   表示字符型和宽字符型这些整数类型（属于基本类型），但一般只专用于表示字符。`char`（和`signed char`、`unsigned char`一起）事实上定义了字节的大小。`char`表示单字节字符，`wchar_t`表示多字节字符。
9. `const`、`volatile`
   `const`和`volatile`是类型修饰符，语法类似，用于变量或函数参数声明，也可以限制非静态成员函数。`const`表示只读类型（指定类型安全性，保护对象不被意外修改），`volatile`指定被修饰的对象类型的读操作是副作用（因此读取不能被随便优化合并，适合映射I/O寄存器等）。
  * `volatile`:
        * 当读取一个变量时，为提高存取速度，编译器优化时有时会先把变量读取到一个寄存器中，以后再取变量值时，就直接从寄存器中取值。
        * 优化器在用到`volatile`变量时必须每次都小心地重新读取这个变量的值，而不是使用保存到寄存器里的备份。
        `volatile`适用于多线程应用中被几个任务共享的变量。
10. `struct`、`class`、`union`
  用于类型声明。`class`是一般的类类型。`struct`在C++中是特殊的类类型，声明中仅默认隐式的成员和基类访问限定与`class`不同（`struct`是`public`，`class`是`private`）。`union`是联合体类型。满足特定条件类类型——`POD struct`或`POD union`可以和C语言中的`struct`和`union`对应兼容。
注：POD类型（Plain Old Data）,plain---代表普通类型，old---代表可以与C语言兼容。
11. `new`、`delete`
   `new`、`delete`属于操作符，可以被重载。`new`表示向内存申请一段新的空间，申请失败会抛出异常。`new`会先调用`operator new`函数，再在`operator new`函数里调用`malloc`函数分配空间，然后再调构造函数。`delete`不仅会清理资源，还会释放空间。`delete`县调用析构函数，其次调用`operator delete`函数，最后在`operator delete`函数里面调用`free`函数。`malloc`申请内存失败会返回空。`free`只是清理了资源，并没有释放空间。
12. `do`、`for`、`while`
  循环语句的组成部分，C和C++都支持这3种循环。
13. 数值类型，如 `int`、`double`、`float`、`short`、`long`、`signed`、`unsigned`
　　`signed`和`unsigned`作为前缀修饰整数类型，分别表示有符号和无符号。`signed`和`unsigned`修饰`char`类型，构成`unsigned char`和`signed char`，和`char`都不是相同的类型；不可修饰`wchar_t`、`char16_t`和`char32_t`。其它整数类型的`signed`省略或不省略，含义不变。`signed`或`unsigned`可单独作为类型，相当于`signed int`和`unsigned int`。
　　`double`和`float`专用于浮点数，`double`表示双精度，精度不小于`float`表示的浮点数。`long double`则是C++11指定的精度不小于`double`的浮点数。
14. `if`和`else`
   条件语句的组成部分。if表示条件，之后else表示否定分支。
15. `enum`
  构成枚举类型名的关键字。
16. `explicit`
    该关键字的作用就是避免自定义类型隐式转换为类类型。
17. `export`
　　使用该关键字可实现模板函数的外部调用。对模板类型，可以在头文件中声明模板类和模板函数；在代码文件中，使用关键字export来定义具体的模板类对象和模板函数；然后在其他用户代码文件中，包含声明头文件后，就可以使用该这些对象和函数。
18. `extern`
  当出现`extern "C"`时，表示 `extern "C"`之后的代码按照C语言的规则去编译；当`extern`修饰变量或函数时，表示其具有外部链接属性，即其既可以在本模块中使用也可以在其他模块中使用。
19. `friend`
  友元。使其不受访问权限控制的限制。例如，在1个类中，私有变量外部是不能直接访问的。可是假如另外1个类或函数要访问本类的1个私有变量时，可以把这个函数或类声明为本类的友元函数或友元类。这样他们就可以直接访问本类的私有变量。
20. `inline`
     内联函数，在编译时将所调用的函数代码直接嵌入到主调函数中。各个编译器的实现方式可能不同。
21. `mutable`
　　`mutable`也是为了突破`const`的限制而设置的。被`mutable`修饰的变量，将永远处于可变的状态，即使在一个`const`函数中。
22. `namespace`
　　C++标准程序库中的所有标识符都被定义于一个名为`std`的`namespace`中。命名空间除了系统定义的名字空间之外，还可以自己定义，定义命名空间用关键字`namespace`，使用命名空间时用符号`::`指定。
23. `operator`　　
   和操作符连用，指定一个重载了的操作符函数，比如，operator+。
24. `public`、`protected`、`private`
   这三个都为权限修饰符。`public`为公有的，访问不受限制；`protected`为保护的，只能在本类和友元中访问；`private`为私有的，只能在本类、派生类和友元中访问。
25. `register`
　　提示编译器尽可能把变量存入到CPU内部寄存器中。
26. `return`：`return`表示从被调函数返回到主调函数继续执行，返回时可附带一个返回值，由return后面的参数指定。return通常是必要的，因为函数调用的时候计算结果通常是通过返回值带出的。如果函数执行不需要返回计算结果，也经常需要返回一个状态码来表示函数执行的顺利与否（-1和0就是最常用的状态码），主调函数可以通过返回值判断被调函数的执行情况.
27. `static`：可修饰变量（静态全局变量，静态局部变量），也可以修饰函数和类中的成员函数。static修饰的变量的周期为整个函数的生命周期。具有静态生存期的变量，只在函数第一次调用时进行初始化，在没有显示初始化的情况下，系统把他们初始化微0.
28. `sizeof`
   返回类型名或表达式具有的类型对应的大小。
29. `template`
    声明一个模板，模板函数，模板类等。模板的特化。
30. `this`
    每个类成员函数都隐含了一个`this`指针，用来指向类本身。`this`指针一般可以省略。但在赋值运算符重载的时候要显示使用。静态成员函数没有`this`指针。
31. `typedef`
    `typedef`声明，为现有数据类型创建一个新的名字。便于程序的阅读和编写。
32. `virtual`
    声明虚基类，虚函数。虚函数=0时，则为纯虚函数，纯虚函数所在的类称为抽象类。
33. `typeid`
    `typeid`是一个操作符，返回结果为标准库种类型的引用。
34. `typename`
    `typename`关键字告诉编译器把一个特殊的名字解释为一个类型。
35. `using`
     (1)、在当前文件引入命名空间，例`using namespace std`;
     (2)、在子类中使用，`using`声明引入基类成员名称。
36. `void`
    特殊的"空"类型，指定函数无返回值或无参数。

### 复合类型
C++中的复合类型是指基于其他类型定义的类型；C++语言中基本的复合类型有：引用(&)和指针(*);

引用(&)主要是为对象起了另外一个名字；注意引用类型的初始值必须是一个对象。
#### 指针
指针(*)也是间接指向另外一种类型的复合类型；但其相对引用有一下不同点：
    * 指针本身是一个对象，允许对指针赋值和拷贝;而且在指针的声明周期内它可以先后指向几个不同的对象
    * 指针无需在定义时赋值。和其它的内置类型一样，在块作用域内定义的指针如果没有初始化，也将拥有一个不确定的值。
指针操作中`&`操作符，表示取地址作用
```c++
  int ival=42;
  int *p=&ival;//p存放变量ival的地址,即p指针指向ival;

```
指针的值：
1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，意味着指针没有指向任何对象
4. 无效指针，上述情况之外的其它值。
注意：
1. 如果指针指向了一个对象；则允许使用解应用符`*`来访问对象。
2. 对于指针变量，初始化时可以使用NULL来方便内存分配判断；但是在C++11标准中对象指针使用nullptr;对于未初始化的int 等基本数据类型可以使用NULL;

#### void* 指针
void* 指针是C语言中的保留项目，它是一种特殊的指针类型；可以用于存放任意对象的地址；
但是因为void* 指针的不确定性，也意味着我们无法确定能够在这个对象上进行哪些操作。
注意：
```c++
  int* p1,p2;//p1指向int的指针；p2是int类型 

  int** pi//一个指向int指针的指针
```
#### const 关键字
##### const * int 和int *const、const int * cosnt、const int &
_参考链接：_[const int、const int *、int *cosnt、const int * const、const int &的区别](https://blog.csdn.net/itworld123/article/details/78967080);

- `const int *`:该指针变量指向的是常量，即该指针变量的内容可以改变，但是该内容指向的内容不可改变！;即底层const(常量指针)；（其与`const int *`相同）；
- `int *const`:声明该指针变量为常变量，即指针变量里面的内容不可改变，但是该内容指向的内容可以改变;即为常指针。
- `const int * cosnt`:指向一个内容不可变的指针，且指向对象地址不能变；
- `const int &`:在引用前面加上const，代表该引用为常引用，即被引用的对象不可改变。若是在形参中使用，则不可达到在函数里面修改变量值的目的。

`const`关键字修饰的变量会在编译的时候将定义的字符串替换掉，为了提高编译效率和防止文件冲突，默认状态下const对象仅在文件内有效；
注意：

 1. `const`是变量的值无法改变（有待商榷）；`static`是指变量直接在堆上分配内存，内存不会销毁，但是值可以改变；
 2. 当某一个文件中的const变量希望它能够在其它文件之间共享的时候；即在一个问价中定义const，而在其它多个文件中使用它，需要在`const`关键字前添加`extern`关键字；
 
##### constexpr和常量表达式
**常量表达式:（const expression）**是指不会改变并且在编译过程中就能得到计算结果的表达式；一个对象/表达式是不是常量表达式；由它的数据类型和初始值共同决定。例：
```c++
const int max_files=20;//max_files 是常量表达式

const int limit=max_files+1;//limit 是常量表达式

int staff_size=27;//staff_size 不是常量表达式

const int sz=get_size();//运行时才知道值，因此不是常量；
```
**constexpr变量**
C++11允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量移动是一个产量，而且必须用常量表达式初始化：
```c++
constexpr int mf=20;//20是常量表达式

constexpr int limit=mf+1;//mf+1是常量表达式

constexpr int sz=size();//只有当size是一个constexpr函数时才是一条正确的声明语句
```
**指针和constexpr**
在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指对象无关；
```c++
const int *p=nullptr;//p是一个指向整型常量的指针

constexpr int *q=nullptr;//q是一个指向整数的常量指针；constexpr把她所东一的对象置为了顶层const
```

#### 类型别名typedef关键字
- `typedef int my_int`:将`int `取别名为`my_int`;
- `typede 函数`：定义函数类型(常用语C语言中；C++慎用)；例：

```c++
typedef long SetStringPtr(char *);//预定于函数输入输出类型

typedef long GetStringPtr(char *, long);//预定于函数输入输出类型

typedef struct {
   SetStringPtr * SetString;//初始化函数指针

   GetStringPtr * GetString;//初始化函数指针
   DWORD          count;
   char           buffer[80];
} IExample;
//实例化函数
long SetString(char * str)
{
   return(0);
}

IExample * example;//使用结构体对象

example->SetString = SetString;//使用函数；
```

#### auto关键字；
auto关键字在C++11中得到了广泛使用；但是他是基于C++模板类型推断的，因此需要慎重使用；多用于循环迭代中；例：
```c++
#include <iostream>
#include <vector>
using namespace std;
int main(int arc,char const *argv[])
{
    std::vector<int> v={1,1,12,3};
    for(auto temp : v){
        std::cout<<temp<<'\t'<<std::endl;;
    }
    return 0;
}
```

#### decltype类型指示符
decltype 是C++11新引入的关键字，帮助从表达式推断定义的变量的类型。
注意：
1. decltype 处理顶层const和引用的方式与auto有些许不同；
2. 如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型，当有时返回一个引用类型的时候；表达式的结果对象，能够作为一条赋值语句的左值。
3. dectype((variable))(注意是双层括号)的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是。

```c++
const int ci=0,&cj=ci;
decltype(cj) x=0;//x 类型是const int

decltype(cj) y=x;//y的类型是const int&,y绑定到变量x

decltype(cj) z;//错误，z是一个引用必须初始化

//decltype 的结果可以是引用类型

int i=42，*p=&i,&r=i;
decltype(r+0) b;//加法的结果是int，因此b是一个（未初始化的）int

decltype(*p) c;//错误：c是int&,必须初始化

```

## 第三章 字符串、向量和数组

### 使用using name space
c++中使用`using name space ` 来进行命名空间的选择，但是一般不建议直接在声明中使用。建议使用`spacename:: function`的格式；例如`std::cout`;并且头文件中，不应该包括`using`声明。

### 标准库类型 string
下面展示string的常用初始化方法：

```c++
    std::string s1; //默认初始化，s1市一个空字符
    std::string s2=s1; //s2是s1的副本
    std::string s3="hiya";//s3市该字符串字面值的副本
    std::string s5("hiya");//s3是字面值“value”的副本，除了字面值最后的那个空字符除外
    std::string s4(10,'c'); //s4 的内容是cccccccccc
```
`os<<s`、`is>>s`；从字符串的输入，输出流。例如：

```c++
#include <iostream>
using namespace std;
int main(int argc, char const *argv[])
{
    string s;
    cin>>s; //将string 对象读入s,遇到空白停止
    cout<<s<<endl;//输出
    return 0;
}
```
`getline()`:读取函数整行，直到遇到换行符为止。
注意`string 对象的size()`函数返回值类型是`string::size_type`;当他与一个具有负号的n比较时，肯定为true，因此建议使用`auto`来进行返回值的定义。防止`int`和`unsigned`可能带来的问题。

#### 标准库string重点字符处理--<cctype>头文件

|函数名称|功能|
|:---:|:---|
|`isalnum(c)`|当c是字母或数字时为真|
|`isalpha(c)`|当c是字母时为真|
|`iscntrl(c)`|当c是控制字符时为真|
|`isdigit(c)`|当c是数字时为真|
|`isgraph(c)`|当c不是空格但可以打印时为真|
|`isalower(c)`|当c是小写字母时为真|
|`isprint(c)`|当c是可打印字符时为真|
|`ispunct(c)`|当c是标点符号时为真|
|`isspace(c)`|当c是空白时为真（空格，制表符、回车符、换行符、进纸符中的一种）|
|`issupper(c)`|当c是大写字母时为真|
|`isxdigit(c)`|当c是十六进制数字时为真|
|`tolower(c)`|转换字母为小写|
|`toupper(c)`|转换字母为大写|

使用示例：

```c++
string s("hello word !!!");
decltype(s.size()) punct_cnt=0;
for (auto c : s)//注意这里auto是拷贝无法改变其中的char的值，可以使用&c进行值的改变。
{
    if(ispunct(c))
    {
        ++punct_cnt;//标点负号计数值加1；
    }
    cout<<punct_cnt
        <<"punctuation characters in"<<s<<endl;
}
//输出结果
3 punctuation characters in hello word!!!
```
将输入十进制数字转化为十六进制：

```c++
#include <iostream>
#include <stack>
#include <sstream>
#include <string>
using namespace std;

int main(int argc, char const *argv[]) {
    const string test="0123456789ABCDEF";
    cout<<"please input number between 0 and 15"<<endl;
    string::size_type n, temp;//用于保存从输入流读取的数;
    while((cin.peek()!=EOF)&&(cin.peek()!='\n'))
    {
        cin>>n;
        string result;//用于保存十六进制的字符串
       //else if(n>test.size()){
            for(int i=n;i>0;){
                temp=i%16;
                auto s1 = test[temp];//转化为十六进制
                result=s1+result;
                i=i>>4;
            }
        printf("%X\n",n);
        std::cout<<"this result is :"<<result<<std::endl;
        //result.clear();
    }
    printf("hello word");
    return 0;
}
```
### vector 向量介绍
#### 迭代器(iterator)介绍
迭代器类似于指针但是不同于指针；利用地址进行一次间接的迭代访问。
标准迭代器的运算符：

|运算符|功能|
|:---:|:---:|
|*iter|返回迭代器iter所指元素的引用|
|iter->mem|解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem|
|++iter|令iter指示容器的下一个元素|
|--iter|令iter指示容器的上一个元素|
|iter1==iter2|判断是否指向同一个元素|
|iter1!=iter2|判断是否指向同一个元素|

```c++
string s("some string ");
if(s.begin()!=s.end())
{
    auto it=s.begin();//it表示s的第一个字符
    *it=toupper(*it);//当前字符改写成大写格式
}
```
注意：
1. c++中定义了箭头运算符：(`->`)把解引用和成员访问两个操作结合在一起，`it->mem`和`(*it).mem`表达的意思相同。
2. 两个迭代器相减结果是它们之间的距离。迭代器加整数还是迭代器。

### 数组

使用数组下标的时候，通常将其定义为`size_t`类型；
```c++
unsigned scores[11]={};//11个分数段，全部初始化为0
unsigned grade;
while(cin>>grade) {
    /* code */
    if (grade<=100)
    {
        /* code */
        ++scores[grade/10];//将当前分数段的计数值加1
    }
}
```
注意：
1. 数组中的 `int *parr[10]`表示含有10个整型指针的数组;`int (*parr)[10]`表示指向含有10个整数的数组的指针。`int *(&array)[10]`表示含有10个int型指针的数组的引用。

#### c 风格字符串
c++中支持c风格字符串，但是在c++程序中最好还是不要使用他们。因为字符串使用起来不太方便，而且极易产生程序内存泄露
c++中string对象使用c_str()函数，实现string对象到 char*[]的转换。
尽量使用标准类库而非数组。

#### 多维数组的初始化：
```c++
int ia[3][4]={
    //内嵌`{`并不是必须的但是，可以似的文件更加整洁，代码更加规范
    {0,1,2,3},
    {4,5,6,7},
    {8,9,10,11}
}
```

## 第四章 表达式
### 左值和右值问题
_参考链接_：[理解C和C++中的左值和右值](https://blog.csdn.net/xuwqiang1994/article/details/79924310);[C++11 左值、右值、右值引用详解](https://blog.csdn.net/hyman_yx/article/details/52044632);

左值：代表一个在内存中占有确定位置的对象(存在地址);例如`int a=0;`中`a`就是一个左值
右值：通过排他性来定义，每个表达式不是lvalue就是rvalue。因此从上面的lvalue的定义，rvalue是在不在内存中占有确定位置的表达式。

**左值引用**就是对一个左值进行引用的类型。**右值引用**就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。

右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。

左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。

```c++
int &a = 2; // 左值引用绑定到右值，编译失败 
int b = 2; // 非常量左值 
const int &c = b; // 常量左值引用绑定到非常量左值，编译通过 
const int d = 2; // 常量左值 
const int &e = c; // 常量左值引用绑定到常量左值，编译通过 
const int &b =2; // 常量左值引用绑定到右值，编程通过
```
右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值，例如：

```c++
int a;
int &&r1 = c;             # 编译失败
int &&r2 = std::move(a);  # 编译通过
```
![可引用类型值](https://img-blog.csdn.net/20160727131907698)

```c++
 // lvalues:
  //
  int i = 42;
  i = 43; // ok, i is an lvalue
  int* p = &i; // ok, i is an lvalue
  int& foo();
  foo() = 42; // ok, foo() is an lvalue
  int* p1 = &foo(); // ok, foo() is an lvalue

  // rvalues:
  //
  int foobar();
  int j = 0;
  j = foobar(); // ok, foobar() is an rvalue
  int* p2 = &foobar(); // error, cannot take the address of an rvalue
  j = 42; // ok, 42 is an rvalue
```

### 运算符优先级顺序

运算符优先级顺序如下表所示：

|运算符|功能|用法|
|:---:|:---:|:---:|
|`+`|一元正号|`+ expr`|
|`-`|一元负号|`- expr`|
|`*`|乘法|`expr * expr`|
|`/`|除法|`expr / expr`|
|`%`|求余|`expr % expr`|
|`+`|加法|`expr + expr`|
|`-`|减法|`expr - expr`|

注意

1. 使用数据类型赋值的时候不要超出类型的上界；例如：
```c++
short short_value=32767；//short类型占16位，则能表示的最大值是32767
short_value+=1;//该计算导致溢出，实际值：-32768
```
2. 如果`m%n`不等于0，则它的负号和`m`相同
3. 赋值运算符`=`的左侧运算对象必须是一个可以修改的左值。

### 位运算符
位运算符主要使用方法如下表：

|运算符|功能|用法|
|:---:|:---:|:---:|
|`~`|位求反|`~ expr`|
|`<<`|左移，相当于乘`2^n`|`expr1 >> expr2`|
|`>>`|右移，相当于除`2^n`|`expr1 >> expr2`|
|`&`|位与|`expr & expr`|
|`^`|位异或|`expr ^ expr`|
|`"|"`|位或|`"expr|expr"` |


### `sizeof`运算符

`sizeof`来进行对象或者类型名称所占用的字节数目

### 类型转换
_参考链接：_ [C++强制类型转换：static_cast、dynamic_cast、const_cast、reinterpret_cast](https://www.cnblogs.com/chenyangchun/p/6795923.html);[C++ 类型转换（C风格的强制转换）](https://www.cnblogs.com/Allen-rg/p/6999360.html);

c++中的隐式类型转换，已经在之前介绍过了，同时c++中还存在显示的强制类型转换`cast-name<type>(expression)`；其中`cast-name`是指：`static_cast`、`dynamic_cast`、`const_cast`和`reinterpret_cast`

|名称|区别|
|:---:|:---:|
|`static_cast`|静态强制转换，编译时就转换|
|`dynamic_cast`|动态强制转换，运行时转换|
|`const_cast`|编译时进行检查，强制消除对象的常量性|
|`reinterpret_cast`|编译时进行检查，是特意用于底层的强制转型，主要用于二进制的强制类型转换|

* `static_cast` 

`static_cast`相当于传统的C语言里的强制转换，该运算符把expression转换为new_type类型，用来强迫隐式转换，例如non-const对象转为const对象，编译时检查，用于非多态的转换，可以转换指针及其他，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：
  1. 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。
      - 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；
      - 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。
  2. 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
  3. 把空指针转换成目标类型的空指针。
  4. 把任何类型的表达式转换成void类型。

注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。

* `dynamic_cast`

主要用于执行“安全的向下转型(safe downcasting)”，也就是说，要确定一个对象是否是一个继承体系中的一个特定类型。支持父类指针到子类指针的转换，这种转换时最安全的转换。它 是唯一不能用旧风格语法执行的强制类型转换，也是唯一可能有重大运行时代价的强制转换。
  1. 其他三种都是编译时完成的，`dynamic_cast`是运行时处理的，运行时要进行类型检查。
  2. 不能用于内置的基本数据类型的强制转换。
  3. `dynamic_cast`转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。
  4. 使用`dynamic_cast`进行转换的，基类中一定要有虚函数，否则编译不通过。B中需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表（关于虚函数表的概念，详细可见<Inside c++ object model>）中。只有定义了虚函数的类才有虚函数表。
  5. 要求<>内部所描述的目标类型必须为指针或引用。
  6. 在类的转换时，在类层次间进行上行转换时，`dynamic_cast`和`static_cast`的效果是一样的。在进行下行转换时，`dynamic_cast`具有类型检查的功能，比`static_cast`更安全。
    - 向上转换，即为子类指针指向父类指针（一般不会出问题）；向下转换，即将父类指针转化子类指针。
    - 向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。
    - 在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。Dynamic_cast操作符则可以在运行期对可能产生问题的类型转换进行测试。

* const_cast
  
 而`const_cast`则正是用于强制去掉这种不能被修改的常数`const`特性，但需要特别注意的是`const_cast`不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。
 1. 该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。
 2. 常量指针被转化成非常量指针，并且仍然指向原来的对象；
 3. 常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。
 4. const_cast强制转换对象必须为指针或引用
 5. const_cast一般用于修改底指针。如const char *p形式

* reinterpret_cast

是特意用于底层的强制转型，导致实现依赖（就是说，不可移植）的结果，例如，将一个指针转型为一个整数。这样的强制类型在底层代码以外应该极为罕见。操作 结果只是简单的从一个指针到别的指针的值得二进制拷贝。在类型之间指向的内容不做任何类型的检查和转换。
new_type必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，再把该整数转换成原类型的指针，还可以得到原先的指针值）。

##### 运算符优先级表格如下


<table>
    <thead>
        <tr>
            <th>优先级 </th>
            <th>运算符 </th>
            <th>说明  </th>
            <th>结合性 </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>1</td>
            <td>::</td>
            <td>范围解析</td>
            <td rowspan="6">自左向右</td>
        </tr>
        <tr>
            <td rowspan="5">2</td>
            <td>++ - - </td>
            <td>后缀自增/后缀自减</td>
        </tr>
        <tr>
            <td>()</td>
            <td>括号</td>
        </tr>
        <tr>
            <td>[]</td>
            <td>数组下标</td>
        </tr>
        <tr>
            <td>.</td>
            <td>成员选择(对象)</td>
        </tr>
        <tr>
            <td>-&gt;</td>
            <td>成员选择(指针)</td>
        </tr>
        <tr>
            <td rowspan="9">3</td>
            <td>++ - -</td>
            <td>前缀自增/前缀自减</td>
            <td rowspan="9">自右向左</td>
        </tr>
        <tr>
            <td>+ -</td>
            <td>加减</td>
        </tr>
        <tr>
            <td>! ~</td>
            <td>逻辑非/按位取反</td>
        </tr>
        <tr>
            <td>(type)</td>
            <td>强制类型转换</td>
        </tr>
        <tr>
            <td>*</td>
            <td>取指针指向的值</td>
        </tr>
        <tr>
            <td>&amp;</td>
            <td>某某的地址</td>
        </tr>
        <tr>
            <td>sizeof</td>
            <td>某某的大小</td>
        </tr>
        <tr>
            <td>new,new[]</td>
            <td>动态内存分配/动态数组内存分配</td>
        </tr>
        <tr>
            <td>delete,delete[]</td>
            <td>动态内存分配/动态数组内存释放</td>
        </tr>
        <tr>
            <td>4</td>
            <td>.* -&gt;* - -</td>
            <td>成员对象选择/成员指针选择</td>
            <td rowspan="12">自左向右</td>
        </tr>
        <tr>
            <td>5</td>
            <td>* / %</td>
            <td>乘法/除法/取余</td>
        </tr>
        <tr>
            <td>6</td>
            <td>+ -</td>
            <td>加号/减号</td>
        </tr>
        <tr>
            <td>7</td>
            <td>&lt;&lt; &gt;&gt;</td>
            <td>位左移/位右移</td>
        </tr>
        <tr>
            <td rowspan="2">8</td>
            <td> &lt; &lt;=</td> 
            <td>小于/小于等于</td>
        </tr>
        <tr>
            <td> &gt; &gt;=</td> 
            <td>大于/大于等于</td>
        </tr>
        <tr>
            <td>9</td>
            <td>== !=</td>
            <td>等于/不等于</td>
        </tr>
        <tr>
            <td>10</td>
            <td>&amp;</td>
            <td>按位与</td>
        </tr>
        <tr>
            <td>11</td>
            <td>^</td>
            <td>按位异或</td>
        </tr>
        <tr>
            <td>12</td>
            <td>|</td>
            <td>按位或</td>
        </tr>
        <tr>
            <td>13</td>
            <td>&amp;&amp;</td>
            <td>与运算</td>
        </tr>
        <tr>
            <td>14</td>
            <td>||</td>
            <td>或运算</td>
        </tr>
        <tr>
            <td>15</td>
            <td>?:</td>
            <td>三目运算符</td>
            <td rowspan="7">自右向左</td>
        </tr>
        <tr>
            <td rowspan="5">16</td>
            <td>=</td>
            <td>赋值</td>
        </tr>
        <tr>
            <td>+= -=</td>
            <td>相加后赋值/相减后赋值</td>
        </tr>
        <tr>
            <td>*= /= %=</td>
            <td>相乘后赋值相值/取余后赋值</td>
        </tr>
        <tr>
            <td>&lt;&lt;= &gt;&gt;=</td>
            <td>位左移赋值/位右移赋值</td>
        </tr>
        <tr>
            <td>&amp;= ^= |=</td>
            <td>位与运算后赋值/位异或运算后赋值/位或运算后赋值</td>
        </tr>        
        <tr>
            <td>17</td>
            <td>throw</td>
            <td>抛出异常</td>
        </tr>        
        <tr>
            <td>18</td>
            <td>,</td>
            <td>逗号</td>
            <td>自左向右</td>
        </tr>
    </tbody>
</table>

## 第五章 语句
没什么好写的。

## 第六章 函数

###  函数基础

在函数中可以使用`static`来进行静态局部变量的全局作用域。使得局部变量的生存周期可以一直持续到程序结束。
注意当使用指针作为函数传入参数的时候，函数内部会拷贝传入参数指针，指针不同但是指向的地址和变量相同。当使用引用时，是传给函数使用对象的另外一个名字。因此在函数参数传递时应该，尽量使用引用参数。如下：

```c++
bool isShorter(const string &sl;const string &s2)
{
    return s1.size()<s2.size();
}

int  main(int argc,char *argv[])
{

}

//第二个形参argv是一个数组，它的元素是指向c风格字符串的指针；因为第二个形参是数组，所以main函数也可以定义成：

int main(int argc, char const **argv) {
    /* code */
    return 0;
}


```


### initialzer_list 形参

当函数的实参数量未知；但是全部实参的类型相同，我们可以使用initializer_list类型的形参。详细描述如下表：

|操作|解释|
|:---|:---|
|`initializer_list <T> lst`|默认初始化；类型的空列表|
|`initializer_list <T> lst {a,b,c...}`|lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中的元素是const|
|`lst2(lst) or lst2=lst`|拷贝复制一个元素|
|`lst.size()`|列表中的元素数量|
|`lst.begin()`|返回指向lst中首元素的指针|
|`lst.end()`|返回指向lst中尾元素下一位置的指针|


下面是代码示例：
```c++
void error_msg(initializer_list<string> il)
{
    for(auto beg=il.begin();beg!=il.end();++beg)
    {
        cout<<*beg<<" ";//连续输出错误的函数信息
    }
    cout<<endl;

}

```

#### 省略符形参

为了方便c++程序访问某些特殊的c代码而设置的，这些大妈使用了名为`varargs`的c标准库功能。

```c++

void foo(parm_list,...);
void foo(...);

```
#### 值是如何被返回的
返回复制一个临时变量，该临时变量就是函数调用的结果。
注意：
1. 不要返回局部对象的引用或者指针，因为局部变量的引用和指针会随着局部变量的结束而终止，因此，返回的引用和指针会不在有效的内存区域内。
2. 函数的返回类型决定函数是否是左值，调用一个返回引用的函数得到左值，其它返回类型得到右值。
3. 数组不能被返回，但是函数可以通过返回数组指针来进行返回操作。
4. c++11新标准，允许使用尾置返回类型；或者使用`decltype`声明返回指针的类型；例如：
    
```c++
    //func 接受一个int类型的实际参数，返回一个指针，该指针指向含有10个整数的数组
    
    auto funct(int i) -> int(*)[10];
    int odd[]={1,3,5,7,9};
    int odd[]={2,4,6,8,10};

    decltype(odd) *arrPtr(int i)
    {
        return (i%2)?&odd:&even;//返回一个指向数组的指针

    }
```

#### 函数重载(overloaded 和over)

_参考链接：_ [C++的重载(overload)与重写(override)](https://www.cnblogs.com/luxiaoxun/archive/2012/08/09/2630751.html)；[C++中 overload 、override、overwrite 之间的区别](https://blog.csdn.net/qq_34793133/article/details/80938099);

因为c++是强类型语言，因此当相同函数名称处理不同的输入数据时需要设置多个函数，实现相同函数名称的查找匹配最佳值。这一点c++中的模板很好的解决了这个问题，但是函数的重载也很好的解决了这个问题。例如：

```c++
//定义重载函数

void print(const char *cp);//函数1

void print(const int *beg,const int *end);//函数2

void print(const int ia[],size_t size);//函数3

//接受参数不同，使用也不相同

int j[2]={0,1};

print("Hello word ");//调用函数1

print(j,end(j),-begin(j));//调用函数2

print(begin(j),end(j));//调用函数3

```
注意：

1. `main`函数不能重载。
2. c++中函数名字查找发生在类型检查之前。因此建议，函数重载，针对不同输入直接取名不同。
3. 当函数传入参数是拷贝传递时`const int a`与`int a`是同一个函数，即重写了前一个函数。当使用`&`作为引用参数时，使用`const`为新参数。例如`int &a`与`const int &a`是两个不同的函数。
4. 注意当查找同名函数时，编译器首先查找当前作用域(局部作用域)内的同名函数。

##### overload 、override、overwrite 之间的区别

##### Overload  重载
在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数不同（包括类型、顺序不同），即**函数重载**。条件：

- 相同的范围(在同一个类中)
- 函数名字相同
- 参数不同
- 重载解析中不考虑返回类型，而且在不同的作用域里声明的函数也不算是重载。重载可以理解为一个类内部的函数重载

#####  Override 覆盖
是指派生类函数覆盖基类函数，实际上是c++多态的衍生品；特征是：

- 不同的范围(分别位于派生类与基类)
- 函数名字相同；
- 参数名字相同
- 基类函数必须有`virtual`关键字。

示例：

```c++
#include <iostream>
using namespace std;
class base
{
  public:
  virtual void Fun1()
    {
        
        cout<<"Base Fun1..."<<endl;
     }
 
      virtual void Fun2()
     {
         cout<<"Base Fun2..."<<endl;
     }
 
      void Fun3()
    {
        
        cout<<"Base Fun3..."<<endl;
     }
};
 
class Derived:public Base
{
   public:
   void Fun1()
    {
        
        cout<<"Derived Fun1..."<<endl;
     }
 
    void Fun1()
    {
        
        cout<<"Derived Fun2..."<<endl;
     }
 
      void Fun3()
    {
        
        cout<<"Derived Fun3..."<<endl;
     }
};
 
 
int main()
{
  Base* p;
  Derived d;
  p=&d;
 
 p->Fun1();  //因为Fun1是虚函数，所以调p指向的对象的Fun1

 p->Fun2();   //同Fun1
 
 p->Fun3();   //Fun3不是虚函数，所以根据指针的类型，是基类指针，调基类的Fun3
  
return 0;
}
/*
结果：
Derived Fun1...
Derived Fun2...
Base Fun3...
*/
```
#####  overwrite：重定义
是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
    
- 如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无`virtual`关键字，基类的函数将被隐藏。
- 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有`virtual`关键字。此时，基类的函数被隐藏（注意别与覆盖混淆)
- 重定义分两种：
    + 对基类数据成员的重定义：不改变基类的数据成员，改变派生类的数据成员。
    + 对基类成员函数的重定义
        * 派生类的成员函数与基类完全相同；基类中的函数被隐藏
        * 派生类的成员函数与语言基类成员函数名相同但参数不同；使用派生类的函数，如果要方位基类方法使用`<class_name>.Base::<function>`或者`<class_name>.Base::<成员变量名>`；


#### 特殊用途语言实参
c++中存在特殊用途的语言实参：

##### 默认实参
函数可以使用默认初始值，这点称为默认实参例如：`string function1(int hz=24,int wid=80,char backgrnd='n');`
注意：

1. 默认实参最好放在头文件中
2. 已经给予初始值的默认实参不得再定义初始值，只能给未定义的给予初始值；重复声明会发生错误。

##### 内联函数和`constexpr`函数

内联函数说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求，在编译时将其替换。可以多次定义

`constexpr`函数用于指示常量表达式。

##### 帮助调试
c++中有许多帮助调试的信息；其中包括`assert`预处理宏；在`<assert>`头文件中定义。`assert(expr)`中判断表达式为假时，函数终止。
同时还存在NDEBUG预处理变量;使用静态预处理变量，说明当前文件信息。

|关键字|作用|
|:---:|:---|
|`__FILE__`|存放文件名字的字符串字面值|
|`__LINE__`|存放当前行号整形字面值|
|`__TIME__`|存放编译时间字符串字面值|
|`__DATE__`|存放编译日期字符串字面值|

例如：

```c++

#include <iostream>
using namespace std;

int main(void)
{
    std::cout<<"function name"<<__func__<<"\n";
    std::cout<<"file name "<<__FILE__<<"\n";
    std::cout<<"line "<<__LINE__<<"\n";
    std::cout<<"time"<<__TIME__<<"\n";
    return 0;
}
/*输出：
function namemain
file name test.cpp
line 8
time20:39:05
*/

```
#### 函数指针
指针的实质是指向内存的地址的一个变量，函数存在于堆栈中，因此指针也可以指向函数，成为函数指针。例如：

```c++

//定义函数function2

bool function2(const string &,const string &);
//定义指针指定输入参数的指针

bool *pf(const string &,const string &);

pf=function2;//将指针pf指向lengthCompare的函数

auto b1=pf("hello","goodbye");//调用函数

auto b2=(*pf)("hello","goodbye");//一个等价的调用

//使用指针函数，方便我们在某些状况下使用指定的重载函数，避免产生隐式转换的错误

void ff(int* )//重载函数1

void ff(unsigned int)//重载函数2

//定义函数指针，并初始化
void (*pf1)(unsigned int )=ff;

```
我们也可以使用函数指针，作为函数返回值，指向一个函数；只要返回类型写成指针形式。使用类型别名可以声明一个返回函数指针的函数。

```c++
using F=int(int*,int);//F是函数类型，不是指针

using PF=int(*)(int *,int);//PF是指针类型


PF f1(int);//正确：PF是指向函数的指针，f1返回指向函数的指针

F f1(int); //错误：F是函数类型，f1不能返回一个函数

F *f1(int)；//正确：显式地指定返回类型是指向函数的指针

```
## 类

### 定义抽象数据
c++中类的实质就是数据的抽象实现和封装。抽象数据依赖于接口和实现，分离的编程技术；**定义在函数内部的函数是隐式的inline函数**

#### 类中的this关键字
_参考链接：_ [C++类中this指针的理解](https://www.cnblogs.com/liushui-sky/p/5802981.html); [C++ this 指针](https://www.runoob.com/cplusplus/cpp-this-pointer.html);[关于this指针](https://blog.csdn.net/shidantong/article/details/80104710);

首先声明`this`指针是c++为了方便管理类中的函数而产生的，每个对象的`this`指针都指向对象本身，可以使用对象的非静态方法。`this`指针是编译器给予的每个成员函数的隐含参数，用来指向调用对象。
注意：

1. 友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。
2. this指针其本身的内容是不能被改变的，其类型为：**类类型 * const**
3. this指针不是对象本身的一部分，不影响该对象的大小
4. this指针的作用域在类的 **非静态成员函数**的内部，只能在其内部进行使用，其他任何函数都不能，静态成员函数内部无this指针，后面会详述。
5.  this指针是类中非静态成员函数的第一个默认隐含参数，编译器自动传递和维护，用户不可显示传递
6.  this指针可以为空但是类内部的成员变量数据不能为空，因此当调用使用成员变量时，请确保成员变量不为空。

函数调用约定如下：

![函数调用约定表](https://img-blog.csdn.net/20180426163408707?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaWRhbnRvbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

_thiscall关键调用：

- 它只能用在类的成员函数上
- 参数从右向左进行压栈
- 若参数个数确定，this指针通过ecx寄存器传递给被调用者；若参数不确定，this指针在所有参数被压栈后压入堆栈
- 对于参数不确定的函数，调用者清理堆栈，否则函数自己清理堆栈。

##### 构造函数
构造函数主要是c++中对于类对象的实例化的函数,这里需要强调一下c++中`new A`、`new A()`与`new A[]`的区别；

_参考链接：_ [C++中new 一个对象的时候加括号和不加括号的区别](https://blog.csdn.net/ywending/article/details/51096547);[C++ new A 和 new A() 的区别详解以及引申的各种初始化类型](https://blog.csdn.net/qq_34228570/article/details/79549958);

先说结论：

-  加括号调用没有参数的构造函数，不加括号调用默认构造函数或唯一的构造函数，看需求。
-  **C++在new时的初始化的规律可能为：对于有构造函数的类，不论有没有括号，都用构造函数进行初始化；如果没有构造函数，则不加括号的new只分配内存空间，不进行内存的初始化，而加了括号的new会在分配内存的同时初始化为0。**

POD(Plain old data):它是一个struct或者类，且不包含构造函数、析构函数以及虚函数。POD class没有用户定义的析构函数、拷贝构造函数和非静态的非POD类型的数据成员。而且，POD class必须是一个aggregate，没有用户定义的构造函数，没有私有的或者保护的非静态数据，没有基类或虚函数。它只是一些字段值的集合，没有使用任何封装以及多态特性。

对于`[new] T [object] {};`初始化一般有三种处理方式：

- 如果T有用户定义的缺省构造函数，直接调用；
- 如果T有编译器生成的缺省构造函数，先0值初始化再调用；
- 如果T根本不是类，直接0值初始化。

对于`[new] T object;`如果T是非class类型，则给出非确定值（不赋值），比如：`int i; double d; bool b;`；
0值初始化也单独作用于静态(或者线程局部）变量：`static T object;`

五种初始化类型：

- list initialization (since C++11) 
- aggregate initialization 这是list initialization对aggregate类型的特例 
- value initialization 值初始化 
- default initialization 缺省初始化 
- zero initialization 0值初始化

示例代码：

```c++
#include <iostream>  

using namespace std;

class A { public:int m; }; // POD  

class B { public:~B() {}; int m; }; // non-POD, compiler generated default ctor  

class C { public:C() :m() {}; ~C() {}; int m; }; // non-POD, list-initialising m

class D { public:D() {}; ~D() {}; int m; };  // non-POD，default-initialising m

int main()
{
    A *aObj1 = new A;
    A *aObj2 = new A();
    cout << aObj1->m << endl;
    cout << aObj2->m << endl;

    B *bObj1 = new B;
    B *bObj2 = new B();
    cout << bObj1->m << endl;
    cout << bObj2->m << endl;

    C *cObj1 = new C;
    C *cObj2 = new C();
    cout << cObj1->m << endl;
    cout << cObj2->m << endl;

    D *dObj1 = new D;
    D *dObj2 = new D();
    cout << dObj1->m << endl;
    cout << dObj2->m << endl;

    delete aObj1;
    delete aObj2;
    delete bObj1;
    delete bObj2;
    delete cObj1;
    delete cObj2;

    getchar();
    return 0;
}
/*result


-842150451
0
-842150451
0
0
0
-842150451
-842150451
注意不同编译器可能产生不同的结果，GCC中结果：
0
0
38158368
0
0
0
38158400
0
结论（以GCC为准）：
new A：0

new A()：0

new B：不确定的值

new B()：0

new C：0

new C()：0

new D：不确定的值

new D()：0

*/


```

注意：
1. 只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。
2. 可以在构造函数之后添加`=default`来要求编译器生成默认构造函数。

### 访问控制与封装
访问说明符`public`、`private`、`protect`来加强类的封装性。注意`struct`关键字中定义第一个访问说明符之前的成员是`public`，如果使用`class`关键字，成员是`private`的。因此当希望所有的类成员是`public`时使用`struct`；希望是`private`时使用`class`。

**友元(friend)**:类允许其他类或者函数访问它的非公有成员，将函数成为友元只需要增加一条`friend`关键字就可以了。注意友元函数，必须在友元声明之外再专门对函数进行一次声明。

定义类型的成员必须先定义后使用例如：

```c++
class Screen
{
public:
    //使用类型别名等价地声明一个类型名字

    typedef std::string::size_type pos;
    Screen();
    ~Screen();
private:
    pos cursor=0;
    pos height=0,width=0;
    std::string contents;
    
};
```
类的友元使用示例如下

```c++
//screen.cpp

class Screen
{
public:
    //使用类型别名等价地声明一个类型名字

    typedef std::string::size_type pos;
    Screen();
    ~Screen();
    //定义友元

    //Windows类可以访问Screen类的私有部分

    friend class Windows;
    //成员函数作为友元

    friend void Windows::clear(ScreenIndex);

private:
    pos cursor=0;
    pos height=0,width=0;
    std::string contents;
    
}

//windows.cpp

class Windows
{
public:
    //窗口中每个屏幕的编号

    using ScreenIndex=std::vector<Screen>::size_type;
    //按照编号将指定的Screen重置为空白
private:
    
    std::vector<Screen> screen{screen(24,80,'')};

public:
    void clear(ScreenIndex i)
    {
        //s是一个Screen的引用，指向我们想清空的那个平米

        Screen &s=screen[i];

        //将那个选定的Screen重置为空白

        s.contents=string(s.height*s.width,'');
    }
}

```
注意：

1. 友元的函数未声明直接出现时，我们隐式的假定该名字在当前作用域中是可见的，要想正常使用，该函数必须先被定义过。


**`mutable`**关键字： 类成员变量使用`mutable`关键字即便是`const`对象也能更改类的成员变量。

类的成员函数后添加`const`关键字，表示不会修改类中的成员变量；并且有一下几点规则：

1. 在类中被const声明的成员函数只能访问const成员函数，而非const函数可以访问任意的成员函数，包括const成员函数
2. 在类中被const声明的成员函数不可以修改对象的数据，不管对象是否具有const性质，它在编译时，以是否修改成员数据为依据，进行检查。
3. 加上mutable修饰符的数据成员，对于任何情况下通过任何手段都可修改，自然此时的const成员函数是可以修改它的

**向前声明：** 仅仅声明类而不去定义它。对于类而言，当类的名字出现过后，它就被认为是声明过了（但是尚未定义），因此类允许包含指向它自身类型的引用或者指针。例如：

```c++
class Link_screen
{
    Screen windows;
    Link_screen *next;
    Link_screen *prev;
}

```

**类中普通块作用域的名字查找**

- 首先，成员函数内查找该名字的声明，只有在函数使用之前出现的声明才被考虑。
- 如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑
- 如果类内也没有找到该名字的声明，在成员函数定义之前的作用域内继续查找。
- 类作用域之后，在外围的作用域中查找；如果编译器在函数和类的作用域中都没有找到名字，它将接着在外围的作用域中查找

### 构造函数再探

如果成员是是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。最好令构造函数初始值的顺序与成员声明的顺序保持一致；而且如果有可能的话，尽量避免使用某些成员变量初始化其他成员。

注意：成员的初始化顺序与他们在类中定义的出现顺序一致；第一个成员先被初始化，然后第二个

```c++
class X
{
    int i;
    int j;
public:
    X(int val):j(val),i(j){}

    //错误：i在j之前被初始化，因此初始化i之前发生错误，j未定义。
}

```

#### 委托构造函数

C++中可以使用委托构造函数，即预定义一个基础的构造函数其它的构造函数可以调用这个构造函数。

#### 隐式的类类型转换与转换避免。
c++语言之间存在隐式的转换规则；构造函数实际上也定义了转换为此类类型的隐式转换机制。我们将这种构造函数称之为 **转换构造函数**；隐式转换，相当于构造了一个临时的变量对象。再给类一个临时成员变量。但是这种转换只允许一步类型转换，并且类型转换并不是总有效。
为了防止这种状况的发生，我们在单参数构造函数前面添加`explicit`关键字使得构造函数只能直接初始化。但是使用`static_cast`强制类型转化可以使用带有`explicit`关键字的构造函数。

#### 聚合类
聚合类中可以使得用户直接访问其成员，并且具有特殊的初始化语法形式。聚合类的特征：

- 所有成员都是public的
- 没有定义任何构造函数
- 没有类内初始值
- 没有基类，也没有`virtual`函数

例如：

```c++
struct Data
{
    int ival;
    string a;
};
//这就是一个聚合类
```

注意：显示地初始化类的对象的成员存在三个明显的缺点

- 要求类的所有成员都是`public`的。
- 将正确初始化每个对象的每个成员的重任交给了类的用户。因为用户很容易忘掉某个初始值，或者提供一个不恰当的初始值，所以这样的初始化过程冗长乏味且容易出错。
- 添加或者删除一个成员之后，所有的初始化语句都需要重新更新。

#### 字面常量类

要求：

- 数据成员都必须是字面类型值
- 类必须至少含有一个`constexpr`构造函数
- 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；如果成员属于某种类型，则初始值必须使用成员自己的`constexpr`构造函数。
- 类必须使用析构函数的默认定义，该成员负责销毁类的对象。

#### `constexpr`构造函数

首先需要明确构造函数不能是`const`的，因为const修饰函数表示该函数的返回值是const类型的，改返回值只能赋值给同类型的const变量，不符合类的构造函数的需求。const是可以修饰类的成员函数，但是该函数不能修改数据成员。构造函数也属于类的成员函数，但是构造函数是要修改类的成员变量，所以类的构造函数不能申明成const类型的。

但是字面常量类的构造函数时可以`constexpr`的函数，实际上一个字面值常量类必须至少提供一个`constexpr`构造函数。并且该构造函数一般是空的。因为它必须符合构造函数的要求--不能存在返回值；又符合`constexpr`函数要求--能拥有的唯一可执行语句就是返回语句。示例如下;

```c++
class Debug {
private:
    /* data */
public:
    constexpr Debug(bool b=true):hw(b),io(b),other(b){};
    constexpr Debug(bool h,bool i,bool o):hw(h),io(i),other(o){};
    constexpr bool any(){return hw || io || other;}
    //.....
};

```

#### 类的静态成员

##### c++中的内存分配
_参考链接：_ [C/C++程序内存的分配](https://blog.csdn.net/cherrydreamsover/article/details/81627855)；[【C++】动态内存分配详解（new/new[]和delete/delete[]）](https://blog.csdn.net/qq_40416052/article/details/82493916);

首先c/c++中内存分为以下几种类型

- 栈(stack):由编译器自动分配与释放，存放为运行时函数分配的局部变量、函数参数、返回数据、返回地址等。其操作类似于数据结构中的栈。
- 堆区（heap）：一般由程序员自动分配，如果程序员没有释放，程序结束时可能有OS回收。其分配类似于链表。
- 全局区（静态区static）：存放全局变量、静态数据、常量。程序结束后由系统释放。全局区分为已初始化全局区（data）和未初始化全局区（bss）。
- 常量区（文字常量区）：存放常量字符串，程序结束后有系统释放。
- 代码区：存放函数体（类成员函数和全局区）的二进制代码。

具体的内存分配如下：

![程序内存分配](https://img-blog.csdn.net/20180813110942795?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXJyeWRyZWFtc292ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70);

注意：栈的地址由高到低，堆的地址由低到高。

**内存分配的方式**

1. 从静态存储区分配：内存在程序编译的时候已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。
2. 在栈上创建：在执行函数时，函数内局部变量的存储单元可以在栈上创建，函数执行结束时，这些内存单元会自动被释放。栈内存分配运算内置于处理器的指令集，效率高，但是分配的内存容量有限。
3. 从堆上分配： 亦称为动态内存分配。
 - 程序在运行的时候使用malloc或者new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。
 - 动态内存的生命周期有程序员决定，使用非常灵活，但如果在堆上分配了空间，既有责任回收它，否则运行的程序会出现内存泄漏，频繁的分配和释放不同大小的堆空间将会产生内存碎片。
4. 在 C 语言中，全局变量又分为初始化的和未初始化的（未被初始化的对象存储区可以通过 void* 来访问和操纵，程序结束后由系统自行释放），在 C++ 里面没有这个区分了，他们共同占用同一块内存区。

**堆和栈的区别**

1. **管理方式不同**：栈是由编译器自动申请和释放空间，堆是需要程序员手动申请和释放；
2. **空间大小不同**：栈的空间是有限的，在32位平台下，VC6下默认为1M，堆最大可以到4G；
3. **能否产生碎片**：栈和数据结构中的栈原理相同，在弹出一个元素之前，上一个已经弹出了，不会产生碎片，如果不停地调用malloc、free对造成内存碎片很多；
4. **生长方向不同**：堆生长方向是向上的，也就是向着内存地址增加的方向，栈刚好相反，向着内存减小的方向生长。
5. **分配方式不同**：堆都是动态分配的，没有静态分配的堆。栈有静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。
6. **分配效率不同**： 栈的效率比堆高很多。栈是机器系统提供的数据结构，计算机在底层提供栈的支持，分配专门的寄存器来存放栈的地址，压栈出栈都有相应的指令，因此比较快。堆是由库函数提供的，机制很复杂，库函数会按照一定的算法进行搜索内存，因此比较慢。

**静态全局变量、全局变量区别**

- 静态全局变量和全局变量都属于常量区 
- 静态全局区只在本文件中有效，别的文件想调用该变量，是调不了的，而全局变量在别的文件中可以调用。
- 如果别的文件中定义了一个该全局变量相同的变量名，是会出错的。

**静态局部变量、局部变量的区别**

- 静态局部变量是属于常量区的，而函数内部的局部变量属于栈区
- 静态局部变量在该函数调用结束时，不会销毁，而是随整个程序结束而结束，但是别的函数调用不了该变量，局部变量随该函数的结束而结束； 
- 如果定义这两个变量的时候没有初始值时，静态局部变量会自动定义为0，而局部变量就是一个随机值
- 静态局部变量在编译期间只赋值一次，以后每次函数调用时，不在赋值，调用上次的函数调用结束时的值。局部变量在调用期间，每调用一次，赋一次值。

通过以上基础知识我们知道c++的静态成员都是直接在静态全局区域分配内存。因此在编译时就已经内存就已经开始分配成功了，因此不需要实例化类并且解引用，可以直接使用。
# 第II部分 C++ 标准库

## 第8章 IO库

C++中没有直接的输入和输出库，而是使用标准库的IO库来进行IO操作，下面让我们进入IO的世界吧

### 8.1 IO类
IO基本类和头文件如下表：

IO库的类型和对应头文件

|头文件|类型|
|:---|:---|
|`iostream`|`istream,wistream` 从流读取数据；`ostream,wostream` 从流输出数据；`iostream,wiostream`读写流|
|`fstream`|`ifstream,wifstream` 从文件读取数据；`ofstream,wofstream` 从文件写入数据；`fstream,wfstream` 读写文件；|
|`sstream`|`istringstream,wistringstream`从`string`读取数据;`ostringstream,wostringstream`向`string`写入数据;`stringstream,wstringstream` 读写`string`|

注意：

- IO对象无拷贝或者赋值--通过重载拷贝构造函数和赋值操作，禁止拷贝和赋值；或者**将拷贝构造函数与赋值函数，声明为private，并且不给出实现**
- 在函数后面使用`=delete`；例如：`NoCopyable(const NoCopyable&) = delete;`;其中
delete表明函数已删除。使用会报错："尝试使用已删除的函数";（参考：[C++禁止对象拷贝](https://blog.csdn.net/qqqqqqqqqq1qqqqqqqqq/article/details/46006791)）

**c++中的浅拷贝和深拷贝**

_参考链接：_ [C++本质：类的赋值运算符=的重载，以及深拷贝和浅拷贝](https://www.cnblogs.com/zsq1993/p/5791130.html)；[C++的拷贝构造函数、operator=运算符重载，深拷贝和浅拷贝、explicit关键字](https://blog.csdn.net/shine_journey/article/details/53081523)；

c++默认的拷贝构造函数和赋值运算符都是简单的浅拷贝，直接使用其它变量初始化对象，并没有重新分配内存，**但是如果实行浅拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。**因此类的成员变量需要动态开辟堆内存，此时，深拷贝尤为重要。默认类的缺省函数都是浅拷贝函数。简单示例如下：

```c++
//原始浅拷贝

#include <iostream>
using namespace std;

class Data {
public:
    Data() {}
    Data(int _data) :data(_data)
    {
        cout << "constructor" << endl;
    }
    //简单赋值浅拷贝

    Data& operator = (const int _data)
    {
        cout << "operator = (const int _data)" << endl;
        data = _data;
        return *this;
    }
private:
    int data;   
};

int main()
{
    Data data1(1);
    Data data2, data3;
    data2 = 1;
    data3 = data2;//调用编译器提供的默认的赋值运算符重载函数，当自定义析构函数的时候会存在问题
 
    return 0;
}

//深拷贝

#include <iostream>
#include <string>
using namespace std;

class MyStr {
public:
    MyStr() {}
    MyStr(int _id, char *_name)
    {
        cout << "constructor" << endl;
        id = _id;
        name = new char[strlen(_name) + 1];
        strcpy_s(name,strlen(_name) + 1,_name); 
    }
    //深拷贝构造函数

    MyStr(const MyStr &str)
    {
        cout << "copy constructor" << endl;
        id = str.id;
        if (name != NULL)
            delete name;
        name = new char[strlen(str.name) + 1];
        //拷贝数据

        strcpy_s(name,strlen(str.name) + 1,str.name);
    }

    MyStr& operator=(const MyStr& str)
    {
        cout << "operator=" << endl;
        if (this != &str)
        {
            if (name != NULL)
                delete name;
            this->id = str.id;
            name = new char[strlen(str.name) + 1];
            //拷贝字符长度

            strcpy_s(name,strlen(str.name) + 1,str.name);

            return *this;
        }
    }
    ~MyStr() 
    {
        cout << "deconstructor" << endl;
        delete name;
    }
private:
    char *name;
    int id;
};

void main()
{
    MyStr str1(1,"Jack");
    MyStr str2;
    str2 = str1;
    MyStr str3 = str2;
    return;

}


```

IO库条件状态：

|状态|含义|
|:---|:---|
|`strm::iostate`|strm是一种IO类型。iostream是一种机器相关的整型提供了表达条件状态的完整功能|
|`strm::badbit`|`strm::badbit`用来指出流已崩溃|
|`strm::failbit`|`strm::failbit`用来指出一个IO操作失败了|
|`strm::eofbit`|`strm::eofbit`用来指出流达到了文件结束|
|`strm::goodbit`|`strm::goodbit`用来指出流未处于错误状态。此值保证为零|
|`s.eof()`|流 s 的 `eofbit` 置位，则返回 `true`|
|`s.fail()`|流 s 的 `failbit` 或 `badbit` 置位，则返回 true|
|`s.bad()`|流 s 的 badbit 置位，则返回 true|
|`s.good()`|若流 s 处于有效状态，则返回 true|
|`s.clear()`|将流 s 中的所有条件状态位复位，将流的状态设置为有效。返回void|
|`s.clear(flag)`|根据给定的 flags 标志位，将流 s 中对于条件状态位复位。 flag 的类型是`strm::iostate`。返回 void|
|`s.setstate(flag)`|根据给定的 flags 标志位，将流 s 中对于条件状态位置位。 flag 的类型是strm::iostate。返回 void|
|`s.rdstate()`|返回流 s 的当前条件，返回值类型为 `strm::iostate`|

**四种条件状态**

|状态|含义|数值|`good()`|`eof()`|`bad()`|`fail()`|`rdstate()`|
|:---|:---|:---|:---|:---|:---|:---|:---|
|`ios::goodbit`|流状态完全正常|0|1|0|0|0|`goodbit`|
|`ios::eofbit`|已达到文件结束|2|0|1|0|0|`eofbit`|
|`ios::badbit`|输入（输出）流出现非致命错误，可挽回|1|0|0|1|0|`badbit`|
|`ios::failbit`|输入（输出）流出现致命错误，不可挽回|4|0|0|0|1|`failbit`|

**文件结束**

|状态|解释|
|:---|:---|
|`strm::eofbit`|`strm::eofbit`用来指出流达到了文件结束|
|`s.eof()`|流 s 的 `eofbit` 置位，则返回 `true`|

注意：

- 一个流一旦发生错误，其上后续的IO操作都会失败。因此一般使用`while(cin>>word)`来检测是否成功。

iostate 类型用来表示流状态的完整功能。使用示例如下：

```c++
auto old_state=cin.restate(); //记住cin的状态

cin.clear();//使得cin有效

process_input(cin); //使用cin

cin.setstate(old_state);//设置cin为原有状态。

cin.clear(cin.rdstate() & ~cin.failbit & ~cin.badbit);//复位failbit和badbit,保持其他标志位不变。

```

#### 管理输出缓冲

每个输出流都管理一个缓冲区，用来保存程序读写的数据；例如`os<<"Please enter a value:";`中文本串可能被立即打印出来，但也有可能被操作系统保存在缓冲区中，随后打印。

注意：如果程序异常崩溃，输出缓冲区不会更新，数据很可能停留在缓冲区中等待打印。因此当程序崩溃后，需要确定已经输出的数据确实已经刷新了，否则可能将大量时间浪费在追踪代码为什么没有执行上面。

输入和输出流也是可以正常关联的：利用`ostream`的`tie`实现相关操作。`tie()`当前关联到的输出流，`tie(&o)`关联到o输出流。多个流可以关联到同一个`ostream`;下面是使用示例：

```c++
cin.tie(&cout); //将标准cin与cout关联在一起。

ostream *old_tie=cin,tie(nullptr);//关联空流

cin.tie(&cerr); //读取cin会刷新cerr而不是cout

cin.tie(old_tie); //重建cin和cout间的正常关联。

```

#### 文件输入输出
_参考链接:_ [fstream参考](http://www.cplusplus.com/reference/fstream/fstream/)；

fstream特有操作：

|名称|操作|
|:---|:---|
|`fstream fstrm`|创建一个未绑定的文件流|
|`fstream fstrm（s）`|创建一个fstream，并打开名为s的文件。默认的文件模式mode依赖于fstream的类型|
|`fstream fstrm（s，mode）`|与前一个构造函数类似，但按指定mode打开文件|
|`fstrm.open(s)`|打开名为s的文件，并将文件与fstrm绑定，默认的文件mode依赖于fstream的类型，返回void|
|`fstrm.close()`|关闭与fstrm绑定的文件，返回void|
|`fstrm.is_open()`|返回一个bool值，指出与fstrm关联的文件是否成功打开且尚未关闭|

文件的打开有两种方式：

-  在初始化输入输出对象时，直接构建；如： `ifstream in(ifile)`
-  先声明，再使用`open`函数关联文件；例如：

```c++
std::string ifile="c:/Windows/assembly/test";
ifstream in(ifile); //构筑一个ifstream并打开给定文件

ofstream out; //输出文件流未与任何文件相关联。

out.open(ifile+".txt");//打开指定文件

in.close(); //关闭文件


```

注意： 
- 当一个`fstream`对象呗销毁时,`close`会自动被调用。
- 默认模式打开文件进行输出将自动打开文件的长度截为零，即 **删除已有内容**。 （细节！！） 

文件读写模式：

|模式|作用|
|:---|:---|
|`in`|读方式打开|
|`out`|写方式打开|
|`app`|每次写操作前均定位到文件末尾|
|`ate`|打开文件后立即定位到文件末尾|
|`trunc`|截断文件|
|`binary`|二进制方式进行io|

注意：以`out`模式打开文件会丢弃已有数据，因此常需要附加`app`模式；例如：

```c++
ofstream out("file1");// 输出模式打开文件并截断文件

ofstream out2("file1",ofstream::out);//隐含第截断文件

ofstream out3("file1",ofstream::out | ofstream::trunc);
//保留文件内容显式指定app模式。

ofstream app("file2",ofstream::app);
//隐含为输出模式 

ofstream app2("file2",ofstream::out | ofstream::app);
```

每次使用open函数都可以再次更改文件模式。
文件流使用示例：

```c++
# include<iostream>
# include<fstream>
# include<string>
using namespace std;
 
int main()
{
    //读取初始文件内容，并输出显示
    
    ifstream in;
    in.open("guest.txt");
    char ch;
    if (in.is_open())
    {
        cout << "Here are the current contents of thepeople.text's file:" <<endl;
        while (in.get(ch))
            cout << ch;
        cout << endl;
        in.close();
 
    }
 
    // 添加内容到文件
    
    ofstream out;
    out.open("D:guest.txt", ofstream::app);  
    //out.open("people.txt", ios_base::app);
    
    if (!out.is_open())
    {
        cout << "failed to open file" << endl;
    }
    cout << "Please enter content:";
    string str;
    while (getline(cin, str) && str.size() > 0)
    {
        out << "\n"<<str << endl;
    }
    out.close();
    //读取修改后的文件内容，并输出显示

    in.open("guest.txt");
    if (in.is_open())
    {
        cout << "Here are the revised contents of the people.text's file:" << endl;
        while (in.get(ch))
            cout << ch;
        cout << endl;
        in.close();
    }
 
    return 0;
 
}

```

### string 流

string相关流继承关系如下图：

![相关继承关系](http://www.pconline.com.cn/pcedu/empolder/gj/c/0504/pic/08cppios01.gif)

stringstream的特有操作

|操作|含义|
|:---|:---|
|`sstream strm`|定义字符串头文件类型|
|`sstream strm(s)`|保存string s的一个拷贝|
|`strm.str()`|返回strm所保存的`string`的拷贝|
|`strm.str(s)`|将`string s` 拷贝到`strm`中。返回`void`|

## 第 9 章顺序容器

容器是一些特定类型对象的集合。顺序容器为程序员提供了控制元素存储和访问顺序的能力。下面是简介表

|类型|特点|
|:---|:---|
|`vector`|可变大小数组。支持快速随机访问。在尾部之外的位置插入或者删除元素|
|`deque`|双端队列。支持快速随机访问。在头尾插入/删除速度很快|
|`list`|双向链表。只支持双向顺序访问。在`list`中任何位置进行插入/删除操作速度都很快|
|`forward_list`|单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快|
|`array`|固定大小数组。支持快速随机访问。不能添加或者删除元素|
|`string`|与`vector`相似的容器，但是专门保存字符。随机访问快。在尾部插入/删除速度很快|

下面是一些选择容器的基本原则：

- 除非有很好的理由，否则应使用`vector`
- 如果你的程序有很多小元素，且额外开销很重要，则不要使用`list`或者`forward_list`。
- 如果程序要求随机访问元素，应该使用`vector`或者`deque`。
- 如果程序要求在容器的中间插入或者删除元素，应该使用`list`或者`forward_list`。
- 如果程序需要在头尾位置插入或者删除元素，但不会在中间位置进行插入，则使用`deque`。
- 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则：
    + 首先，确定是否真的需要在容器中间位置添加元素，当处理输入数据时，通常可以很容易地向`vector`追加数据，然后再调用标准库`sort`函数来重新排列容器中的元素，从而避免在中间位置添加元素。
    + 如果必须在中间位置插入元素，考虑在输入阶段使用`list`，一旦输入完成，将`list`中的内容拷贝到一个`vector`中。

容器操作：


|类型别名|操作|
|:---|:---|
|`iterator`|此容器类型的迭代器类型|
|`const_iterator`|可以读取元素，但不能修改元素的迭代器类型|
|`size_type`|无符号整数类型，足够保存此种容器类型最大可能容器的大小|
|`difference_type`|带符号整数类型，足够保存两个迭代器之间的距离|
|`value_type`|元素类型|
|`reference`|元素的左值类型；与`value_type&`含义相同|
|`const_reference`|元素的`const`左值类型(即，`const value_type&`)|


|构造函数|操作|
|:---|:---|
|`C c`|默认构造函数，构造空容器(array)|
|`C c1(c2)`|构造`c2`的拷贝`c1`|
|`C c(b,e)`|构造`c`,将迭代器`b`和`e`指定的范围内的元素拷贝到`c`|
|`C c{a,b,c ...}`|列表初始化`c`|


|赋值与`swap`|操作|
|:---|:---|
|`c1=c2`|将`c1`中的元素替换为`c2`中元素|
|`c1={a,b,c...}`|将`c1`中的元素替换为列表中元素(不适用于array)|
|`a.swap(b) or swap(a,b) `|交换a和b的元素|


|大小|操作|
|:---|:---|
|`c.size()`|c中元素的数目(不支持`forward_list`)|
|`c.max_size()`|c可保存的最大元素数目|
|`c.empty()`|若`c`中存储了元素，返回`fasle`,否则返回`true`|

|添加/删除元素|操作|
|`c.insert(args)`|将`args`中的元素拷贝进`c`|
|`c.emplace(inits)`|适用`inits`构造`c`中的一个元素|
|`c.clear()`|删除`c`中所有的元素，返回`void`|

|关系运算符|解释|
|:---|:---|
|`==,!=`|所有容器都支持相等(不等)运算符|
|`<,<=,>,>=`|关系运算符(无序关联容器不支持)|

|获取迭代器|解释|
|:---|:---|
|`c.begin(),c.end()`|返回指向`c`的首元素和尾元素之后位置的迭代器|
|`c.cbegin(),c.cend()`|返回`const_iterator`|

|反向容器的额外成员(不支持`forward_list`)|解释|
|:---|:---|
|`reverse_iterator`|按逆序寻址|
|`const_reverse_iterator`|不能修改元素的逆序迭代器|
|`c.rbegin(),c.rend()`|返回指向cz的尾元素和首元素之前位置的迭代器|
|`c.crbegin(),c.crend()`|返回`const_reverse_iterator`|

**迭代器**

迭代器范围是标准库的基础，标砖库的很多操作都是基于迭代器产生的。`begin`迭代器迭代器指向迭代器开头的元素；`last`迭代器指向尾元素之后的元素；即不是指向尾部元素，元素范围为**左闭右开**

代码示例：

```c++
list<string> a={"string1","string2","string3"};
auto it1=a.begin(); //lsit<string>::iterator;

auto it2=a.rbegin();//list<string>::reverse_iterator;

auto it3=a.cbegin(); //list<string>::const_iterator;

auto it4=a.crbegin();//list<string>::const_reverse_iterator
```

注意：

- 顺序容器不需要写访问时，应该尽量使用`cbegin`和`cend`；
- 只有顺序容器不包括(array)的构造函数才能接受大小参数
- 拷贝构造只有当容器类型匹配时才能成立，
- 当将一个容器初始化为另外一个容器的拷贝的时候，两个容器的容器类型和元素类型都必须相同。

**标准库array具有固定大小**
与内置数组一样，标准库array的大小也是类型的一部分。当定义一个`array`时，除了指定元素类型，还要指定容器大小；使用array类型，也必须指定元素类型的大小；array初始化会自动给与0值。内置数组不允许拷贝，但是array类型允许拷贝。

```c++
array<int ,42>; //类型为：保存42个int的数组

array<string,10>; //类型为：保存10个 string的数组

array<int,10>::size_type i;//数组类型包括元素类型和大小

array<int>::size_type j; //错误:array<int>不是一个类型

```

**替换操作 `assign`**

|函数|功能|
|:---|:---|
|`seq.assign(b,e)`|将seq中的元素替换为迭代器b和e所示到范围中的元素。迭代器b和eb不能指向seq中的元素|
|`seq.assign(li)`|将seq中的元素替换为初始化列表li中的元素|
|`seq.assign(n,t)`|将seq中的元素替换为n个值为t的元素|

使用：`vector<int > b(10,5);vector<int> a;a.assgin(b.cbegin(),b.cend());`

注意：赋值运算会导致指向左边容器内部的迭代器、引用和指针失效。而`swap`操作将容器内容交换不会导致容器的迭代器、引用和指针失效(容器类型为array和string的情况除外)；例如，假定`iter`在`swap`之前指向`svecl[3]`中的string,那么在`swap`之后它指向`svec2[3]`的元素。但是array会真正交换他们的元素。因此交换两个array所需的时间与array中元素的数目成正比。

##### 关系运算符
每个容器类型都支持相等运算符(==和!=)除了无序关联容器外，都支持关系运算符(>、>=、<、<=)。关系运算符两边必须是相同类型的容器，且必须保存相同类型的元素。元素相等比较规则如下：

1. 如果两个容器具有相同大小且所有元素都两两对应相等，则这个容器相等，否则不相等。
2. 如果两个容器大小不相同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器
3. 如果两个容器都不是另外一个容器的前缀子序列，则他们的比较结果取决于第一个不相等的元素的比较结果。
4. 只有当其元素类型也定义了相应的比较运算符的时候，我们才可以使用关系运算符来，比较两个容器。

##### 向顺序容器中添加元素

|操作名称|作用|
|:---|:---|
|`c.push_bcak(t)`|在c的尾部创建并插入一个元素|
|`c.push_back(t)`|在c的头部创建并插入一个元素|
|`c.insert(p,t)`|在迭代器p指向的元素之前创建插入一个元素，返回指向新添加元素的迭代器|
|`c.insert(p,n,t)`|在迭代器p指向的元素之前创建插入n个元素，返回指向新添加元素第一个元素的迭代器|
|`c.insert(p,b,e)`|将迭代器b和e指定的范围内的元素插入到迭代器p指向的元素之前，返回指向新添加元素第一个元素的迭代器；若p为空则返回p|
|`c.insert(p,il)`|il是一个花括号包围的元素值列表。将这些给定值插入到迭代器p指向的元素之前，返回指向新添加的第一个元素的迭代器|

注意： 

- 向一个`vector`、`string`或者`deque`插入元素会使所有指向容器的迭代器、引用和指针失效。
- 容器元素插入和初始化都是拷贝
- 使用插入`insert`的时候会返回插入的值

**使用emplace操作**

新标准中引入了三个新成员函数-`emplace_front`、`emplace`和`emplace_back`它们与`insert`系列操作相同，
注意：

- `emplace`函数在容器中直接构造元素，传递给`emplace`函数的参数必须与元素类型的构造函数相匹配。

例如：
```c++
c.emplace_back("99999",25,15.99);//错误没有接受三个参数的`push_back`版本

c.push_back("99999",25,15.99);//正确创建一个临时的`push_back`版本
```

##### 顺序容器中访问元素操作

|操作|含义|
|:---|:---|
|`c.back()`|返回c中尾元素的引用。若c空，函数行为未定义|
|`c.front()`|返回c中首元素的引用。若c空，函数行为未定义|
|`c[n]`|返回c中下标为n元素的引用。若c空，n>=c.size()函数行为未定义|
|`c.at(n)`|返回c中下标为n元素的引用。若越界抛出异常|

建议：尽量使用at函数，避免下标越界


##### 顺序容器中删除元素操作

|操作|含义|
|:---|:---|
|`c.pop_back()`|删除c中尾部元素，若c空，函数行为未定义|
|`c.pop_front()`|删除c中首元素的引用。若c空，函数行为未定义|
|`c.erase(n)`|删除迭代器p所指的元素，返回一个指向被删除元素之后元素的迭代器|
|`c.erase(b,e)`|删除迭代器b和e所指定范围内的元素。返回指向最后一个被删除元素之后元素的迭代器|
|`c.clear()`|删除c中所有元素。返回`void`|

注意对于单链表而言有许多不同之处

![链表操作](http://wangpengcheng.github.io/img/fowrd_list_insert.png)

当在forword_list中添加或者删除元素时，我们必须关注两个迭代器-一个指向我们要处理的元素，另外一个指向其前驱元素。例如：

```c++
forward_list<int> flst={0,1,2,3,4,5,6,7,8,9}；
auto prev=flst.before_begin(); //表示flst的首前元素

auto curr=flst.begin();   //表示flst中的第一个元素

while(curr!=flst.end()) {
    if(*curr%2){
        curr=flst.erase_after(prev); //删除并移动curr

    }else{
        prev=curr;//移动迭代器curr,指向下一个元素，prev指向curr之前的元素
        
        ++curr;
    }
}


```
##### 容器操作可能会使迭代器失效

_参考链接：_ [C++迭代器失效的几种情况总结](https://www.cnblogs.com/fnlingnzb-learner/p/9300073.html)；[C++之迭代器失效及解决](https://blog.csdn.net/Yinghuhu333333/article/details/80744440)；

在向容器中添加元素之后：

- 如果容器是`vector`或者`string`，且存在存储空间被重新分配，则指向容器的迭代器、指针和引用内存都会失效。如果没有重新分配内存，指向插入位置之前的元素的迭代器、指针和引用仍然有效，但是指向插入之后的元素迭代器、指针和引用都会失效
- 对于`deque`插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但是指向存在的元素的引用和指针不会失效。
- 对于`list`和`forward_list`指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效。

在删除一个元素后

- 对于`list`和`forward_list`指向容器其它位置的迭代器、引用指针任然有效。
- 对于`deque`如果在首尾之外的任何位置删除元素，那么指向被删除元素之外其它元素的迭代器、引用或者指针也会失效。如果删除的是尾部元素，则尾后的迭代器也会失效，但其它迭代器、引用和指针不受影响；如果删除首尾元素，这些也不会受影响。
- 对于`vector`和`string`,指向被删除元素之前元素的迭代器、引用和指针仍然有效。注意当我们删除元素时，尾后迭代器总是会失效。

因为添加删除原来的元素后，`end`迭代器总是会失效，因此尽量不要保存`end`返回的迭代器

vector和string 的容器大小管理操作
`capacity()`容器在不扩张内存空间的情况下可以容纳多少个元素，`reserve`允许我们通知容器它应该准备保存多少个元素


|操作|含义|
|:---|:---|
|`c.shrink_to_fit()`|将`capacity（）`减小为和`size`相同大小|
|`c.capacity()`|不重新分配内存空间的话，c可以保存多少元素|
|`c.reserve(n)`|分配至少能容纳n个元素的内存空间|

注意： reserve并不改变容器元素中的数量，它仅仅影响vector预先分配多大的内存空间。


##### 额外的string操作

|操作|含义|
|:---|:---|
|`s.insert(pos,args)`|在迭代器pos之前插入args指定的字符|
|`s.erase(pos,len)`|删除从位置`pos`开始的`len`个字符。如果len 被省略则删除从`pos`开始至s末尾的所有字符。返回一个指向`s`的引用|
|`s.assign(args)`|将`s`中的字符串替换为`args`指定的字符。返回一个指向`s`的引用|
|`s.append(args)`|将`s`后添加`args`指定的字符。返回一个指向`s`的引用|
|`s.replace(range,args)`|删除`range`范围内的字符，替换为`args`指定的字符，返回`s`的引用|


**string搜索操作**

|操作|含义|
|:---|:---|
|`s.find(args)`|查找`s`中第一次出现的位置|
|`s.rfind(args)`|查找`s`中最后一次出现的位置|
|`s.find_frist_of(args)`|在`s`中查找`args`中任何一个字符，第一次出现的位置|
|`s.find_last_of(args)`|在`s`中查找`args`中任何一个字符，最后一次出现的位置|
|`s.find_frist_not_of(args)`|在`s`中查找第一个不在`args`中的字符|
|`s.find_last_not_of(args)`|在`s`中查找最后一个不在`args`中的字符|

```c++
//循环查找下一个数

string::size_type pos=0;
while((pos=name.find_frist_of(number,pos))!=string::npos) {
    cout<<"found number at index: "<<pos
        <<"element is "<<name[pos]<<endl;
        ++pos;//移动到下一个字符    
}

```

`compare`比较字符串；`to_string()`将数字转化为字符串。

**string和数值之间的转换**

|操作|含义|
|:---|:---|
|`to_string(val)`|将任意一种算术类型`val`转化为`string`|
|`stoi(s,p,b)`|返回s的起始字符子串(整数内容)的数值 `int`,b是转换基数，p是`size_t`指针|
|`stol(s,p,b)`|返回s的起始字符子串(整数内容)的数值 `long`,b是转换基数，p是`size_t`指针|
|`stoul(s,p,b)`|返回s的起始字符子串(整数内容)的数值 `unsigned long`,b是转换基数，p是`size_t`指针|
|`stoll(s,p,b)`|返回s的起始字符子串(整数内容)的数值 `long long`,b是转换基数，p是`size_t`指针|
|`stoull(s,p,b)`|返回s的起始字符子串(整数内容)的数值 `unsigned long long`,b是转换基数，p是`size_t`指针|
|`stof(s,p)`|返回s的起始字符子串(整数内容)的数值 `float`,b是转换基数，p是`size_t`指针|
|`stod(s,p)`|返回s的起始字符子串(整数内容)的数值 `long long`,b是转换基数，p是`size_t`指针|
|`stold(s,p)`|返回s的起始字符子串(整数内容)的数值 `long double`,b是转换基数，p是`size_t`指针|

### 容器适配

出来标准容器外还有三个顺序容器适配器： `stack`、`queue`和`proiority_queue`。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。例如`stack`适配器接受一个顺序容器，并使其操作像一个stack一样。下面是使用示例：

```c++
stack<int> stk(deq);//从deq拷贝元素到stk

stack<string ,std::vector<string> > str_stk;//在vector上实现的空栈

stack<string ,vector<string > > str_stk2(svec);//str_stk2在vector上实现，初始化时保存svec的拷贝

```
## 泛型算法

泛型算法是指使用迭代器为媒介的通用型算法；泛型算法本身不会执行容器的操作，他们只会运行于迭代器智商，执行迭代器的操作--算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素值。

**`accumulate` 求和**

```c++

int sum =accumulate(vec.cbegin(),vec.cend(),0);//对元素求和初值是0

string sum=accumulate(v.cbegin(),v.cend(),string(''));//字符串求和

equal(roster1.cbegin(),roster1.cend(),rosterl2.cbegin());//比较元素，数量相同且一样多的时候才返回`true`

fill(vec.begin(),vec.begin()+vec.size()/2,10);//将容器的一个子序列设置为10

back_inserter();//插入元素，检查是否存在

copy(begin(a1),end(a1),a2);//把a1的内容拷贝给a2

replace(ilist.begin(),ilist.end(),0,42);//查找所有元素为0的值，并将它更改为42

replace_copy(ilis.cbegin(),ilist.cend(),back_inserter(ivec),0,42);//ilist指出调整序列之后的保存位置。

sort(word.begin(),word.end());//按照字典排序

auto end_unique=unique(words.begin(),words.end());//除去重复单词

``` 

注意：
 
- 算法不检查写操作
- 向目的位置迭代器写入数据的算法，假定目的位置足够大，能容纳要写入的元素。

### 定制操作
许多算法的默认关键操作符，并不能满足我们的需求，因此，需要我们来重载`sort`的默认行为。

#### 向算法传递函数
sort可以接受第三个参数，即谓词--一个可用的表达式，其返回结果是一个能用作条件的值。标准库中分为
**一元谓词**(只接受单一参数)和**二元谓词**(他们有两个参数)。例如下面的代码，重载了sort函数的基础比较操作

```c++
//排序函数

bool isShorter(const string &s1,const string &s2){
    return s1.size()<s2.size();
}
//按照长度由短到长排序
sort(words.begin(),words.end(),isShorter);

elimDups(words);//将words按照字典重新排序，并消除重复单词

stable_sort(words.begin(),words.end(),isShorter)；//按照长度重新排序，长度相同的单词维持字典序

//无需拷贝字符串

for (const auto &s :words)
{
    cout<<s<<"";//打印每个元素，以空格分割

}
cout<<endl;

```
### lambda 表达式

_参考链接：_ [c++11 lambda 表达式](https://www.cnblogs.com/DswCnblog/p/5629165.html);[c++ lambda表达式](https://www.cnblogs.com/jimodetiantang/p/9016826.html);

**lambda表达式的声明**

`[capture list] (params list) mutable exception-> return type { function body }`
各项含义如下：

1. `capture list`: 捕获外部变量列表
2. `params list`: 形参列表
3. `mutable`:用来说明是否可以修改捕获的变量
4. `exception`:异常设定
5. `return type`:返回类型
6. `function body`:函数体

省略的常见表达式有：

|序号|格式|
|:---|:---|
|1|`[capture list] (params list) -> return type {function body}`|
|2|`[capture list] (params list) {function body}`|
|3|`[capture list] {function body}`|

其中：

- 格式1声明了const类型的表达式，这种类型的表达式不能修改捕获列表中的值。
- 格式2省略了返回值类型，但编译器可以根据以下规则推断出Lambda表达式的返回类型： （1）：如果function body中存在return语句，则该Lambda表达式的返回类型由return语句的返回类型确定； （2）：如果function body中没有return语句，则返回值为void类型。
- 格式3中省略了参数列表，类似普通函数中的无参函数。

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

bool cmp(int a, int b)
{
    return  a < b;
}

int main()
{
    vector<int> myvec{ 3, 2, 5, 7, 3, 2 };
    vector<int> lbvec(myvec);

    sort(myvec.begin(), myvec.end(), cmp); // 旧式做法

    cout << "predicate function:" << endl;
    for (int it : myvec)
        cout << it << ' ';
    cout << endl;

    sort(lbvec.begin(), lbvec.end(), [](int a, int b) -> bool { return a < b; });   // Lambda表达式
    cout << "lambda expression:" << endl;
    for (int it : lbvec)
        cout << it << ' ';
}

```
lambde表达式的外部捕获

Lambda表达式通过在最前面的方括号[]来明确指明其内部可以访问的外部变量，这一过程也称过Lambda表达式“捕获”了外部变量。

值捕获方式：

|捕获形式  |  说明|
|:---|:---|
|`[]`| 不捕获任何外部变量|
|`[变量名, …]`    |默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&说明符）|
|`[this]` | 以值的形式捕获this指针|
|`[=]`| 以值的形式捕获所有外部变量|
|`[&]`| 以引用形式捕获所有外部变量|
|`[=, &x]`| 变量x以引用形式捕获，其余变量以传值形式捕获|
|`[&, x] `| 变量x以值的形式捕获，其余变量以引用形式捕获|

注意：如果一个lambda体包含`return`之外的任何语句，则编译器假定lambda返回`void`；被推断`void`的lambda不能返回值。因此当重写排序等操作的时候，只能有一句`return`语句；例如：

```c++
transform(vi.begin(),vi.end(),vi.begin(),
    [](int i){
        return i<0?-i:i;//返回绝对值

    });

transform(vi.begin(),vi.end(),vi.begin(),
    [](int i){
        if(i<0){
            return -i;
        }else{
            return i;
        }
        //错误，有多余语句，判定返回void

    });

```

因此当我们使用一个lambda定义返回类型的时候，必须使用尾置返回类型，声明返回类型；例如：

```c++
transform(vi.begin(),vi.end(),vi.begin(),
    [](int i)->int 
    {
        if(i<0){
            return -i;
        }else{
            return i;
        }
        //返回绝对值

    });
```

#### lambda 参数绑定
lambda表达式，虽然可以进行简单的参数绑定，但是对于复杂的参数绑定而言，还是存在许多问题，因此可以利用函数对lambda表达式进行参数绑定。大致步骤如下：
 
 1. 使用`std:bind`函数对函数参数和函数进行绑定
 2. 使用`placeholderd`进行参数占位符的使用。

调用`bind`一般形式为：
`auto newCallable=bind(callable,arg_list);`

`newCallable`本身是一个可以调用对象，`arg_list`是一个逗号分隔的参数列表，对应给定的`callable`的参数，即调用的实际参数。
`arg_list`中的参数可能包含形如`_n`的名字，其中`n`是一个整数。表示占位符，数值`n`表示生成的可调用对象中参数的位置：`_1`为`newCallble`的第一个参数，`_2`为第二个参数。`_n`为第`n`个参数。
使用：
`auto g=bind(f,a,b,_2,c,_1);`
生成一个新的可调用函数对象，它有两个参数，分别使用占位符`_2`和`_1`表示。使得原本需要输入5个参数的函数变为，只需要2个参数的函数，对函数进行了再一次封装。`f(a,b,_1,c,_2)`等价于`g(_1,_2)`减少了函数的复杂程度。

`std::ref()`：传递给`bind`一个对象但是不拷贝它

例如：

```c++
//1. 定义比较string大小函数

bool check_size(const string &s,string::size_type sz){
    return s.size()>=sz;
}

//2. 使用bind绑定函数和参数
//将输入比较顺序颠倒，将单词长度由长至短排序

sort(words.begin(),words.end(),bind(isShorter,_2,_1));

//使用lambda表达式，输出表达式，os是一个局部变量，引用一个输出流

for_each(word.begin(),words.end(),[&os,c](const string &s){
    os<<s<<c;
});
//bind相同的效果 

ostream &print(ostream &os,const string &s,char c){
    return os<<s<<c;
}
//ref返回一个对象，包含给定的引用，此对象是可以拷贝的

for_each(words.begin(),words.end(),
        bind(print,std::ref(os),_1,' '));


``` 

#### 再探迭代器

##### 插入迭代器
插入迭代器有三种基本类型

- `back_inserter`: 创建一个使用`push_back`的迭代器。
- `front_inserter`:创建一个使用`push_front`的迭代器。 
- `inserter`:创建一个使用`inserter`的迭代器。此函数接受第二个参数，这个参数必须是一个指向容器的迭代器。元素将被插入到给定迭代器所表示的元素制之前。

注意： 只有在容器支持`push_front/push_back`的情况下，我们才可以使用`front_inserter/back_inserter`。

使用示例：

```c++

*it=val;
it=c.insert(it,val);//it指向插入的新元素

++it;//递增it使它指向原来的元素

list<int> lst={1,2,3,4};
list<int> lst2，lst3;//空list
//拷贝完成之后，lst3包含1 2 3 4

copy(lst.cbegin(),lst.cend(),front_inserter(lst2));
//拷贝完成之后，lst3包含1 2 3 4

copy(lst.cbegin(),lst.cend(),inserter(lst3,lst3.begin()));

```

##### iostream 迭代器

- `istream_iterator`:读取输入流。
- `ostream_iterator`:向输出流写数据。

**`istream_iterator`操作** 

|操作|含义|
|:---|:---|
|`istream_iterator<T> in(is)`|`in`从输入流`is`读取类型为`T`的值|
|`istream_iterator<T> end`|读取类型为`T`的值的`istream_iterator`迭代器，表示尾后位置|
|`in1=(!)=in2`|`in1`和`in2`必须读取相同类型。如果他们都是尾后迭代器，或绑定到相同输入，则二者相等|
|`*in`|返回从流中读取的值|
|`in->mem`|与`(*in).mem`的含义相同|
|`++in,in++`|使用元素类型所定义的`>>`运算符从输入流中读取下一个值，并且前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值|

操作示例：

```c++
istream_iterator<int > int_it(cin); //从cin读取int

istream_iterator<int> int_eof; //尾后迭代器

ifstream in("afile");  
istream_iterator<string> str_it(in); //从"afile"读取字符串

//读入数据并存储到vector向量组

while(int_it!=eof) {
    //后置递增运算读取流，返回迭代器的旧值
    //解引用迭代器，获得从流读取的前一个值

    vec.push_back(*in_iter++);
}
//循环读取其中的int值存储在vec中

//使用算法操作流迭代器

istream_iterator<int > in(cin),eof;
cout<<accumulate(in,eof,0)<<endl;
//输入：23 109 45 89 6 34 12 90 34 23 56 23 8 89 23

//输出：664


```
注意：当我们将一个`istream_iterator`绑定到一个流时，标准库并不保证迭代器立即从流中读取数据。直到使用迭代器时才正真读取。标准库中的实现所保证的是，我们第一次解引用迭代器之前，从六中的数据操作已经完成了。

##### `ostream_iterator`操作

|操作|含义|
|:---|:---|
|`ostream_iterator<T> out(os)`|`out`将类型为`T`的值写入到流`os`中|
|`ostream_iterator<T> out(os,d)`|将类型为`T`的值写到输出流`os`中，每个值后面都输出一个`d`。`d`指向一个空字符结尾的字符数组|
|`out=val`|`out`和`val`必须类型兼容。用运算符`<<`将`val`写入到`out`输出流中|
|`*out,++out,out++`|这些运算符是存在的，但是不对`out`做任何事情。每个运算符都返回`out`|

### 泛型算法结构
对于向一个算法传递错误类别的迭代器的问题，很多编译器不会给出任何警告或者提示。因此需要迭代器类型的支持和认证。

**迭代器类别**

|类别|含义|
|:---|:---|
|输入迭代器|只读，不写；单遍扫描，只能递增|
|输出迭代器|只写，不读；单遍扫描，只能递增|
|前向迭代器|可读写；多遍扫描，只能递增|
|双向迭代器|可读写；多遍扫描，可递增递减|
|随机访问迭代器|可读写；多遍扫描，支持全部迭代运算|

## 第11章 关联容器

关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是`map`和`set`；关联容器不支持顺序容器的位置相关的操作。也不支持构造函数或者插入操作这些接受一个元素值和一个数量值的操作。

使用示例：
```c++
std::map<string, size_t;> word_count;//空容器

set<string> exclude={"the","but","and","or","an","a"};

//三个元素；authors将姓映射为名

map<string ,string> authors={
    {"Joyce","James"},
    {"Austen","Jane"},
    {"Dickens","Charles"}
};
```

注意：一个`map`或者`set`中的关键字必须是唯一的。但是`multimap`和`multiset`没有这个限制。允许多个元素，拥有相同的关键字。

#### 11.2.2 关键字类型要求
传递给排序算法的可调用对象，必须满足于关联容器中关键字一样的类型要求。

#### 11.2.3 `pair`类型

`pair`主要保存，两个数据成员，必须提供2个类型名，`pair`的数据成员，将具有应对的类型。

```c++
pair<string ,string > anon; //保存两个string

pair<string ,size_t> word_count; //保存一个string和一个size_t

pair<string ,vector<int>> line; //保存string和vector<int>

```

**`pair`上的操作**

|操作|含义|
|:---|:---|
|`pair <T1,T2> p`|p是一个`pair`，两个类型分别为`T1`和`T2`的成员都进行了初始化|
|`pair <T1,T2> p(v1,v2)`|p是一个`pair`，两个类型分别为`T1`和`T2`的`v1`和`v2`都进行了初始化|
|`pair <T1,T2> p={v1,v2}`|意义同上|
|`make_pair(v1,v2)`|返回一个用`v1`,`v2`初始化的`pair`。`pair`的类型从`v1`和`v2`的类型中推断出来|
|`p.first`|返回`p`的名称为`first`的公有数据成员|
|`p1 relop p2`|关系运算符(<、>、<=、>=)按照字典序定义：例如对应成立时返回`true`|

### 11.3 关联容器操作

|操作类型|含义|
|:---|:---|
|`key_type`|此容器类型的关键字类型|
|`mapped_type`|每个关键字关联的类型；只适用于`map`|
|`value_type`|对于`set`,与`key_type`相同；对于`map`，为`pair<const key_type,mapped_type>`|

```c++
set<string>::value_type v1; //v1是一个string

set<string>::key_type v2; //v2是一个string

map<string,int>::value_type v3;//v3是一个pair <const string ,int>

map<string,int>::key_type v4; //v4是一个string

map<string,int>::mapped_type v5; //v5是一个int

```
注意：

- 一个`map`的`value_type`是一个`pair`,我们可以改变`pair`的值，但不能改变关键字成员的值。
- `set`的迭代器是`const`的，只能读取，不能修改。

#### 11.3.1 关联容器迭代器
使用示例：

```c++
auto map_it=word_count.begin();  //*map_it 是一个指向pair<const string,size_t>对象的引用

cout<<map_it->first; //打印此元素的关键字

cout<<""<<map_it->second; //打印此元素的值

map_it->first="new key"; //错误：关键字是const的

++map_it->second; //正确：我们可以通过迭代器改变元素

```
因为关联容器`set`的迭代元素是`const`的，`map`中的元素是`pair`，其第一个成员是`const`的，因此关联容器，通常用于值读取元素的算法,多为搜索排序。
同时使用`insert`来添加元素

```c++
vector<int> ivec={2,4,6,8,10};//ivec有8个元素

set<int> set2; //空集合

set2.insert(ivec.cbegin(),ivec.cend());//set2有4个元素

set2.insert({1,3,5,7,9});//set2现在有8个元素

```
关联容器操作：
`emplace(args)`:对于`map`和`set`,只有当元素的关键字不在`c`中时才插入(或者构造)元素。函数返回一个`pair`,包含一个迭代器，指向具体有指定关键字的元素，以及一个指示插入是否成功的bool值。

注意插入操作返回的是一个`pair`对象，第一个元素是差诶迭代器的坐标，第二个值是一个`bool`值，确定是否插入成功。

```c++
//统计每个单词在输入中出现的次数

map<string ,size_t> word_count;//从string到size_t的空map

string word;

while(cin>>word){
    //插入一个元素，关键字等于word，值为1；
    //若word已载word_count中，insert什么也不做
    auto ret=word_count.insert({word,1});

    if(!ret.second)  //word已经在word_count中

        ++ret.first->second; //递增计数器

/*

等价形式 ++((ret.first)->second);
ret 保存insert返回的值，是一个pair
ret.first 是pair的第一个成员，是一个map迭代器，指向具有给定关键字的元素
ret.first-> 解引用此迭代器，提取map中的元素，元素也是一个pair
ret.first->second; map中元素值的部分
++ ret.first->second; 递增此值
*/
}
```
#### 11.3.3 删除元素
使用`erase`函数来删除和释放元素;
```c++
auto cnt=authors.erase("Barth,Johns");
```

#### 11.3.4 map的下表操作

|操作|含义|
|:---|:---|
|`c[k]`|返回关键字为`k`的元素；如果`k`不在`c`中，添加一个关键字为`k`的元素，对其进行值初试化|
|`c.at(k)`|访问管家字为`k`的元素|

示例：
```c++
map <string ,size_t> word_count; //empty map

//插入一个关键字为Anna的元素，关联值进行值初试化；然后将1赋予它

word_count["Anna"]=1;

```
注意：

- 对一个`map`使用下表操作，使用一个不在容器中的关键字作为下表，会添加一个具有此关键字的元素到`map`中
- 与`vector`与`string`不同，`map`的下标运算符，返回的类型与解引用`map`迭代器得到的类型不同。
- `map`使用`find`代替下标操作
- `lower_bound`和`upper_bound`不适用于无序容器
- 下标和`at`操作只适用于非`const`的`map`和`unordered_map`

**关联容器中查找元素的操作**

|操作|含义|
|:---|:---|
|`c.find(k)`|返回一个迭代器，指向第一个关键字为`k`的元素，若`k`不在容器中则返回尾后迭代器|
|`c.count(k)`|返回关键字等于`k`的元素的数量。对于不允许重复关键字的容器，返回值永远是0或者1|
|`c.lower_bound(k)`|返回一个迭代器，指向第一个关键字不小于`k`的元素|
|`c.upper_bound(k)`|返回一个迭代器，指向第一个关键字不大于`k`的元素|
|`c.equal_range(k)`|返回一个迭代器`pair`，指向第一个关键字等于`k`的元素|

注意：
 
- 当我们遍历一个`multimap`或者`multiset`时，保证可以得到序列中所有具有给定关键字的元素。
- `lower_bound`返回的迭代器可能指向一个具有给定关键字的元素，但也可能不指向。如果关键字不在容器中，则`lower_bound`会返回关键字的第一个安全插入点--不影响容器中元素顺序的插入位置。
- 如果`lower_bound`和`upper_bound`返回相同的迭代器，则给定关键字不在容器中。

### 11.4 无序容器
无序关联容器总共有4个：`unordered_map`和`unordered_set`;

**桶管理**
无序容器在存储组织上为一组桶，每个桶保存0个或者多个元素。无序容器使用一个哈希函数将元素映射到桶。

**无序容器管理操作**

|操作|含义|
|:---|:---|
|**桶接口**|  |
|`c.bucket_count()`|正在使用的桶的数目|
|`c.max_bucket_count()`|容器能容纳的最多的桶的数量|
|`c.bucket_size(n)`|第n个桶中有多少个元素|
|`c.bucket(k)`|关键字为`k`的元素在那个桶中|
|**桶迭代**||
|`local_iterator`|可以用来访问桶中元素的迭代器类型|
|`const_local_iterator`|桶迭代器的`const`版本|
|`c.begin(n),c.end(n)`|与前两个函数类似，但返回`const_local_iterator`|
|**哈希策略**||
|`c.load_factor()`|每个桶的平均元素数量。返回`float`值|
|`c.max_load_factor()`|c维护桶的大小，返回`float`值。c会在需要时添加新的桶。以使得`load_factor<=max_load_factor`|
|`c.rehash(n)`|重组存储，使得`bucket_count>=n`且`bucket_count>size/max_load_factor`|
|`c.reserve(n)`|重组存储，使得c可以保存`n`个元素且不必`rehash`|

## 第 12 章 动态内存

### 12.1 动态内存与智能指针
在c++中动态内存管理是通过一对运算符来完成的：`new`和`delete`;同时为了更加安全的管理指针；标准库提供了两种 **智能指针** ：**shared_ptr**、**unique_ptr** ;前者允许多个指针指向同一个对象；后者独占所指对象。同时还有 **weak_ptr**的伴随类，他是一种弱引用，指向shared_ptr所管理的对象。三种类都定义在头文件memory中

当我们创建指针时，必须提供指针可以指向的类型。

```c++
shared_ptr<string> p1; //shared_ptr,可以指向string 

shared_ptr<list<int>> p2; //shared_ptr,可以指向int的list 
```

**shared_ptr和unique_ptr都支持的操作**

|操作|含义|
|:---|:---|
|`shared_ptr<T> sp unique_ptr<T> up`|空智能指针，可以指向类型为`T`的对象|
|`p`|将p用作一个条件判断，若`p`指向一个对象，则为`true`|
|`*p`|解引用p,获得它指向的对象|
|`p->mem`|等价于`(*p).mem`|
|`p.get()`|返回`p`中保存的指针，要小心使用；若智能指针释放了其对象，返回的指针所指向的对象也就消失了|
|`swap(p,q)/p.swap(q)`|交换`p`和`q`中的指针|

**share_ptr独有的操作**

|操作|含义|
|:---|:---|
|`make_shared<T>(args)`|返回一个`shared_ptr`,指向一个动态分配的类型为`T`的对象。使用`args`初始化此对象|
|`shared_ptr<T> p(q)`|p是`shared_ptr q`的拷贝；此操作会递增`q`中的计数器。`q`中的智能指针必须转化为`*T`|
|`p=q`|p和q都是`shared_ptr`，所保存的指针必须能够相互转换。此操作会递减`p`的引用计数，递增`q`的引用计数；若`p`的引用计数变为0，则将其管理的原内存释放|
|`p.unique()`|若`p.use_count()`为1，返回`true`;否则返回`false`|
|`p.use_count()`|返回与`p`共享对象的智能指针数量；可能很慢，主要用于调试|

注意：
- 我们通常使用`auto`作为`make_shared`指针函数所对应的值。
- 不要使用引用传递，在函数体内对智能指针`shared_ptr`进行赋值操作，计数会-1，离开函数作用域，局部变量销毁，计数可能为0.

计数递增情况：

- 一个`shared_ptr`初始化另外一个`shared_ptr`
- 作为参数传递给一个函数
- 作为函数的返回值

计数减少情况：

- `share_ptr`赋予一个新值
- `shared_ptr`被销毁--局部的`shared_ptr`离开其作用域。

注意：
- 如果将`shared_ptr`存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得`erase()`删除不再需要的那些元素。
- 使用动态内存的一个常见原因是允许多个对象，共享相同的状态。

#### 12.1.2 直接管理内存
c++可以使用`new`和`delete`直接管理内存；尽量在分配内存时，对动态分配内存的对象进行初始化操作。

```c++

int *p1=new int; //如果分配失败，new抛出std::bad_alloc;

int *p2=new (nothrow) int; //如果分配失败，new 返回一个空指针

delete p1,p2;
```
注意： 

- 我们传递给delete的指针必须指向动态分配的内存。或者是一个空指针。
- 不要随便删除一个空指针，可能在指针所指向的内存，被其它程序所使用，删除空指针，会造成极大的问题。
- 动态对象的生存周期是直到被释放为止。
- 由内置指针(而不是智能指针)管理的动态内存在被显式释放之前一直都会存在。
- 尽量坚持使用智能指针，防止内存分配错误
- 在删除指针之后使用`NULL/nullptr`使得指针悬空。
- 悬空只真对当前指针，对于和当前其它指向销毁内存对象的指针是没有作用的，尽量减少使用指针赋值和拷贝，或者直接使用shared_ptr智能指针。例如：

```c++
shared_ptr<int> p1=new int(1024); //错误；必须使用直接初始化形式。

shared_ptr<int> p2(new int(1024)); //正确：使用了直接初始化形式。

```

**定义和改变shared_ptr的其它方法**

|操作|含义|
|:---|:---|
|`shared_ptr<T> p(q)`|p管理内置指针q所指的对象；q必须指向`new`分配的内存，且能够转换为`T*`类型|
|`shared_ptr<T> p(u)`|p从unique_ptr u中接管了对象的所有权；将`u`置为空|
|`shared_ptr<T> p(q,d)`|p接管了内置指针q所指向的对象的所有权。q必须能转换为`T*`类型。p将使用可调用对象`d`来代替`delete`|
|`shared_ptr<T> p(p2,d)`|p是`shared_ptr p2`的拷贝,唯一的区别是`p`将使用可调用对象`d`来代替`delete`|
|`p.reset()`|若p是唯一指向其对象的`shared_ptr`，reset会释放此对象。|
|`p.reset(q)`|释放原有对象的同时，若传递了可选的内置参数指针`q`，会令`p`指向`q`，否则会将p置为空|
|`p.reset(q,d)`|若还传递了参数`d`,将会调用`d`而不是`delete`来释放`q`|

注意：

1. 不要混合使用普通指针和智能指针，很容易造成错误的析构
2. 不要使用get初始化另外一个智能指针或者为智能指针赋值，赋值给内置指针时，需要注意，不要让它管理的指针被释放。
3. 使用get返回指针的代码不能`delete`此指针。防止智能指针失效，成为野指针。
4. get用来将指针的访问权限传递给代码，只有确定代码不会delete指针的情况下，才能使用get。永远不要使用get初始化另外一个智能指针或者为另外一个智能指针赋值。
5. 智能指针指向新指针时，需要检查自己是否是当前对象仅有的用户。如果不是，在改变之前要制作一份新的拷贝。

```c++

if(!p.unique())
    p.reset(new string(*p)); //我们不是唯一的用户；分配新的拷贝

*p+=newVal; //可以改变对象的值

```
#### 12.1.4 智能指针和异常

注意，**智能指针陷阱**

基本规范：

- 不使用相同的内置指针值初始化(或reset)多个智能指针
- 不delete get()返回的指针
- 不使用 get()初始化reset另外一个指针
- 如果你使用get()返回的指针，记住，当最后一个指针对应的智能指针销毁后，你的指针就变为无效了
- 如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器。

#### 12.1.5 unique_ptr

**unique_ptr操作**

|操作|含义|
|:---|:---|
|`unique_ptr <T> u1`|空unique_ptr，可以指向类型为T的对象，u1会使用delete来释放它的指针|
|`unique_ptr <T,D> u2`|u2使用一个类型为D的可调用对象来释放它的指针|
|`unique_ptr <T,D> u(d)`|空unique_ptr，指向类型为T的对象，用类型为D的对象d代替delete|
|`u=nullptr`|释放u指向的对象，将u置为空|
|`u.release()`|u放弃对指针的控制权，返回指针，并将u置为空|
|`u.reset()`|释放u指针对象|
|`u.reset(q)/u.reset(nullptr)`|如果提供了内置指针q,令u指向这个对象；否则将`u`置为空|

unqiue_ptr不能共享所有权，但是可以将所有权，进行转移

```c++
//将所有权从一个unique_ptr转移给另一个unique

unique_ptr<string> p2(p1.release()); //release 将p1置为空

unique_ptr<string> p3(new string("Text"));
//将所有权从p3转移给p2

p2.reset(p3.release()); //reset释放了p2原来指向的内存

```

#### 12.1.6 weak_ptr

weak_ptr是一种不控制所指向兑现生存周期的智能指针，它指向一个由shared_ptr管理的对象。

**weak_ptr**

|操作|含义|
|:---|:---|
|`weak_ptr <T> w`|空`weak_ptr`可以指向类型为`T`的对象|
|`weak_ptr <T> w(sp)`|与`shared_ptr sp`指向相同对象的`weak_ptr`，T必须可以指向类型为`sp`的对象|
|`w=p`|p可以是一个`shared_ptr`或者一个`weak_ptr`。赋值后w与p共享对象|
|`w.reset()`|将w置为空|
|`w.use_count()`|与w共享对象的`shared_ptr`的数量|
|`w.expired()`|若`w.use_count()`为0，返回true，否则返回`false`|
|`w.lock()`|如果`expired`为`true`，返回一个空`shared_ptr`；否则返回一个指向`w`的对象的`shared_ptr`|

我们创建一个`weak_ptr`时，要用一个`shared_ptr`来初始化它：

```c++
auto p=make_shared<int>(42);

weak_ptr<int> wp(p);//wp 弱共享p;p的引用计数未改变，因此使用时必须使用函数lock()

if(shared_ptr<int> np=wp.lock()){//如果np不空则条件成立
    
    //在if中，np与p共享对象
}
```
### 12.2 动态数组

数组主要是为了更好的快速分配内存；大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且拥有更好的性能。

注意：

- 分配数组，会得到一个元素类型的指针。
- 动态分配一个空数组是合法的。
- 释放动态数组使用`delete []`,数组中的元素按逆序销毁。
- 数组指针需要使用`delete []`,单个对象需要使用`delete`,换用的行为都是未定义的。
- 未使用匹配的delete时，编译器很可能不会给出警告。程序可能在执行过程中没有任何警告的情况下行为异常。

初始化动态分配对象的数组

```c++
int *pia=new int[10]; //10个没有初始化的int

int *pia2=new int[10](); //10个初始化为0的int

string *psa=new string[10]; //10个空string

string *psa2=new string[10](); //10个空string

string *psa3=new string[10]{"a","an","the",sting(3,'x')}; //10个string初始化

```

**指针和动态数组**
```c++
unique_ptr<int []> up(new int[10]); //up指向10个未初始化int的数组

up.release(); //自动调用delete销毁其指针。
```

#### 12.2.2 allocator类

通常因为指针数组的定额分配可能产生内存浪费，因此需要`allocator`来进行内存分配。类似vector，allocator是一个模板，为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。当一个allocator对象分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位置：

```c++
allocator<string > alloc; //可以分配stringd allocator对象

auto const p=alloc.allocate(n); //分配n个未初始化的string
```
**标准库allocator类及其算法**

|算法|解释|
|:---|:---|
|`allocator <T> a`|定义了一个名为`a`的`allocator`对象，他可以为类型T的对象分配内存|
|`a.allocate(n)`|分配一段原始的、未构造的内存，保存n个类型为`T`的对象|
|`a.deallocate(n)`|释放从`T*`指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由`allocator`返回的指针，且n必须是p创建时所要求的大小。调用`dealocator`之前，用户必须对每个在这块内存中创建的对象调用`destroy`|
|`a.construct(p,args)`|p必须是一个类型为`T*`的指针，指向一块原始内存；arg被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象|
|`a.destroy(p)`|p为`T*`类型的指针，此算法对p指向的对象执行析构函数|

注意：

- allocator分配的内存时未构造函数的。我们按照需要在此内存中构造对象。
- 为了使用allocator返回的内存，我们必须使用construct构造对象。未使用构造的内存，其行为是未定义的。
- 我们只能对真正构造了的元素进行destory操作。

```c++
auto q=p;  // q指向最后构造的元素之后的位置

alloc.construct(q++);  //*q为空字符串

alloc.construct(q++,10,'c'); // *q为cccccccccc

std::cout<<*p<<endl; //正确：使用string 的输出运算符

cout<<*q<<endl;  // 灾难： q指向未构造的内存。

//使用完成必须对每个构造的元素调用destory来销毁它们

while (q!=p)
    alloc.destory(--q);  //释放我们真正构造的string，此时元素被销毁，可以重新使用这部分内存来保存其它string

alloc.deallocate(p,n);  //释放内存操作

```
**allocator 算法**

|算法|含义|
|:---|:---|
|`uninitialized_copy(b,e,b2)`|将迭代器b和e之间的输入，拷贝到迭代器b2指定的未构造的原始内存中，b2指向的内存必须足够大，能够容纳输入序列中元素的拷贝|
|`uninitialized_copy_n(b,n,b2)`|同上，从b开始拷贝n个元素到b2|
|`uninitialized_fill(b,e,t)`|在迭代器b和e指定的原始内存范围中创建对象，对象的值，均为t的拷贝|
|`uninitialized_fill_n(b,n,t)`|从b指向的内存地址开始创建n个对象，b必须指向足够大的内存|

使用示例：
```c++
//分配比vi中元素所占用空间大一倍的动态内存

auto p=alloc.allocate(vi.size()*2);
//通过拷贝vi中的元素来构造从p中开始的元素

auto q=uninitialized_copy(vi.begin(),vi.end(),p);
//将剩余元素初始值为42
uninitialized_fill_n(q,vi.size(),42);

```

# 第III 部分类设计者的工具

##第13 章拷贝控制
类的五种特殊成员函数:

- 拷贝构造函数
- 拷贝赋值构造函数
- 移动构造函数
- 移动赋值运算符
- 析构函数

注意：定义任何C++类的时候，拷贝控制操作都是必要部分。即使我们不显示定义这些操作，编译器也会为我们定义，但是编译器定义的版本的行为可能并非我们所想象。

### 13.1 拷贝、赋值与销毁

**合成拷贝构造函数**：用来阻止我们拷贝该类类型的对象。一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器给定对象中依次将每个非static成员拷贝到正在创建的对象中。

拷贝初始化发生情况：

- 使用`=`定义变量时会发生
- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用`{}`列表初始化一个数组中的元素或者一个聚合类中的成员
- 接收参数的构造函数，一般是explicit的
- 编译器可以绕过拷贝构造函数

```c++
vector<int> v1(10); //正确：直接初始化

vector<int> v2=10; //错误：接受大小参数的构造函数时explicit的

void f(vector<int>); //f的参数进行拷贝初始化

f(10); //错误；不能用一个explicit的构造函数拷贝一个实参

f(vector<int>(10));正确：从一个int直接构造一个临时的vector

string null_book="9-99-99";//拷贝初始化

string null_book("9-99-99"); //编译器略过了拷贝构造函数
//重载赋值运算符

class Foo{
public:
    Foo& operator=(const Foo&); //赋值运算符
    ...
}

Foo& Foo::operator=(const Sales_data &rhs){
    bookNo=rhs.bookNo;  //调用 string::opeator=

    units_sold=rhs.units_sold; //使用内置的int赋值

    ...
    return *this;
}
```
赋值运算符通常应该返回一个指向其左侧运算对象的引用

如果类没有定义自己的拷贝赋值运算符，编译器会为它生成一个 **合成拷贝赋值运算符**

析构函数调用情况

- 变量在理考作用域时被销毁
- 一个对象在被销毁时，其成员被销毁
- 容器(无论是标准库容器还是数组) 被销毁时，其元素被销毁
- 对于动态分配的对象，当对指向它的指针应用delete运算符进行销毁
- 临时对象，当创建它的完整表达式结束时被销毁。

注意：

- 析构函数调用时，先调用父类，再调用子类；与构造函数正好相反。
- 当指向一个对象的引用或者指针离开作用域时，析构函数不会执行。
- delete 删除指针，是删除指针指向的那块内存，指针本身仍旧存在，因此需要，键指针指向NULL防止错误

**三/五法则**
三个基本操作可以控制类的拷贝操作：

- 拷贝构造函数
- 拷贝赋值运算符
- 析构函数
- 如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数；反之亦然。
- 可以通过使用`=default`来显示地要求编译器生成合成的版本(默认构造函数)。
- 可以使用`=delete`来阻止默认的拷贝个赋值函数。
- 将拷贝和赋值拷贝设为私有函数，将使得用户代码不能拷贝这个类型的函数，用户代码在编译时错误，成员函数或者有元函数在连接诶时错误。
- 希望阻止拷贝的类应该使用`=delete`来定义他们自己的拷贝构造函数和拷贝赋值运算符，而不应该将他们声明为`private`的。

```c++
HasPtr HasPtr::operator=(const HasPtr &rhs)
{
    auto newp=new string(*rhs.ps) ;// 拷贝底层string

    delete ps; //释放旧内存

    ps=newp; //从右侧运算对象拷贝数据到本对象

    i=rhs.i;
    return this; //返回对象本身

}
```
当编写一个赋值运算符的时候，最好先将右侧运算对象拷贝到一个局部临时对象。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。

拷贝赋值运算符通常执行拷贝构造函数和析构函数也要做的工作，公共的工作应该放在`private`的工具函数中。

### 13.5 动态内存管理

简单标准库vector类的简化实现版本。

```c++
//stdvec.h
//类vector类内存分配策略的简化实现

class StrVec{
public:
    StrVec():
        elements(nullptr),first_free(nullptr),cap(nullptr){}
    StrVec(const StrVec&); //拷贝构造函数

    StrVec &operator=(const StrVec&); //拷贝赋值运算符

    ~StrVec();  //析构函数

    void push_back(const std::string&);  //拷贝元素

    size_t size() const {return first_free-elements;}
    size_t capacity() const {return cap-elements;}
    std::string *begin() const {return elements;}
    std::string *end() const {return first_free;}
    // ...
private:
    Static std::allocator<std::string> alloc; //分配元素
    //被添加元素的函数所使用
    
    void chk_n_alloc() {if(size()==capacity()) reallocate();}
    //工具函数，被拷贝构造函数、赋值运算符和析构函数所使用
    
    std::pair<std::string*,std::string*> alloc_n_copy(const std::string*,const std::string*);
    void free();  //销毁元素并释放内存

    void reallocate();  //获得更多内存并拷贝已有元素

    std::string *elemets;  //指向数组首元素的指针

    std::string *frist_free; //指向数组第一个空闲元素的指针

    std::string *cap; // 指向数组尾后位置的指针

};

//strvec.cpp

void Strvec::push_back(const string& s)
{
    chk_n_alloc();  //确保有空间容纳新元素

    //在frist_free指向的元素中构造s的副本
    
    alloc.construct(first_free++,s);
};

std::pair<std::string*,std::string*> alloc_n_copy(const std::string* b,const std::string* e)
{
    //分配空间保存给定范围中的元素
    
    auto data=alloc.allocate(e-b);
    //初始化并返回一个pair,该pair由data和uninitialized_copy的返回值构成
    
    return {data.uninitialized_copy(b,e,data)};
}

void StrVec::free()
{
    //不能传递给deallocate 一个空指针，如果elements为0，函数什么也不做
    
    if(elements){
        //逆序销毁旧元素
        
        for(auto p=first_free;p!=elements;)
        {
            alloc.destory(--p);
            alloc.deallocate(elements,cap-elements);
        }
    }
}

StrVec::StrVec(const StrVec &s)
{
    //调用alloc_n_copy 分配内存空间以容纳与s中一样多的元素
    
    auto newdata=alloc_n_copy(s.begin(),s.end());
    elements=newdata.frist;
    frist_free=cap=newdata.second;
}

StrVec::~StrVec(){free();}

StVec &StrVec::operator=(const StrVec &rhs)
{
    //调用alloc_n_copy 分配内存，大小与rhs中元素占用空间一样多
    
    auto data=alloc_n_copy(rhs.begin(),rhs.end());
    free();
    elements=data.first;
    frist_free=cap=data.second;
    return *this;
}

void StrVec::reallocate()
{
    //我们将分配当前大小两倍的内存空间
    
    auto newcapacity=size()?2*size():1;
    //分配新内存
    
    auto newdata=alloc.allocate(newcapacity);
    //将数据从旧内存移动到新内存
    auto dest=newdata;  //指向新数组中下一个空闲位置

    auto elem=elements; //指向旧数组中下一个元素

    for(size_t i=0;i!=size();++i)
    {
        alloc.construct(dust++,std::move(*elem++));
    }
    free(); //一旦我们移动完成元素就释放旧内存空间

    //更新我们的数据结构，执行新元素
    elements=newdata;
    first_free=dest;
    cap=element+newcapacity;

}
```

### 13.6 对象移动

注意：标准容器库、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。

使用`&&`来进行右值引用。右值引用--只能绑定到一个将要销毁的对象。**左值持久；右值短暂**。右值引用只能绑定到临时对象。

对于右值有：

- 所引用的对象，将要被销毁
- 该对象没有其他用户
- 使用右值引用的代码可以自由地接管所引用的对象的资源
- 变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型。
- 可以销毁一个移后对象，也可以赋予它新值，但不能够使用一个移后源对象的值。

使用move来获得绑定到左值上的右值引用`int &&rr3=std::move(rr1);`

注意：

- 不抛出异常的移动构造函数和移动赋值运算符必须标记为`noexcept`。
- 只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或者移动赋值时，编译器才会为它合成移动构造函数或者移动赋值运算符。
- 定义了一个移动构造函数或者移动赋值运算符符类，必须也定义自己的拷贝构造操作。否则，这些成员默认地被定义为删除的。
- 如果一个类有一个可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来“移动”的。拷贝赋值运算符和移动赋值运算符的情况类似。
- 移动赋值函数，相对拷贝构造函数，更减少资源的使用。
- 对象移动数据并不会销毁此对象，但有时在移动完之后，源对象会被销毁。编写移动操作时，必须保证源对象可以析构。
- 一个类集邮移动构造，又有拷贝构造，则移动是右值，拷贝是左值。
- 没有移动构造函数，右值也会被拷贝。但是编译器不会合成移动构造函数。即便是使用std::move也是调用的拷贝构造函数。
- 不要随意使用移动操作，一个移动源对象具有不确定的状态。当我们使用`move`时，必须绝对确认移后源对象没有其它用户。
- 移动接收`T&&`,拷贝接收`T&`

**左值和右值引用成员函数**
c++中允许右值进行赋值例如：

```c++
auto s1="hello";
auto s2="word";
s1+s2="wow!";
```
为了阻止这种情况的发生，使用 **引用限定符**：`&` 来强制指定左侧运算对象(即，this指向的对象)是一个左值。或者使用`&&`，强制指明，左侧运算对象是一个右值，例如：

```c++
class Foo{
public:
    Foo &operator=(const Foo&) &; //只能向可修改的左值赋值

}

class Foo{
public:
    Foo someMem() & const; //错误限定符const 必须在前
    
    Foo anotherMem() const &; //正确
}

Foo &retFoo();  //返回一个引用；retFoo调用时一个左值

Foo retVal();  // 返回一个值；retVal调用时一个右值

Foo i,j; //i,j均是左值

i=j; //正确：i是左值

retFoo()=j ;// 正确:retFoo()返回一个左值

retVal()=j; //错误:retVal()返回一个右值

i=retVal();  //正确：我们将一个右值作为赋值操作的右侧运算对象

//成员函数可以根据const区分其重载版本，引用也可以区分重载版本

class Foo{
public:
    Foo sorted() &&;  //可用于可改变的右值

    Foo sorted() const &; //可用于任何类型的Foo
}

//本对象为右值，因此可以原址排序

Foo Foo::sorted() &&
{
    sort(data.begin(),data.end());
    return *this;
}

//本对象是const或者是一个左值，不论何种情况我们都不能对其进行原址排序

Foo Foo::sorted() const & {
    Foo ret(*this);  //拷贝一个副本

    sort(ret.data.begin(),ret.data.end());  //排序副本

    return ret;  //返回副本

}

//这里编译器会根据sorted 的对象的左值/右值属性来确定使用那个sorted版本


```
注意： 如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。

## 第14 章 重载运算符与类型转换

重载的运算符是具有特殊名字的函数；他们的名字由关键字，operator和其后要定义的运算符共同组成。
注意：
- 一个类成员运算符函数，第一个运算对象绑定到隐式的`this`指针上。因此成员函数运算符函数的显示参数数量比运算符的运算对象，总少一个。
- 我们无法改版内置类型的运算符含义。
- 我们只能重载已有的运算符，而无权发明新的运算符号。例如我们不能提供operator**来执行幂操作。

**可重载运算符**

|运算符类型|运算符种类|
|:--|:---|
|双目算术运算符| `+ (加)，-(减)，*(乘)，/(除)，% (取模)`|
|关系运算符  | `==(等于)，!= (不等于)，< (小于)，> (大于>，<=(小于等于)，>=(大于等于)`|
|逻辑运算符  | `//(逻辑或)，&&(逻辑与)，!(逻辑非)`|
|单目运算符  | `+ (正)，-(负)，*(指针)，&(取地址)`|
|自增自减运算符 | `++(自增)，--(自减)`|
|位运算符 |   `/ (按位或)，& (按位与)，~(按位取反)，^(按位异或),，<< (左移)，>>(右移)`|
|赋值运算符  | `=, +=, -=, *=, /= , % = , &=, /(其实是竖着的)=, ^=, <<=, >>=`|
|空间申请与释放| `new, delete, new[ ] , delete[]`|
|其他运算符 |  `()(函数调用)，->(成员访问)，,(逗号)，[](下标)`|

**不可重载的运算符列表**

|运算符|含义|
|:---|:---|
|`.`|成员访问运算符|
|`.*, ->*`|成员指针访问运算符|
|`::`|域运算符|
|`sizeof`|长度运算符|
|`?:`|条件运算符|
|`#`| 预处理符号|

注意：

1. 运算重载符不可以改变语法结构。
2. 运算重载符不可以改变操作数的个数。
3. 运算重载符不可以改变优先级。
4. 运算重载符不可以改变结合性。

**类重载、覆盖、重定义之间的区别：**

重载指的是函数具有的不同的参数列表，而函数名相同的函数。重载要求参数列表必须不同，比如参数的类型不同、参数的个数不同、参数的顺序不同。如果仅仅是函数的返回值不同是没办法重载的，因为重载要求参数列表必须不同（发生在同一个类里）。

覆盖是存在类中，子类重写从基类继承过来的函数。被重写的函数不能是static的。必须是virtual的。但是函数名、返回值、参数列表都必须和基类相同（发生在基类和子类）

重定义也叫做隐藏，子类重新定义父类中有相同名称的非虚函数 ( 参数列表可以不同 ) （发生在基类和子类）。

操作符的等价调用：
```c++
data1+data2; //普通的表达式

operator+(data1,data2); //等价的函数调用

data1.operator+=(data2); //等价的函数调用

```

注意：尽量明智地使用运算符重载。只有当操作的含义对于用户磊说清晰明了时才能使用运算符。当其存在二意性时，最好不要使用。

### 14.2 输入和输出运算符

输出`<<`重载示例:

```c++
ostream &operator<<(ostream &os,const Sales_data &item)
{
    os<<item.isbn()<<" "<<item.units_sold<<""
    <<item.revenue<<" "<<item.avg_price();

    return os;
}
```
注意： 
- 输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。
- 输入输出运算符必须是非成员函数，不能是类的成员函数。否则，他们左侧运算对象将是我们的类的一个对象。

输入`>>`重载示例：

```c++
istream &opertaor>>(istream &is,Sales_data &item)
{
    double price;// 不需要初始化，因为我们将先读入数据到`price`,之后才使用它

    is>>item.bookNo>>iten.units_sold>>price;
    //检查输入是否成功

    if(is)
    {
        item.revenue=item.units_sold*price;
    }else{
        item=Sales_data(); //输入失败：对象呗赋予默认的状态

    }
    return is;


}
```
注意：

1. 当流含有错误类型的数据时，读取操作可能失败。之后的其他使用都将失败
2. 当读取操作达到文件末尾或者遇到输入流的其它错误时，也会失败
3. 当读取操作发生错误时，输入运算符应该负责从错误中恢复。

### 14.3 算术和关系运算符

注意：

- 如果同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。
- 如果某个类在逻辑上有相等性的含义，则该类应该定义`operator==`。
- 如果存在唯一一种可靠的`<`定义，则应该考虑为这个类定义`<`运算符。如果类同时还包含`==`，则当且仅当`<`的定义和`==`产生的结果一致时才睡定义`<`运算符。
- 重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。
- 赋值运算符必须定义为类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。

使用示例：

```c++
//重载赋值运算符
StrVec &StrVec::operator=(initializer_list<string> il)
{
    //alloc_copy分配内存空间，并从给定安慰内拷贝元素
    
    auto data=alloc_n_copy(il.begin(),il.end());
    free();  // 销毁对象中的元素并释放内存空间

    elements=data.frist;//更新数据成员，使其指向新空间

    first_free=cap=data.second; 
    return *this;  

} 

//重载复合赋值运算符

StrVec &StrVec::operator+=(initializer_list<string> il)
{
    unit_sold+=rhs.units_sold;
    revenue+=rhs.revenue;
    return *this;
}
```
### 14.5 下标运算符 `operator [] `
注意：

-  下标运算符必须是成员函数。
-  如果一个类包含下标运算符，则它通常会定义两个版本；一个返回普通引用，一个是类的常量成员并且返回常量引用。

使用示例:

```c++
class StrVec{
public:
    std::string& operator [](std::size_t n){return elements[n];}

    const std::string& operator[] (std::size_t n) const
    { return element[n];}

private:
    std::string *elements;  //指向数组首元素的指针
}

const StrVec cvec=svec;  //把svec的元素拷贝到cvec中

//如果svec中含有元素，对第一个元素运行string的empty函数

if(svec.size()&&svec[0].empty){
    svec[0]="zero";  //正确：下标运算符返回string的引用

    svec[0]="Zip";  //错误；对cvec取下标返回的是常量引用
}
```

### 14.6 递增和递减运算符

注意：

- 定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类的成员。
- 为了与内置版本保持一致，前置运算符应该返回递增或者递减后对象的引用。
- 为了与内置版本保持一致，后置运算符应该返回对象的原值(递增或者递减之前的值)，返回的形式是一个值而非引用。
- 因为我们不会用到`int`形参，所以无需为其命名。

```c++
//前置版本：返回递增/递减对象的引用

StrBlobPtr& StrBlobPtr::operator++()
{
    //如果curr已经指向了容器的尾后位置，则无法递增它
    
    check(curr,"xxxx");
    ++curr;  //将curr在当前状态下向前移动一个元素

    return *this;
} 

//后置版本:递增/递减对象的值，但是返回原值
StrBlobPtr StrBlobPtr::operator++(int)
{
    //此处无需检查有效性，调用前置递增运算时才需要检查
    
    StrBlobPtr ret=*this;  //记录当前的值

    ++*this   //向前移动一个元素，前置++需要检查递增的有效性

    return ret;  //返回之前记录的状态

}

```
**C++中 i++ 与++i 的区别**

- i++ 是指先使用i，只用之后再讲i的值加一，
- ++i 是将i的值先加一，然后在使用i；

如果i是一个整型变量那么i++ 与++i 几乎是没有区别的，在学习C++的后面会有迭代器，迭代器是一个对象，当i是迭代器时，那么++i的效率运行速度就比i++快；所以我们在一般的for循环语句中当i++与++i都可以使用时，可以考虑使用++i，养成一种良好的风格。

### 14.7 成员访问运算符

成员访问运算符，在 迭代器及智能指针类中常常见到解引用运算符`*`和箭头运算符`->`。我们以如下形式向`StrBlobPtr`类添加这两种运算符：

```c++
class StrBlobPtr{
public:
    std::string& operator*() const
    {
        auto p=check(curr,"dereference past end");
        return (*p)[curr];  //(*p)是对象所指的vector

    }
    std::string* operator->() const
    {
        //将实际工作委托给解引用运算符
        return& this->operator*();
    }
    //将两个运算符定义成了const成员，这是因为与递增和递减预算符不一样，获取一个元素并不会改变StrBlobPtr对象的状态
}
```
注意：

- 箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。
- 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象

### 14.8 函数调用运算符
如果类重载了函数调用运算符，则我们可以像使用函数一样灵活使用该类的对象。因为这样的类同时也能存储状态，所以与普通函数相比它们更加灵活。例如：

```c++
strcut absInt{
    int operator()(int val) const
    {
        return val<0?-val:val;
    }
};

//使用

int i=-42; 
absInt absObj;  // 含有函数调用运算符符对象

int ui=absObj(i);  //将i传递给absObj.operator()
```

注意：
- 函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或者类型上有所区别。
- 如果类定义了调用运算符，则该类的对象称作 **函数对象**。因为可以调用这种对象，所以我们说这些对象的“行为就像函数一样”。
- lambda是就是一个典型的函数对象。但是lambda表达式的类不含默认构造函数、赋值运算符及默认析构函数；它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定。
- 对于比较两个无关指针的内存地址，将产生未定义的行为，标准函数库提供了相关函数兑现进行定义。

**标准库函数对象**

|算术|关系|逻辑|
|:---|:---|:---|
|`plus<Type>`|`equal_to<Type>`|`logical_and<Type>`|
|`minus<Type>`|`not_equal_to<Type>`|`logical_or<Type>`|
|`multiplies<Type>`|`greater<Type>`|`logical_not<Type>`|
|`divides<Type>`|`greater_equal<Type>`||
|`modulus<Type>`|`less<Type>`||
|`negate<Type>`|`less_equal<Type>`||

```c++
vector<string  *> nameTable; //指针的vector
//错误会产生未定义的行为

sort(nameTable.begin(),nameTable.end(),[](string *a,string *b){return a<b;});
//正确：标准库规定指针的less是定义良好的

sort(nameTable.begin(),nameTable.end(),less<string *>());

```

**可调用对象与function**
c++中的可调用对象：

- 函数
- 函数指针
- lambda表达式
- bind创建的对象
- 重载了函数调用运算符的类

对于相似操作但是输入参数不同的情况，我们可以使用一个名为`function`的新标准库类型解决上述问题,`function`定义在`functional`头文件中。

**function的操作**

|操作|含义|
|:---|:---|
|`function<T> f`|f是一个用来存储可调用对象的空`function`,这些课调用对象的调用形式应该与`T`相同|
|`function<T> f(nullptr)`|显示构造一个空`function`|
|`function<T> f(obj)`|在f中存储可调用对象`obj`的副本|
|` f`|将f作为条件:当f含有一个可调用对象时为真；否则为假|
|`f(args)`|调用f中的对象，参数时`args`|

**定义为function<T>的成员类型**
|类型|含义|
|:---|:---|
|`result_type`|该function类型的可调用对象返回的类型|
|`argument_type`|当T有一个或者两个实参时定义的类型。T只有一个实参|
|`frist_argument_type`|当T有一个或者两个实参时定义的类型。T只有两个实参,第一个参数|
|`second_argument_type`|当T有一个或者两个实参时定义的类型。T只有一个实参,第二个参数|

使用示例：

```c++
function<int(int,int)> f1=add;  //函数指针

function<int(int,int)> f2=divide();  //函数对象类的指针

function<int(int,int)> f3=[](int i,int l){return i*j;};  //函数指针

cout<<f1(4,2)<<endl;  //打印

cout<<f2(4,2)<<endl;  //打印

cout<<f3(4,2)<<endl;  //打印8

//使用map映射

map<string,function<int(int,int)> > binops={
    {"+",add},  //函数指针

    {"-",std::minus<int>()},  //标准库函数对象

    {"/",divide()},  // 用户定义的函数对象

    {"*",[](int i,int j){return i*j;}},  //未命名的lambda

    {"%",mod} //已命名的lambda对象
};
```
注意：
新版本标准库中的`function`类与旧版本中的`unary_function`和`binary_function`没有关联，后两个类已经被更加通用的`bind`函数代替了。

### 14.9 重载、类型转换和运算符

**类类型转换：** 将实参类型对象隐式转换为类类型，转换构造函数和类型转换运算符共同定义类类型转换，也称作 **用户定义的类类型转换**。

例如：`double b=3.141516;int a=(int)b;`

**类型转换运算符：** 将一个类类型的值转换成其它类型。一般形式如下:
`operator type() const`


注意：

- 一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参类表也必须为空。类型转换函数通常应该是`const`。
- 类型转换运算符可能产生意外结果，例如bool类型转换，能被隐式地转换为int类型输出。
- 为了防止上一条情况发撒恒，c++11定义了显示的类型转换运算符；例如：

```c++
class SmallInt{
public:
    //编译器不会自动执行这一类型转换

    explicit operator int() const {return val;}
}
//显式地请求类型转换

SmallInt si=3;
static_cast<int>(si)+3;
```
- 向bool的类型转换通常用在条件部分，因此`operator bool`一般定义成`explicit`的。
- 通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或者转换目标是算术类型的转换。
- 当我们使用两个用户定义的类型转换时，如果转换函数之前或者之后存在标准类型转换，则标准类型转换将决定最佳匹配到底是哪个
- 除了显式向bool类型的转换为，应该尽量避免定义类型转换函数并尽可能地限制“显然正确”的非显式构造函数。
- 如果在调用重载函数时，需要构造函数或者强制类型转换来改变实参类型，则这通常意味着程序设计存在不足。
- 在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型不止一个，则该调用具有二义性。

#### 14.9.3 函数匹配与重载运算符

注意：

- 表达式中运算符的候选函数集即应该包括成员函数，也应该包括非成员函数。
- 如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到运算符与内置运算符符二义性问题。

例如：
```c++
class SmallInt{
    friend SmallInt operator+ (const SmallInt&,const SmallInt&);
public:
    SmallInt(int =0);  // 转换源为int的类型转换

    operator int() const {return val;} //转换目标为int的类型转换

private:
    std::size_t val;
};

SmallInt s1,s2;
SmallInt s3=s1+s2;   //使用重载的operator+

int i=s3+0;  //二义性错误

```

## 第15章 面向对象程序设计

### 15.1 oop:概述
面向对象程序设计的核心思想是数据抽象、继承和动态绑定。

**虚函数：** 基类希望它的派生类各自定义适合自身版本，将这些函数声明为**虚函数**；派生类必须通过派生类列表明确指明他是从那个基类继承而来的。即 **基类希望派生类能进行覆盖的函数**

**动态绑定**
通过**动态绑定**，我们能用同一段代码分别处理不同的对象。相同函数，根据动态绑定的对象实质进行区别。在运行时选择函数的版本，所以动态绑定有时又被称为 **运行时绑定**

注意：

- 在c++语言中，当我们使用基类的引用(或者指针)调用一个虚函数时将发生动态绑定。

### 15.2 定义基类和派生类

注意：

- 基类同城都应该定义一个虚析构函数，计时该函数不执行任何实际操作也是如此。
- 如果一个派生类没有覆盖其基类中的某个虚函数，则该函数的行为类似于其他成员，派生类会直接继承其在基类中的版本。
- 同一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的。

```c++
class Quote{
public:
    Quote()=default;
    Quote(const std::string &book,double sales_price):bookNo(book),price(sales_price){}
    std::string isbn() const {return bookNo;}
    //返回给定数量的书籍的销售总额
    
    //派生类负责改写并使用不同的折扣计算算法
    
    virtual double net_price(std::size_t n) const
    {return n*price;}

    virtual ~Quote()=default; //对析构函数进行动态绑定
private:
    std::string bookNo;  //书籍编号

protected:
    double price=0.0   //普通状态下不打折扣的价格 

}

```

可以将派生类的对象当成基类来使用，而且也能将基类的指针或者引用绑定到派生类对象中的基类部分上。

```c++
Quote item;  //基类对象

Bulk_quote bulk;  //派生类对象

Quote *p=&item;  //p指向Quote对象

p=&bulk; //p指向bulk的Quote的部分

Quote &r=bulk;  //r绑定到bulk的Quote部分

```
上述转换可以把派生类对象的指针用在需要基类指针的地方。
注意：

- 在派生类对象中含有与基类对应的组成部分，这一事实是继承的关键。
- 派生类不能直接初始化继承的基类成员，必须使用基类的构造函数来初始化它的基类部分；每个类控制它自己的成员初始化过程。
- 除非我们特别指出，否则派生类的基类部分会像数据成员一样执行默认初始化。如果需要使用基类的构造函数需要，使用`基类名(参数1，参数2)` 的形式进行显式调用。否则进行一般空参数的默认初始化。
- 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。
-  **c++中类，是在实例化时才会查找相关代码，没有使用就不会生成对应代码，函数无论使用都会生成。**
-  类会自动生成一个`namespace`,其中的静态成员和静态变量，相当于`namespace`中的变量和函数。
-  如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。
-  如果我们想要某个类用作基类，则该类函数必须已经定义而非仅仅声明。主要是构造函数和成员变量必须定义，因为子类的构造函数必须使用父类的构造函数。
-  在类后面添加关键字`final`可以有效防止类被继承。
-  和内置指针一样，智能指针类也支持派生类向基类的类型转换，意味着我们可以将一个派生类对象的指针存储在一个基类指针的只能指针内。

**基类和派生类**

不存在基类向派生类的隐式类型转换，但是当编译器无法确定某个特定的转换在运行时是否安全的时候，则可以，但这是很危险的，并且基类函数的析构函数最好是虚析构函数。([C++中虚析构函数的作用](https://www.cnblogs.com/lit10050528/p/3874703.html))

```c++
Bulk_quote bulk;
Quote *itemP=&bulk;  //正确；动态类型是Bulk_quote

Bulk_quote *bulkP=itemP;  //错误，不能将基类转换成派生类

```

派生类向基类的自动类型转换，支队指针或者引用类型有效，在派生类类型和基类类型之间不存在这样的转换。

当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。

存在继承关系的类型之间的转换规则

- 从派生类向基类的类型转换只对指针或引用类型有效
- 基类向派生类不存在隐式类型转换
- 和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。

### 15.3 虚函数

**虚函数的调用可能在运行时才被解析**

注意：

- 一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。
- 一个派生类的函数如果覆盖了继承来的虚函数，则它的形参类型必须被它覆盖的基类函数完全一致;返回类型也必须相同。形参列表不同时会产生新的函数，继承的基类函数仍旧有效。
- 使用`override`关键字可以明确重载，原函数中没有函数，或者参数不对应则都会产生错误。
- 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。

**回避虚函数的机制**

可以使用作用域运算符，实现虚函数的强行绑定，而非动态绑定；例如：

```c++
double undiscounted=baseP->Quote::net_price(42);
//强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么

```

通常情况下，只有成员函数(或者友元)中的代码才需要使用作用域运算符来回避虚函数的机制。通常是一个派生类的虚函数调用它覆盖的基类的虚函数版本时。

注意：如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。

### 15.4 抽象基类

含有纯虚函数的类是抽象基类；不能创建抽象基类的对象，只能被继承

重构：负责重新设计类的体系以便将操作或数据从一个类移动到另外一个类中。

### 15.5 访问控制与继承

protect:希望派生类分享但是不想被其他公共访问使用的成员。

- 受保护的成员对于类的用户来说是不可访问的。
- 受保护的成员，对于派生类的成员和友元来说是可以访问的
- 派生类或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类的受保护成员没有任何访问特权。

```c++
class Base{
protected:
    int prot_mem;  //protected 成员

};
class Sneaky:public Base{
    friend void clobber(Sneaky&);  //能访问Sneaky::prot_mem

    friend void clobber(Base&);  //不能访问Base::prot_mem

    int j;  
}
void clobber(Sneaky& s) {s.j=s.prot_mem=0;} //正确能访问Sneaky对象的private和protected成员

void clobber(Base& b){b.prot_mem=0;}//错误不能访问protected的成员

```
private 不影响派生类的访问权限，主要影响，相关函数的使用。

**派生类向基类转换的可访问性**

- 只有当D公有地继承B时，用户代码才能够使用派生类向基类的转换；如果D继承B的方式是保护的或者私有的，则用户代码不能使用该转换。
- 不论D以什么方式继承B,D的成员函数和友元都能使用派生类向基类的的转换；派生类向其会直接基类的类型转换对于派生类的成员和友元来说是永远可以访问的。
- 如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换；反之，如果D继承B的方式是私有的，则不能使用
- 对于代码中的某个给定节点来说，如果基类的公有成员是可以访问的，则派生类向基类的类型转换也是可访问的；反之则不行。

**友元与继承**

友元关系不能继承，友元关系也不能传递，基类的友元在访问派生类成员时，不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。-- **不能继承友元关系，每个类负责控制各自成员的访问权限**

**改变个别成员的可访问性**

通过`using`声明可以改变派生类继承的某个名字的访问级别。

```c++
class Base{
public:
    std::size_t size() const {return n;}
protected:
    std::size_t;
};

class Derived: private Base{
public:
    using Base::size;  //保持对象尺寸相关的成员的访问级别

protected:
    using Base::n; //使用using关键字改变成员变量的访问级别。

};

```

- `private using` 该名字能被类的成员和友元访问；
- `public using` 类的所有成员都能访问。
- `protectde using` 类的成员、友元和派生类是可访问的。

### 15.6 继承中的类作用域

每个类定义自己的作用域，；当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。如果一个名字在派生类的作用域内无法正常解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。例如：

```c++
Bulk_quote bulk;
cout<<bulk.isbn();

//查找步骤：先找自身作用域内函数，再找父类，和父类的父类

```
静态类型：在编译时总是已知的，它是变量声明时的类型或表达式生成的类型
动态类型：变量或表达式表示的内存中的对象的类型。

注意：

- 派生类的成员将隐藏同名的基类成员
- 可用通过作用域运算符来使用一个呗隐藏的基类成员
```c++
struct Derived:Base{
    int get_base_mem(){
        return Base::mem;
    }
}

```

- 除了覆盖继承而来的虚函数之外，派生类最好不要中庸其它定义在基类中的名字。

**关键概念:名字夜找与继承**

------

理解函数调用的解析过程刘一于理解C++的继承至关重要，假定我们调用`p->mem()`(或者obj.mem())，则依次执行以下4个步骤:

- 首先确定p(或obj)的静态类型因为我们调用的是一个成员，所以该类型必然是类类型    
- 在p(或。bj)的静态类型对应的类中查找mem如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端如果找遍了该类及其基类仍然找不到，则编译器将报错
- 一旦找到了mem,就进行常规的类型检查(参见6.1节，第183页)以确认对于当前找到的mem，本次调用是否合法
- 假设调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码:      一如果mem是虚函数且我们是通过引用或指针进行的调用，则编译器产生的代          码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型、      一反之，如果mem不是虚函数或者我们是通过对象(而非引用或指针)进行的          调用，则编译器将产生一个常规函数调用。

```c++
struct Base{      
int  memfcn();
};
struct DerivPd:Base{
    int memfcn(int);  //隐藏基类的memfn

};

Derived d;Base b;

b.memfcn();  //调用Base::memfn

d.memfcn(10);  //调用Derived::memfcn

d.memfcn();   //错误：参数列表为空的memfcn被隐藏了

d.Base::memfcn();  //正确：调用Base::memfcn()

```
**通过基类调用隐藏的虚函数**

```c++
class Base{
public:
    virtual int fcn();
};
class D1:public Base{
public:
    //隐藏基类的fcn,这个fcn不是虚函数
    
    //D1继承了Base::fcn()的定义

    int fcn(int);  //形参列表与Base中的fcn不一致

    virtual void f2();  //是一个新的虚函数，在Base中不存在
};

class D2:public D1{
public:
    int fcn(int);   //一个非虚函数，隐藏了D1::fcn(int)

    int fcn();    //覆盖了Base的虚函数fcn

    void f2();  // 覆盖了D1的虚函数f2
}



Base bobj;
D1 d1obj;
D2 d2obj;

Base *bp1=&bobj,*bp2=&d1obj,*bp3=&d2obj;

bp1->fcn();  //虚调用，将在运行时调用Base::fcn()

bp2->fcn();  //虚调用，将在运行时调用Base::fcn()

bp2->fcn();  //虚调用，将在运行时调用D2::fcn()

Base *pd=&d2obj;
D1 *p2=&d2obj;
D2 *p3=&d2obj;

p1->fcn(42);  //错误：Base中没有接受一个int的fcn

p2->fcn(42);  //静态绑定，调用D1::fcn(int)

p3->fcn(42);  //静态绑定，调用D2::fcn(int)

```

类内using声明的一般规则同样适用于重载函数的名字，基类函数的每个实例在派生类中都必须是可访问的，对派生类没有重新定义的重载版本的访问，实际上是对using 声明点的访问。

### 15.7 构造函数与拷贝控制

虚析构函数将阻止合成移动操作：
如果一个类定义了析构函数，即使它通过`=default`的形式使用了合成的版本，编译器也不会为这个类合成移动操作。

**派生类中删除的拷贝控制与基类的关系**

某此定义基类的万式也可能导致有的派产仁类成员成为被删除的函数：

- 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或艺不可访问，则派生类中对应的成员将是被删除的，原因是编译器小能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作。
- 如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认拷贝和构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。
- 和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用=default请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动，如果基类的析构函数是删除或不可访问的，则派牛类的移动构造函数也将是被删除的。

注意：

- 当派生类定义了拷贝或者移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。
- 在默认情况下，基类默认构造函数初始化派生类对象的基类部分如果我想拷贝(或移动)基类部分，则必须在派生类的构造函数初始值列表中显地使用基类的拷贝(或移动)构造函数。
- 如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。
- 构造函数的using 声明不会改变该构造函数的访问级别。
- 基类构造函数的默认实参，并不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。如果一个构造函数接收两个形参后一个由模式实参，则派生类将获得两个构造函数一个函数接受两个形参(没有默认实参)，另外一个构造函数只接受一个形参，它对应于基类中最左侧的没有默认值的那个形参。
- 如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承。定义在派生类中的构造函数将替换继承来的构造函数
- 继承的构造函数不会被作为用户定义的构造函数来使用，如果一个类只含有继承的构造函数，则他也将拥有一个合成的默认构造函数。

### 15.8 容器与继承

**当派生类对象被赋值给基类对象的时候，其中的派生部分将被“切掉”，因此容器和存在继承关系的类型无法兼容；因此最好在容器中放置(智能)指针而非对象**

**模拟拷贝**
给类添加一个虚拷贝函数，该函数将申请一份当前对象的拷贝。处理动态的内存分配

```c++
class  Quote{
public:
    //该虚函数返回当前对象的一份动态分配的拷贝
    
    virtual Quote* clone() const& {return new Quote(*this);} // const& 是对this的修饰,标明这个this是 const引用
    virtual Quote* clone() && {return new Quote(std::move(*this));}  // && 也是对this的修饰,表示由对象this指针生成的一个右值
}

```


## 第16章 模板与泛型编程

通用函数模板实现函数的泛化([函数模板的定义实现分别放在.h和cpp中将会遭遇symbol问题参考](https://blog.csdn.net/Raptor_2017/article/details/77689009))：
```c++
template <typename T>
int compare(const T &v1,const T &v2){
    if(v1<v2) return -1;
    if(v2<v1) return 1;
    return 0; 
}

cout<<compare(1,0)<<endl;// T为int

cout<<compare(vec1,vec2)<<endl;  // T 为vector<int >
```
注意： 在模板定义中模板参列表不能为空

当使用模板的时候，我们指定模板实参，将其绑定到模板参数上。
模板类型参数，可以像内置类型或者类类型说明符一样使用。

```c++
template <typename T,class u> T foo (T* p,u test)
{
    T tmp=*p;  //tmp的类型将是指针p指向的类型
    //...
    
    return tmp;
}
```
**非类型模板参数**

可以在模板中定义非类型模板参数。一个非类型模板参数表示一个值而非一个类型。

```c++
template <unsigned N,unsigned M>

int compare(const char (&p1)[N],const char (&p2)[M])
{
    return strcmp(p1,p2);
}

compare("hi","mom");
//编译器实例化版本

int compare(const char (&p1)[3],const char (&p2)[4]);
```
注意： 

- 非类型模板参数的模板实参必须是常量表达式。
- 模板程序应该尽量减少对实参类型的要求。
- 编译器遇到一个模板定义的时，并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。
- 保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能够正确工作，是调用者的责任。

**inline和constexpr的函数模板**

```c++
//正确：inline说明符跟在模板参数列表之后

template <typename T> inline T min(const T&,const T&);
//错误：inline说明符的位置不正确

inline template <typename T> T min(const T&,const T&);
```
#### 16.1.2 类模板
编译器不能为类模板推断模板参数类型，为了使用类模板，我们必须在模板名后的尖括号中提供额外的信息。用来代替模板参数的模板实参列表。这也决定了使用模板的时候需要我们提供 **显示模板实参**；

注意：

一个类模板的每个实例都形成了一个独立的类。类型`Blob<string>`与任何其他Blob类型都没有关联，也不会对任何其它Blob类型的成员有特殊访问权限。

```c++
//定义模板类

template <typename T> class Blob
{
public:
    typedef T value_type;
    typedef typename std::vector<T>::size_type size_type;
    Blob(std::initializer_list<T> il);
}


//模板类成员

template <typename T>
T& Blob<T>::back()
{
    check(0,"back on empty Blob");
    return data->back();
} 
template <typename T>
T& Blob<T>::operator[](size_type i)
{
    //如果i太大，check会抛出异常，阻止访问一个不存在的元素
    
    check(i,"subscript out of range");
    return (*data)[i];
}

```
默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化。如果成员函数没有被使用，则它不会被实例化。

**在类模板自己的作用域中，我们可以直接使用模板名而不提供实参**

**在类模板外使用类模板名时，我们并不在类的作用域中，直到遇到类名才表示进入类的作用域**

```c++
template <typename T>
BlobPtr<T> BlobPtr<T>::operator++(int)
{
    //此处无需检查；调用前置递增时会进行检查

    BlobPtr ret=*this;  //保存当前值

    ++*this; //推进一个元素；前置++检查递增是否合法

    return ret;  //返回保存的状态
}

```
在一个类模板的作用域内，我们可以指直接使用模板名而不必指定模板实参。

可以使用typedef来定义模板类的别名。
一个`static`成员函数只有在使用的时候才会实例化。

#### 16.1.3 模板参数
一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。模板参数会隐藏外层作用域中声明的相同的名字。与大多数其他上下文不同，在模板内不能重用模板参数名。

```c++
typedef double A;
template <typename A,typename B> void f(A a,B b)
{
    A tmp=a;// tmp的类型为模板参数A的类型，而非double

    double B; //错误： 重声明模板参数
}
```
**模板声明**

```c++
//声明但不定义compare和Blob

template <typename T> int compare(const T &,const T&)

template <typename T> class Blob;
```
一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现与任何使用这些模板的代码之前

注意：
当我们希望通知班一起一个名字表示类型的时候，必须使用关键字`typename`,而不能使用`class`；

对于static修饰的函数使用函数模板的时候，为了处理模板，编译器必须知道名字是否表示一个类型。默认情况下，c++语言假定通过作用域运算访问的名字不是类型。使用一个模板类型参数的类型成员，就必须显示告诉编译器该名字是一个类型，使用`typename`实现
```c++
template <typename T>
typename T::value_type top(const T& c)
{
    if(!c.empty())
        return c.back();
    else
        retrun typename T::value_type();
}

```
**默认模板实参**
c++11允许为函数和类模板提供默认实参。例如：

```c++
template <typename T,typename F=less<T> >
int compare(const T &v1,const T &v2, F f=F())
{
    if(f(v1,v2)) return -1;
    if(f(v2,v1)) return 1;
    return 0;
}
//compare 有一个默认模板实参 less<T> 和一个默认函数实参F()

template <class T=int> class Numbers{ //T 默认为int
    
public:
        Numbers(T v=0):val(v){}
}

```
#### 16.1.4 成员模板
一个类可以包含本身就是模板的成员函数。这种成员被称为 **成员模板**。成员模板不能是函数。

```c++
class DebugDelete{
public:
    DebugDelete(std::ostream &s=std::cerr):os(s){}
    //与任何函数模板相同，T的类型由编译器推断

    template <typename T> void operator() (T *p) const
    {os<<"deleting unique_ptr"<<std::endl;delete p;}

private:
    std::ostream &os;

}

```
#### 16.1.5 控制实例化
模板使用的时候会通过编译器推断，生成对应类型的函数。当两个或者多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个示例，使得相同模板的额外开销特别严重。在新标准中通过 **显示实例化**来避免这种开销。 先声明再实例化，但是`extern` 声明必须出现在任何使用实例化版本的代码之前。[参考链接](https://blog.csdn.net/Raptor_2017/article/details/77689009)

```c++
extern template declaration;  //示例化声明

template declaration;  //实例化定义

//下面的这些模板类型必须在程序其它位置进行实例化

extern template class Blob<string>;
extern template int compare(const int&.const int&);
Blob<string> sa1,sa2;  //示例化会出现在其它位置

Blob<int> a1={0,1,2,3,4,5,6,7,8,9};
Blob<int> a2(a1);  //拷贝构造函数在本文件中实例化

int i=compare(a1[0],a2[0]);  //实例化出现在其它位置

//templateBuild.cc

//实例化文件必须为每个在其它文件中声明为extern的类型和函数提供一个(非extern)的定义

template int compare(const int&,const int&);
template class Blob<string>;  
//实例化类模板的所有成员

```
当编译器遇到一个实例化定义(与声明相对)时，它为其生成代码。需要将生成的.o文件链接到一起。

注意： 
- 对每个实例化声明，在程序中某个位置必须有其显示的实例化定义。
- 一个类模板的示例化定义会实例化该模板的所有成员，包括内联的成员函数。
- 在一个类模板的实例化定义中，所用类型必须能用于模板的所有成员函数。

### 16.2 模板实参推断

编译器利用调用中的函数实参来确定其模板参数的过程被称为 **模板实参推断**。在模板实参推断过程中，编译器使用函数调用中的实参类型来寻找模板实参，用这些模板实参生成的函数版本与给定的函数调用最为匹配。

- 顶层`const`无论是在形参还是实参中，都会被忽略。
- const转换：可以将一个非const对象的引用（或指针）传递给一个const的引用(或指针)形参。
- 数组或函数指针转换：如果函数形参不是引用来兴，则可以对数组或者函数类型的实惨应用正常的指针转换。一个数组实参可以转化为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针。

**不能应用与函数模板的转换**

- 算术转换
- 派生类向基类的转换
- 用户定义的转换
使用示例：

```c++
template <typename T> T fobj(T,T); //实参拷贝

template <typename T> T fref(const T&,const T&); //引用

string s1("a value");

const string s2("nihao ");
fobj(s1,s2); //调用fobj(string，string)；const 被忽略

fref(s1,s2);//调用fref(const string&,const string&) 将s1转换为const是允许的

int a[10],b[42];

fobj(a,b);  //调用 f(int*,int*)

fref(a,b);  //错误：数组类型不匹配；如果形参是一个引用，则数组不会转换为指针，大小不匹配因此不合法。

```

注意： 
- 将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组或函数到指针的转换。
- 如果函数参数类型不是模板参数，则对实参进行正常的类型转换。

#### 16.2.2 函数模板显示实参

**指定显式模板实参**

定义返回类型的第三个模板参数，从而允许用户控制返回类型：

```c++

template <typename T1,typename T2,typename T3>
T1 sum(T2,T3); 
//编译器无法推断T1，它未出现在函数参数列表中

//显示指定T1帮助实参进行类型推断。

auto val3=sum<long long>(i,lng); // long long sum(int ,long)

//用户必须指定所有三个模板参数

template <typename T1,typename T2, typename T3>
T3 alternative_sum(T2,T1);
//错误：不能推断前几个模板参数

auto val3=alternative_sum<long long>(i,lng);
//正确： 显示指定了所有三个参数

auto val2=alternative_sum<long long ,int,long>(i,lng);


```
**显式模板实参按照由左至右的顺序与对应的参数模板匹配**

#### 16.2.3 尾置返回类型与类型转换

尾置返回允许我们在参数累彪之后声明返回类型；编译器会根据实例化的输入，动态判断返回类型。
```c++
template <typename It>
auto fcn(It beg,It end)->decltype(*beg)
{
    //处理序列

    return *beg; // 返回序列中一个元素的引用
}

template <typename It>
auto fcn2(It beg,It end)->
    typename remove_reference<decltype(*beg)>::type //获取元素类型

    //decltype(*beg)返回元素类型的引用类型
    
    //remove_reference::type 脱去引用，剩下元素类型本身

{
    //处理序列

    return *beg; // 返回序列中一个元素的拷贝
}

```
**标准类型转换模板**

|对`Mod<T>`,其中`Mod`为|若`T`为|则`Mod<T>::type`为|
|:---|:---|:---|
|`remove_reference`|`X&`或`X&&`|`X`|
||否则|`T`|
|`add_const`|`X&`或`const X`或函数|`T`|
||否则|`const T`|
|`add_lvalue_reference`|`X&`|`T`|
||`X&&`|`X&`|
||否则|`T&`|
|`add_rvalue_reference`|`X&`或`X&&`|`T`|
||否则|`T&&`|
|`remove_pointer`|`X*`|`X`|
||否则|`T`|
|`add_pointer`|`X&`或`X&&`|`X*`|
||否则|`T*`|
|`make_signed`|`unsigned X` |`X`|
||否则|`T`|
|`make_unsigned`|带符号类型|`unsigned X`|
||否则|`T`|
|`remove_extent`|`X[n]`|`X`|
||否则|`T`|
|`remove_all_extent`|`X[n1][n2]...`|`X`|
||否则|`T`|

#### 16.2.4 函数指针和实参推断
可以使用指针指向模板函数的实例;
```
template <typename T> int compare(const T&,const T&);
//指针pf1指向实例 int compare(const int&, const int&)

int (*pf1)(const int& ,const int&)=compare
//pf1中参数的类型决定了T的模板实参的类型


```

当参数是一个函数模板实例的地址时，程序上下文必须满足对每个模板参数，能唯一确定其类型或值。

#### 16.2.5 模板实参推断和引用

**从左值引用函数参数推断类型**
```c++

template <typename T> void f1(T&); //实参必须是一个左值
//实参类型为模板参数类型

f1(i); // i是int T是int

f1(ci);//ci 是const int;模板参数T是const int

f1(5); // 错误传递给&参数的实参必须是一个左值 

template <typename T> void f2(const T&); // 可以接受一个右值

//f2中的参数是const &;实参中的const 是无关的。

//在每个调用中，f2的函数参数都被推断为 const int&

f2(i);  //模板参数是int

f2(ci); // 模板参数是 int 

f2(5); //一个const &参数可以绑定到一个右值；T是int

```

**从右值引用函数参数推断类型**

类型推断过程类似普通左值引用函数参数的推断过程。

**引用折叠和右值引用参数**

- 当文将一个左值传递给函数的右值引用参数，且此右值引用指向模板类型参数(T&&)时，编译器推断模板类型参数为实参的左值引用类型。因此，当使用f3(i)时，编译器推断T的类型为int&,而非int
- 如果我们间接创建一个引用的引用，则这些引用形成了“折叠”。在所有情况下，引用会折叠成一个普通的左值引用类型。
- 特殊情况下，引用会折叠成右值引用：右值引用的右值引用。即，对于一个给定类型X:
    + X& &、X& &&和X&& &都折叠成类型X&
    + 类型X&& && 折叠成X&&
- 引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数。

折叠规则和右值引用的特殊类型推断规则结合在一起的时候，可以左值调用`f3`,编译器推断`T`为一个左值引用类型：

```c++
f3(i); //实参是一个左值；模板参数T是 int&

f3(ci); //实参是一个左值；模板参数T是一个const int&

void f3<int&>(int& &&); //当T是int&时，函数参数为int& &&

void f3<int&>(int&); //当T是int&时，函数参数折叠为 int& 

```
结果：

- 如果一个函数参数是一个指向模板类型参数的右值引用(如，T&&),则它可以被绑定到一个左值；可以传递给它任意类型的实参。
- 如果一个左值传递给这样的参数，则函数参数被示例化为一个普通的左值引用(T&)。 

接受右值引用参数的模板函数
```c++
template <typename T> void f3(T&& val)
{
    T t=val; //右值调用f3，f3(42),T为int ;左值i调用f3，T为int&；t类型为 int& .t的初始化值绑定到了val，对t赋值时，也改变了val的值。在下面的判断中永远得到true

    t=fcn(t);//当T为右值时，职高部t，当T为左值时，都改变

    if(val==t){
        /*
        若T是引用类型，则一直为true
        */

    }

}

template <typename T> void f(T&&);  //绑定到非const右值

template <typename T> void f(const T&);  //左值和const右值

```
#### 16.2.6 理解std::move

std::move的定义：

```c++

template <typename T>

typename remove_reference<T>::type&& move(T&& t)
{
    return static_cast<typename remove_reference<T>::type&& >(t);
}
// move的函数参数T&&是一个指向模板类型参数的右值引用。通过引用折叠，参数可以与任何类型的实参匹配。

//接下来使用remove_reference获取T的真实类型

//最后使用静态指针变量使得获得指针的右值引用。

```

#### 16.2.7 转发
- 如果一个函数参数是指向模板类型参数的右值引用(如T&&),它对应的实参的const属性和左值/右值属性将得到保持。
- 当用于一个指向模板参数类型的右值引用函数参数(T&&)时，forward会保持实参类型的所有细节。
- 与`std::move`相同，对`std::forward`不使用`using`声明是一个号主意。

对于模板函数，尽量使用右值引用，避免被使用时，末班类型的推导失去`&`符号，造成拷贝使用。相关参数不能使用。

### 16.3 重载与模板

函数匹配规则与影响：

- 对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例。
- 候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板
- 可行函数(模板与非模板)按照类型转换来排序；可以用于函数模板调用的类型转换是非常有限的。
- 如果存在多个匹配函数则：
    + 同样号的函数中只有一个是非模板函数，选择此函数
    + 没有非模板函数，其中一个模板比其它模板更特例话，则选择此模板
    + 不符合上述两条规则，此调用有歧义。

注意： 正确定义一组重载的函数模板需要对类型间的关系及模板函数允许的有限的实参类型转换有深刻的理解。

**编写重载模板**

例如:`debug_rep(const T&)`;本质上可以用于任何类型，包括指针类型。

注意：
- 当有多个重载模板对一个调用提供童颜好的匹配时，应该选择最特例化的版本。
- 对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选择非模板版本。

对于`cout<<debug_rep("hi word!")<<endl;`而言有：

- `debug_rep(const T&)` ,T被绑定到`char[10]`。
- `debug_rep(T*)` ,T被绑定到`const char`。
- `debug_rep(const string&)` ,要求从`const char*`到`string`的类型转换。

`T*`版本更加特例化，编译器会选择它。

注意:
在定义任何函数之前，记得声明所有重载的函数版本。这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个非你所需要的版本。

### 16.4 可变参数模板

**可变参数模板**：接受一个可变数目参数的模板函数或模板类。可变数目的参数被称为 **参数包**。

参数包分为两种：

- 模板参数包：表示0或者对个模板参数。
- 函数参数包：表示0或者多个函数参数。

使用`class...`或者`typename...`指出接下来的参数表示0个或者多个类型的列表；一个类型名后面跟一个省略号表示0或者多个给定类型的非类型参数的列表。例如：

```c++
//Args 是一个模板参数包；rest 是一个函数参数包

//Args 表示0个或多个模板类型参数

//rest 表示0个或者多个函数参数

template <typename T,typename... Args>
void foo(const T &t,const Args& ... rest);
//使用

int i=0;
double d=3.14;
string s="how now brown cow";
foo(i,s,42,d);//包中有三个参数

foo(s,42,"hi");//包中有两个参数

foo(d,s); //包中有一个参数

foo("hi"); //空包

//编译器会分别为他们实例化不同的版本。

//可以使用sizeof...运算符，计算包中有多少个元素

template<typename ... Args> void g(Args ...args){
    cout<<sizeof...(Args)<<endl; //类型参数的数目

    cout<<sizeof...(args)<<endl; //函数参数的数目
}

```
##### 16.4.1 编写可变参函数模板

可变参函数通常是递归的。第一步调用处理包中的第一个实参，然后用剩余实参调用自身。我们的print函数也是这样的模式，每次递归调用将第二个实参打印到第一个实参表示的流中。为了终止递归，我们还需要定义一个非可变参数的print 函数，它接受一个流和一个对象。

```c++
template <typename T>
//最后一次会优先调用它

ostream &print(ostream &os,const T &t)
{
    return os<<t; //包中最后一个元素之后不打印分隔符

}

//包中除了最后一个元素之外的其它元素都会调用这个版本的print

template <typename T,typename... Args>
ostream &print(ostream &os,const T &t,const Args&... rest)
{
    os<<t<<","; //打印第一个实参

    return print(os,rest...);//递归调用，打印其它实参

}
```
当定义可变参数版本的`print`时，非可变参数版本的声明必须在作用域中。否则，可变参数版本会无限递归。

#### 16.4.2 包扩展

包括展：将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。

```c++
template <typename T,typename... Args>
ostream &print(ostream &os,const T &t,const Args&... rest)//扩展Args

{
    os<<t<<",";
    return print(os,rest...);  //扩展rest

}


```
注意：

扩展中的模式会独立地应用与包中的每个元素。

##### 16.4.3 转发参数包
_参考链接：_ [std::forward](https://zh.cppreference.com/w/cpp/utility/forward);[c++11 完美转发 std::forward()](https://blog.csdn.net/coolwriter/article/details/80970718); [C++11 std::move和std::forward](https://blog.csdn.net/guoxiaojie_415/article/details/79902278)

使用可变参数模板与`forward`机制来编写函数，实现将实参不变地传递给其它函数。使用示例如下：
```c++
class StrVec{
public:
    template <class... Args> void emplace_back(Args&&...);
    ...
};
//函数实现

template <class... Args>
inline void StrVec::emplace_back(Args&&... args)
{
    chk_n_alloc(); //如果需要的话，重新分配StrVec内存空间

    alloc.construct(frist_free++,std::forward<Args>(args)...);
}

```

使用扩展`std::forward<Args>(args)...`它即扩展了模板参数包`Args`，也扩展了函数参数包`args`。生成如下形式元素：
    
    `std::forward<Ti>(ti)`

对于`std::forward<Ti>(ti)`;其中Ti表示模板参数包中第i个元素的类型，ti表示函数参数包中第i个元素。例如：
```c++
svec.emplace_back(10,'c'); //将c*10添加为新的尾部元素

```
construct调用中的模式会扩展出：
`std::forward<int>(10),std::forward<char>(c)`。

### 16.5 模板特例化

特例化版本就是模板的一个独立定义，在其中一个或多个模板参数被指定为特定的类型。
**定义函模板特例话**

特例话一个模板时，必须为原模板中的每个模板参数都提供实参。为了指出我们正在实例化一个模板，应使用关键字`template`后跟一个空尖括号对(`<>``)。指出我们将为原模板的所有模板参数提供实参：

```c++
//compare 的特殊版本，处理字符串数组的指针

template <>
int compare(const char* const &p1, const char* const &p2)
{
    return strcmp(p1,p2);
}
```
**在使用特例化版本时，函数参数类型必须与一个先前声明的模板中对应的类型匹配。**

```c++
template <typename T> int compare(const T&,const T&);
```
特例化版本的本质上是一个实例化模板，而非重载它。因此，特例化不影响函数匹配。
特例化版本主要是为了，提供特殊函数优先级，方便在使用函数时，优先搜索。
**类模板特例化**
示例：
```c++
namespace std{
    template <> //定义特例化版本，模板参数为Sales_data

    struct hash<Sales_data> //特例化模板名为hash

    {
        ...
    };
}

```

注意：特例化版本应该尽量在头文件中事先定义。

**类模板部分特例化**

我们只能部分特例化类模板函数，而不能部分特例化函数模板。

```c++
//原始的最通用版本

template <class T> struct remove_reference
{
    typedef T type;
};
// 部分特例化版本，将用于左值引用和右值引用

template <class T> struct remove_reference<T&> //左值引用

{
    typedef T type;
};

template <class T> struct remove_reference<T&&> //右值引用

{
    typedef T type;    
};

//使用

int i;
//decltype(42)为int,使用原始模板

remove_reference<decltype(42)>::type a;
//decltype(i)为int&,使用第一个(T&)部分特例化版本

remove_reference<decltype(i)>::type b;
//decltype(std::move(i))为int&& ,使用第二个(即 T&&)部分特例化版本

remove_reference<decltype(std::move(i)>::type c;

```
**特例化成员**

```c++
template <typename T> struct Foo
{
    Foo(const T &t=T()):mem(t) { }
    void Bar() {/*...*/}

    T mem;

    ...
    
};
//特例化模板函数

template <>
void Foo<int>::Bar()
{
    //进行应用于int的特例化处理

}
//实例化操作

Foo<string > fs; //实例化Foo<string>::Foo()

fs.Bar();  //实例化 Foo<string>::Bar()

Foo<int> fi; //实例化 Foo<string>::Foo()

fi.Bar();  //使用我们特例化版本的Foo<int>::Bar()

```

# 第IV部分高级主题

## 第17 章标准库特殊设施
标准库设施是:`tuple` 、`bittest`、随机生成数及正则表达式。

### 17.1 tuple 类型
tuple类似于pair是将一些数据组合成单一的对象。可以将其看做一个“快速随意”的数据结构

**tuple支持的操作**

|操作|含义|
|:---|:---|
|`tuple<T1,T2,...,Tn> t;`|t是一个tuple，成员数为n，第i个成员的类型为Ti。所有成员都进行值初始化|
|`tuple<T1,T2,...,Tn> t(v1,v2,...,vn);`|t是一个tuple，成员数为n，第i个成员的类型为Ti。所有成员都使用vi进行值初始化|
|`make_tuple(v1,v2,...,vn)`|返回一个给定初始值初始化的tuple。tuple的类型从初始值的类型推断|
|`t1=t2`|当两个tuple具有相同数量的成员且成员对应相等时|
|`t1!=t2`|当两个tuple具有相同数量的成员且成员对应相等时之外的情况|
|`t1 relop t2`|tuple的关系运算符使用字典序。两个tuple必须具有相同数量的成员。使用<运算符比较t1的成员和t2中的对应成员|
|`get<i>(t)`|返回t的第i个数据成员的引用；如果t是一个左值，结果是一个左值引用；否则，结果是一个右值引用。tuple的所有成员都是public的|
|`tuple_size<tupleType>::value`|一个类模板，可以通过一个tuple类型来初始化。它有一个名为value的public constecpr static 数据成员，类型为size_t,表示给定tuple类型中成员的数量。|
|`tuple_element<i,tupleType>::type`|一个类模板，可以通过一个整形常量和一个tuple类型来初始化。它有一个名为`type`的`public`成员，表示给定`tuple`类型中指定成员的类型。|

使用示例：

```c++
//定义和初始化

tuple<size_t,size_t,size_t> threeD;  //成员都初始化为0

tuple<string,vector<double>,int,list<int> > someVal("constants",{3.14,2.718},42,{0,1,2,3,4,5});

tuple<size_t,size_t,size_t> threeD2{1,2,3};

auto item=make_tuple("0-999-78345-X",x,20.00); 

//成员的访问

auto book=get<0>(item);  //返回第一个成员

//细节信息访问

typedef decltype(item) trans;  // trans 是item的类型

//返回trans类型对象中成员的数量

size_t sz=tuple_size<trans>::value; //返回3

//获取第二个成员的类型

tuple_element<1,trans>::type cnt=get<1>(item);  // cnt 是一个int

```

**tuple常见用法是，函数返回多个值**

### 17.2 bitset类型
标准库定义了`bitset`类，使得位运算的使用更为容易，并且能够处理超过最长整形类型大小的位集合。`bitset`类定义在头文件`bitset`中。`bitset`类是一个模板，它类似`array`类，具有固定的大小。可以在定义时声明：

```c++
bit<32> bitvec(1U);  // 32位；低位为1，其他位为0
```
**大小必须是一个常量表达式**

**初始化bitset方法**

|操作|含义|
|:---|:---|
|`bitset<n> b;`|b有n位；每位均为0.此构造函数是一个`constexpr`|
|`bitset<n> b(u);`|b是`unsigned long long`值u的低n位的拷贝。如果n大于`unsigned long long `的大小，则b中超出的高位被置为0.此构造函数是一个`constexpr`|
|`bitset<n> b(s,pos,m,zero,one);`|b是`string s`从位置`pos`开始m个字符符拷贝。s只能包含字符`zero`或`one`;如果s包含任何其它字符，构造函数会抛出`invalid_argument`异常。字符在b中分别保存为`zero`和`one`。pos默认为0，m默认为string::npos,zero 默认为`0`,`one`默认为`1`|
|`bitset<n> b(cp,pos,m,zero,one);`|与上一个构造函数相同，但从`cp`指向的字符串数组中拷贝字符，如果m未提供，则cp必须指向一个c风格字符串，如果提供了m,则从cp开始必须至少有m个zero或one字符|

使用示例:

```c++
// bitvec1初始值小；初始值中的高位被丢弃

bitset<13> bitvec1(0xbeef);  // 二进制位序列为 1111011101111

//比初始值大；高位被置为0

bitset<20> bitvec2(0xbeef); // 二进制位序列为 0000101111011101111

//64 位机中， long long 0ULL 是64个0比特，因此～0ULL是64个1

bitset<128> bitvec3(~0ULL); // 0~63 位为1; 63~127位为0

//string 初始化 bitset

bitset<32> bitvec4("1100"); //2、3 两位为1，剩余两位为0；高位被置为0。

```

注意：

string 的下标编号习惯与bitset恰好相反；string中下标最大的字符(最右字符)用来初始化`bitset`中的低位(下标为0的二进制位)。

```c++
string str("1111111000000011001101");

bitset<32> bitvec5(str,5,4); // 从str[5]开始的四个二进制位，1100

bitset<32> bitvec6(str,str.size()-4); //使用最后四个字符
```

![初始化流程](wangpengcheng.github.io/img/2019-06-09-bitset-string.png)

#### 17.2.2 bitset操作

**bitset操作表**

|操作|含义|
|:---|:---|
|`b.any()`|b中是否存在置位的二进制位|
|`b.all()`|b中所有位都置位了吗|
|`b.none()`|b中不存在位置的二进制位吗|
|`b.count()`|b中置位的位数|
|`b.size()`|一个`constexpr`函数，返回b中的位数|
|`b.test(pos)`|若pos位是置位的，则返回true,否则返回false|
|`b.set(pos,v)`|将位置pos处的位设置为bool值v。v默认为true。如果未传递实参，将b中所有位置复位|
|`b.set()`||
|`b.reset(pos)`|将位置pos处的位复位或将b中所有位复位|
|`b.reset()`||
|`b.flip(pos)`|改变位置`pos`处的位的状态或改变b中每一位的状态|
|`b.flip()`||
|b[pos]|访问b中位置pos处的位，如果b是const的，则当该位置位时b[pos]返回一个bool值true,否则返回`fasle`|
|`b.to_ulong()/b.to_ullong()`|返回一个unsigned long 或者一个unsigned long long值，其位模式与b相同。如果b中位模式不能放入指定的结果类型，则抛出一个`overflow_error`异常|
|`b.to_string(zero,one)`|返回一个string,表示b中的位模式。zero和one的默认值分别为0和1，用来表示b中的0和1|
|`os<<b`|将b中二进制位打印为字符1或者0，打印到流`os`|
|`is>>b`|从is读取字符存入b。当下一个字符不是1或者0时，或是已经读入b.size()个位时，读取过程停止|

**提取bitset的值**

```c++
unsigned long ulong=bitvec3.to_ulong();

cout<<"ulong ="<<ulong<<endl;

```
注意：

如果bitset中的值不能放入给定类型中，则这两个操作会抛出一个`overflow_error异常`

**bitset的IO运算符**

```c++
bitset<16> bits;
cin>> bits;  // 从cin读取最多16个0或1

cout<<"bits: "<<bits<<endl; //打印刚刚读取的内容

```
#### 17.3 正则表达式 

_参考链接：_ [regex](http://www.cplusplus.com/reference/regex/);

正则表达式是一种描述字符序列的方法，是一种极其强大的计算工具。本章重点介绍正则表达式库(RE)

**正则表达式库组件**

|组件|含义|
|:---|:---|
|`regex`|表示有一个正则表达式的类|
|`regex_match`|将一个字符序列与一个正则表达式匹配|
|`regex_search`|寻找第一个与正则表达式匹配的子序列|
|`regex_replace`|使用给定格式替换一个正则表达式|
|`sregex_iterator`|迭代适配器，调用`regex_sreach`来遍历一个`string`中所有匹配的子串|
|`smatch`|容器类，保存在`string`中搜索的结果|
|`ssub_match`|`string`中匹配的子表达式的结果|

**regex_search和regex_match的参数**

|参数|解释|
|:---|:---|
|`(seq,m,r,mft)`|在字符序列`seq`中查找`regex`对象r中的正则表达式。seq可以是一个string、表示范围的一对迭代器以及一个指向空字符皆为的字符数组的指针|
|`(seq,r,mft)`|m是一个match对应，用来保存匹配结果的相关细节，m和seq必须具有兼容的类型|
||mft是一个可选的`regex_constants::match_flag_type`值。他们会影响匹配过程|

正则表达式简单使用示例

```c++
//查找不在字符c之后的字符串ei

string pattern("[^c]ei");
//包含pattern的整个单词

pattern="[[:alpha:]]*"+pattern+"[[:alpha:]]*";
regex r(pattern); //构造一个用于查找模式的regex

smatch result;  //定义一个对象保存搜索结果

//定义一个string保存于模式匹配和不匹配的文本

string test_str="receipt freind theif receive";

//查找匹配的字符串

if(regex_search(test_str,result,r)){
    std::cout<<result.str()<<endl; //打印匹配的单词

}
```
**regex(和wregex)选项**

|选项|含义|
|:---|:---|
|`regex r(re)`|re表示一个正则表达式，它可以是一个`string`、一个表示字符范围的迭代器对、一个指向空字符结尾的字符数组的指针、一个字符指针和一个计数器或是一个花括符包围的字符列表。|
|`regex r(re,f)`|f是指出对象如何处理的标志。通过下面列出的值来设置。如果未指定f，其摩恩值为`ECMAScript`|
|`r1=re`|将r1中的正则表达式替换为`re`。`re`表示一个正则表达式，它可以是另外一个`regex`对象、一个`string`、一个指向空字符结尾的字符串数组的指针或是一个花括号保卫的字符串列表|
|`r1.assign(re,f)`|与使用赋值运算符(=)效果相同；可选的标志`f`也与`regex`的构造函数中对应的参数含义相同|
|`r.mark_count()`|r中子表达式的数目|
|`r.flags`|返回`r`的标志|

**定义regex时指定的标志**
定义则regex和regex_constants::syntax_option_type中

|选项|含义|
|:---|:---|
|`icase`|在匹配过程中忽略大小写|
|`nosubs`|不保存匹配的子表达式|
|`optimize`|执行速度优先于构造速度|
|`ECMAScript`|使用`ECMA-262`指定的语法|
|`basic`|使用POSIX基本的正则表达式语法|
|`extended`|使用POSIX扩展的正则表达式语法|
|`awk`|使用POSIX版本的awk语言的语法|
|`grep`|使用POSIX版本的grep的语法|
|`egrep`|使用POSIX版本的egrep的语法|

std::regex_match使用示例

```c++
// regex_match example

#include <iostream>
#include <string>
#include <regex>

int main ()
{


    if (std::regex_match ("subject", std::regex("(sub)(.*)") ))
        std::cout << "string literal matched\n";

    const char cstr[] = "subject";
    std::string s ("subject");
    std::regex e ("(sub)(.*)");

    if (std::regex_match (s,e))
        std::cout << "string object matched\n";

    if ( std::regex_match ( s.begin(), s.end(), e ) )
        std::cout << "range matched\n";

    std::cmatch cm;    // same as std::match_results<const char*> cm;
    
    std::regex_match (cstr,cm,e);
    std::cout << "string literal with " << cm.size() << " matches\n";

    std::smatch sm;    // same as std::match_results<string::const_iterator> sm;
    std::regex_match (s,sm,e);
    std::cout << "string object with " << sm.size() << " matches\n";

    std::regex_match ( s.cbegin(), s.cend(), sm, e);
    std::cout << "range with " << sm.size() << " matches\n";
    // using explicit flags:

    std::regex_match ( cstr, cm, e, std::regex_constants::match_default );

    std::cout << "the matches were: ";
    for (unsigned i=0; i<cm.size(); ++i) {
        std::cout << "[" << cm[i] << "] ";
    }

    std::cout << std::endl;

    return 0;
}

/*

result:

string literal matched
string object matched
range matched
string literal with 3 matches
string object with 3 matches
range with 3 matches
the matches were: [subject] [sub] [ject]


 */ 

```

注意：
一个正则表达式的语法是否正确是在运行时解析的。可以使用`regex_error`来抛出异常。

**异常类型表**

|异常类型|含义|
|:---|:---|
|`error_collate` |  The expression contained an invalid collating element name.|
|`error_ctype`| The expression contained an invalid character class name.|
|`error_escape` |   The expression contained an invalid escaped character, or a trailing escape.|
|`error_backref`|The expression contained an invalid back reference.|
|`error_brack`| The expression contained mismatched brackets ([ and ]).|
|`error_paren`| The expression contained mismatched parentheses (( and )).|
|`error_brace`| The expression contained mismatched braces ({ and }).|
|`error_badbrace`| The expression contained an invalid range between braces ({ and }).|
|`error_range`| The expression contained an invalid character range.|
|`error_space`| There was insufficient memory to convert the expression into a finite state machine.|
|`error_badrepeat`| The expression contained a repeat specifier (one of *?+{) that was not preceded by a valid regular expression.|
|`error_complexity` |The complexity of an attempted match against a regular expression exceeded a pre-set level.|
|`error_stack`| There was insufficient memory to determine whether the regular expression could match the specified character sequence.|

注意： 正则表达式的编译是一个非常慢的操作，特别是你在使用了扩展的正则表达式语法或者复杂的正则表达式的时候。应该尽量避免使用。

**正则表达式库类**

|如果输入序列类型|则使用正则表达式类|
|:---|:---|
|`string `|`regex、smatch、ssub_match和sregex_iterator`|
|`const char* `|`regex、smatch、ssub_match和cregex_iterator`|
|`wstring `|`wregex、wsmatch、wssub_match和wsregex_iterator`|
|`const wchar_t*`|`wregex、wsmatch、wcsub_match和wcregex_iterator`|

ECMAScript正则表达式语句基本特性

- `\{d}`表示单个数字而`\{d}{n}`则表示一个`n`个数字的序列。如，`\{d}{3}`匹配三个数组的序列。
- 在方括号中的字符集和表示匹配这些字符中任意一个。如`[-. ]`匹配一个`-`或`.`或` `。
- 后接'?'的组件是可以选的。如，`\{d}{3}[-. ]?\{d}{4}`匹配这样的序列：开始是三个数字，后接一个可选的短横线或点或空格，然后是四个数字。
- 使用反斜线`\`表示一个字符本身而不是其特殊含义。因此必须使用`\(`和`\)`来表示括号是我们模式的一部分而不是特殊字符。
- 由于反斜线是c++中的特殊字符，在模式中，每次出现`\`的地方，我们都必须使用一个额外的反斜线来告诉c++我们需要一个反斜线字符而不是特殊符号。例如`\\{d}{3}`来表示正则表达式`\{d}{3}`

一个正则表达式的字符串分析：
```c++
"(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ]?)(\\d{4})";
```
整个正则表达式包含一个字表达式： (ddd)分隔符ddd分隔符dddd。剥离子表达式：

1. `(\\()?`表示区号可选的左括号
2. `(\\d{3})`表示区号
3. `(\\))?`表示区号部分可选的右括号
4. `([-. ])?`表示区号部分可选的分隔符
5. `(\\d{3})`表示号码的下三位数字
6. `[-. ]?`表示可选的分隔符
7. `(\\d{4})`表示号码的最后四位数字

使用示例：

```c++
string phone="(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ]?)(\\d{4})";

regex r(phone); // regex对象，用于查找我们的模式

smatch m;
string s;

//从文件中读取每条记录
while (getline(cin,s)){
    //对每个匹配的电话号码
    
    for(sregex_iterator it(s.begin(),s.end(),r),end_it;it!=end_it;++it){
        //检查号码的格式是否合法
        
        if(valid(*it)){
            std::cout<<"valid:"<<it->str()<<endl;
        }else{
            cout<<"not valid:"<< it->str()<<endl;
        }
    }

}

```
##### regex_replace
_参考链接：_ [regex_replace](http://www.cplusplus.com/reference/regex/regex_replace/);

**正则表达式替换操作**

```c++
// regex_replace example
#include <iostream>
#include <string>
#include <regex>
#include <iterator>

int main ()
{
  std::string s ("there is a subsequence in the string\n");
  std::regex e ("\\b(sub)([^ ]*)");   // matches words beginning by "sub"
  // using string/c-string (3) version:

  std::cout << std::regex_replace (s,e,"sub-$2");
  // using range/c-string (6) version:
 
  std::string result;
  std::regex_replace (std::back_inserter(result), s.begin(), s.end(), e, "$2");
  std::cout << result;
  // with flags:
  
  std::cout << std::regex_replace (s,e,"$1 and $2",std::regex_constants::format_no_copy);
  std::cout << std::endl;

  return 0;
}
/*

result :
there is a sub-sequence in the string
there is a sequence in the string
sub and sequence

 */

```

**正则表达式匹配选项**

|flag* | effects| notes|
|:---|:---|:---|
|`match_default` |  Default| Default matching behavior. This constant has a value of zero**.|
|`match_not_bol`  | Not Beginning-Of-Line  | The first character is not considered a beginning of line ("^" does not match).|
|`match_not_eol`  | Not End-Of-Line| The last character is not considered an end of line ("$" does not match).|
|`match_not_bow`|   Not Beginning-Of-Word |  The escape sequence "\b" does not match as a beginning-of-word.|
|`match_not_eow` |  Not End-Of-Word| The escape sequence "\b" does not match as an end-of-word.|
|`match_any` |  Any match  | Any match is acceptable if more than one match is possible.|
|`match_not_null `| Not null  |  Empty sequences do not match.|
|`match_continuous` | Continuous | The expression must match a sub-sequence that begins at the first character.Sub-sequences must begin at the first character to match.|
|`match_prev_avail` |   Previous Available | One or more characters exist before the first one. (match_not_bol and match_not_bow are ignored)|
|`format_default` | Default formatting | Uses the standard formatting rules to replace matches (those used by ECMAScript's replace method). This constant has a value of zero**.|
|`format_sed`|sed formatting | Uses the same rules as the sed utility in POSIX to replace matches.|
|`format_no_copy`| No copy| The sections in the target sequence that do not match the regular expression are not copied when replacing matches.|
|`format_first_only`|  First only | Only the first occurrence of a regular expression is replaced.|

```c++

string fmt="$2.$5.$7"; //将号码格式改为 ddd.ddd.dddd

regex r(phone);  //用来寻找模式的regex对象

string number="(908) 555-1800";
cout<<regex_replace(number,r,fmt)<<endl;

```

### 17.4 随机数

_参考链接：_ [random](http://www.cplusplus.com/reference/random/);

c++中的随机数标准库定义在`random`头文件中。包含 **随机数引擎类(random-number engines)**和 **随机数分布类(random-number distribution)**。一个引擎类可以生成`unsigined`随机数序列，一个分布类使用一个引擎类生成指定类型的、在戈丁范围内的、服从特定概率分布的随机数。

注意：
c++程序不应该使用库函数`rand`,而应该使用`default_random_engine`类和恰当的分布类对象。

##### 17.4.1 随机数引擎和分布

注意:
- 使用随机数引擎应该使用`static`关键字修饰。从而每次都生成新的数，否则产生的两次数可能相同。
- 一个给定的随机数发生器一直会生成相同的随机数序列，一个函数如果定义了局部的随机数发生器，应该将其（包括引擎和分布对象）定义为static的。否则，每次调用函数都会生成相同的序列。

```c++
vector<unsigned> good_randVec()
{
    //定义为static的，从而每次调用都生成新的数
    
    static default_random_engine e;
    static uniform_int_distribution<unsigned> u(0,9);
    vector<unsigned> ret;
    for(size_t i=0;i<100;++i){
        ret.push_back(u(e));
    }
    return ret;
}
```
**随机数引擎基本操作**

|操作|含义|
|:---|:---|
|`Engine e`|默认构造函数；使用该引擎类型默认的种子|
|`Engine e(s)`|使用整型值s作为种子|
|`e.seed(s)`|使用种子s重置引擎的状态|
|`e.min()`|此引擎可生成的最大和最小值|

**设置随机数种子** 
通过设置随机数种子引擎可以产生不同的随机数结果。

```c++
default_random_engine e1; //使用默认的种子

default_random_engine e2(2147483646); //使用给定的种子值

default_random_engine e3;  
e3.seed(32767);
default_random_engine e4(32767);  //e3和e4种子相同将会产生相同的随机数。

default_random_engine e5(time(0));  //稍微随机些的种子

```

注意： 

- time生成的随机种子，作为一个自动的过程反复运行，将time的返回值作为种子的方式就无效了；它可能多次使用的都是相同的种子。
- 引擎必须在循环外，否则可能每步循环都产生相同的随机值。

可以使用`uniform_real_distribution`来实现函数的映射。使用示例如下：

```c++
default_random_engine e; //生成无符号的随机数

uniform_real_distribution<double> u(0,1); // 0到1(包含)的均匀分布

for(size_t i=0;i<10;++i){
    cout<<u(e)<<"";
}
```

**非均匀分布的随机数**

|函数方法|说明|
|:---|:---|
|`normal_distribution(a,b)`|标准随机分布，a为均值，b为标准差|
|`bernoulli_distribution(m)`|布尔分布,不接受任何额外的参数时，都是50/50的机会，当m为0.55时则双方机会不均等|

### 17.5 IO库再探

当操作符改变流的格式状态的时候，通常改变后的状态对所有后续IO都生效。

对于bool值的输出需要添加关键字`boolalpha`；如：

```c++
cout<<"default bool values: "<<true<<" "<<false
    <<"\nalpha bool values: "<<boolalpha
    <<true<<" "<< false<<endl;
/*

result:
default bool values: 1 0
alpha bool value: true false


*/
```
**指定整型的进制**

```c++


cout<<showbase;  //打印的时候显示进制

cout<<"default: "<<20<<" "<<1024<<endl;
cout<<"octal: "<<oct<<20<<" "<<1024<<endl;
cout<<"hex: "<<hex<<20<<" "<<1024<<endl;
cout<<"decimal: "<<dec<<20<<" "<<1024<<endl;

cout<<noshowbase; //恢复流状态
/*

default: 20 1024
octal: 024 2000
hex: 0x14 0x400
decimal: 20 1024

 */
```

**指定打印精度**

可以通过cout的`precision()`函数和`setprecision()`函数设置显示的精度。

**输入输出流中的格式控制符**

|控制符| 说明 | 示例|
|:---|:---|:---|
|`boolalpha`  | 设置 bool 类型在数据流中显示为 true 或 false。默认情况下，bool 类型变量显示为1或0。|  `cout << boolalpha` ; 或 `boolalpha (cout)`;|
|`noboolalpha` |设置 bool 类型在数据流中显示为 1 或 0 （恢复 bool 类型的显示状态至默认）。 | cout << noboolalpha ; 或 hex(noboolalpha );|
|`scientific` | 设置浮点数以科学计数法显示。 | cout << scientific ; 或 hex(scientific );|
|`fixed` |  设置浮点数以标准显示法显示。|  cout << fixed ; 或 hex(fixed );|
|`hex` |设置整数类型以十六进制显示。  |cout << hex; 或 hex(cout);|
|`dec` |设置整数类型以十进制显示（默认情况下，整数类型是以十进制显示）。 |   cout << dec; 或 dec(cout);|
|`cot` |设置整数类型以八进制显示   | cout << oct; 或 oct(cout);|
|`internal`  |  数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充。 | cout << internal ; 或 oct(internal );|
|`left`| 设置输出数值或文本的显示形式为左对齐。| cout << left ; 或 oct(left );|
|`right`  | 设置输出数值或文本的显示形式为右对齐。 |cout << right ; 或 oct(right );|
|`showbase`  |  设置数值前缀不显示  | cout << showbase ; 或 oct(showbase );|
|`noshowbase` | 将数值显示的形式恢复至默认状态。 |   cout << noshowbase ; 或 oct(noshowbase );|
|`showpoint` |  即使小数部分为零，也显示浮点数的整数部分和小数点右侧的数字 |  cout << showpoint ; 或 oct(showpoint );|
|`noshowpoint`| 仅显示数值的整数部分。| cout << noshowpoint ; 或 oct(noshowpoint );|
|`showpos` |显示正数值的 + 号。| cout << showpos ; 或 oct(showpos );|
|`noshowpos`  | 忽略正数值前面的 + 号。 |  cout << noshowpos ; 或 oct(noshowpos );|
|`skipws`  |使 cin 获取输入时忽略空格。   | cout << skipws ; 或 oct(skipws );|
|`noskipws`    |使输入流读取空格  |  cout << noskipws ; 或 oct(noskipws );|
|`unitbuf`| 每次执行输出操作后均会清空缓冲区。 |  cout << unitbuf ; 或 oct(unitbuf );|
|`nounitbuf`  | 将 unitbuf 复位至默认状态。 | cout << nounitbuf ; 或 oct(nounitbuf );|
|`uppercase`  | 设置十六进制数值和科学计数法中的指数以大写形式显示。 | cout << uppercase ; 或 oct(uppercase );|
|`nouppercase` |设置十六进制数字和科学计数法的指数以小写形式显示   | cout << nouppercase ; 或 oct(nouppercase );|
|`flush`| 刷新缓冲区  | cout << “str” << flush; 或 flush(cout);|
|`endl`| 刷新缓冲区并插入一个换行符 |  cout << “str” << endl; 或 endl(cout);|

**定义在iomanip中的操作符**

|操作符|含义|
|`setfill(ch)`|用`ch`填充空白|
|`setprecision(n)`|将浮点精度设置为n|
|`setw(w)`|读或写值的宽度为w个字符|
|`setbase(b)`|将整数输出为b进制|

##### 17.5.2 未格式化的输入/输出操作

标准库提供了一组低层操作，支持未格式化IO.这些操作允许我们将一个流当做一个无解释的字节序列来处理。

```c++
char ch;
while(cin.get(ch)) {
    cout.put(ch);
}
```

**单字节低层IO操作**

|操作|含义|
|:---|:---|
|`is.get(ch)`|从`istream is`读取下一个字节存入字符`ch`中。返回`is`|
|`os.put(ch)`|将字符`ch`输出到`ostream os`。返回`is`|
|`is.get()`|将`is`的下一个字节作为`int`返回|
|`is.putback(ch)`|将字符`ch`放回`is`。返回`is`|
|`is.unget()`|将`is`向后移动一个字节。返回`is`|
|`is.peek()`|将下一个字节作为`int`返回,但不从流中删除它|


**将字符放回输入流**

标准库提供了三种方法退回字符：

- `peek`: 返回输入流中一个字符的副本，但不会将它从流中删除，`peek`返回的值仍然留在流中。
- `unget`:输入流向后移动，从而最后读取的值又回到流中。即使我们不知道最后从流中读取什么值，仍然可以调用`unget`。
- `putpack`: 退回从流汇总读取的最后一个值，但它接受一个参数，此参数必须与最后读取的值相同。

这些函数返回整型的主要原因是可以返回文件尾标记符。
```c++
//检测是否达到文件尾部

int ch; //使用一个int,而不是一个char来保存get()的返回值

//循环读取并输出输入中的所有数据

while((ch==cin.get())!=EOF){
    cout.put(ch);
}
```

**多字节操作**

多字节操作要求我们自己分配管理用来保存和提取数据的字符组操作

**多字节低层IO操作**

|`is.get(sink,size,delim)`|从`is`中读取最多`size`个字节，并保存在字符数组中，字符数组的其实地址由`sink`给出。读取过程直至遇到字符`delim`或读取了`size`个字节或遇到文件末尾时停止。如果遇到了`delim`,则将其留在输入流中，不读取出来存入`sink`|
|`is.getline(sink,size,delim)`|与接受三个参数的get版本类似，但会读取并丢弃`delim`|
|`is.read(sink,size)`|读取最多`size`个字节，存入字符数组`sink`中。返回`is`|
|`is.gcount()`|返回上一个未格式化读取操作从is读取的字节数|
|`os.write(source,size)`|将字符数组`source`中的`size`个字节写入`os`。返回`os`|
|`is.ignore(size,delim)`|读取并忽略最多`size`个字节，包括`delim`。与其他未格式化函数不同，`ignore`有默认参数:size的默认值为1，`delim`的默认值为文件尾|

注意： 
- 一个常见的错误是本想从流中删除分隔符，但却忘了做。
- get和getline读取字符时，get将分隔符留作istream中的下一个字符，而getline则读取并丢弃分隔符。无论哪个函数都不会将分隔符保存在`sink`中

##### 17.5.3 流随机访问

**随机IO本质上是依赖于系统的。为了理解如何使用这些特性，必须查询系统相关文档**

**seek和tell函数**
一个函数通过将标记seek到一个给定位置来重定位它；另外一个函数tell我们标记的当前位置。后缀`g`表示正在"获得"，后缀`p`表示正在放入

|函数|定义|
|:---|:---|
|`tellg()/tellp()`|返回一个输入流中(tellg)或输出流中(tellp)标记的当前位置|
|`seekg(pos)/seekp(pos)`|根据标定的`pos`值，重定位到输入/输出流中的绝对地址|
|`seekp(off,from)/seekg(off,from)`|在一个输入流或输出流中将标记定位到from之前或之后`off`个字符，`from`可以是下列值之一：`beg`,偏移量相对于流开始位置，`cur`,偏移量相对于流当前结束位置；`end`,偏移量相对于流结尾位置 |

注意：由于只有单一的标记，因此只要我们在读写操作间切换，就必须进行`seek`操作来重定位标记。

使用示例：

```c++
#include <iostream>
#include <fstream>
using namespace std;

int main(){
    //以读写方式打开文档
    
    fstream inOut("copyout",fstream::ate|fstream::in|fstream::out);

    if(!inOut){
        cerr<<"Unable to open file"<<endl;
        return 0;
    }
    auto end_mark=inOut.tellg(); //记住原文件尾位置

    inOut.seekg(0,fstream::beg); //重定位带文件开始

    size_t cnt=0; //字节数累加器

    string line;  //保存输入中的每行

    // 还未遇到错误且未到末尾，持续读取
    while(inOut&& inOut.tellg()!=end_mark
        &&getline(inOut,line))
    {
        cnt+=line.size()+1; //+1表示换行

        auto mark=inOut.tellg(); //记住读取位置

        inOut.seekp(0,fstream::end); // 将写标记移动到问价尾

        inOut<<cnt;   //输出累计长度

        if(mark!=end_mark){
            inOut<<" ";
        }
        inOut.seekp(0,fstream::end); //定位到文件尾
    }

    inOut<<"\n";  //文件尾部输出换行符
    return 0;

}
```
## 第18章 用于大型程序的工具

### 18.1 异常处理

_参考链接：_ [C++异常处理（try catch）从入门到精通](http://c.biancheng.net/cplus/exception/);

注意： 

- 一个异常如果没有被捕获，则它将终止当前的程序
- 在钱展开的过程中，运行类类型的局部叶象的析构函数，因为这些析构函数是自动执行的，所以它们不应该抛出异常_一旦在钱展开的过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终止。
- 抛出指针要求在任何时应的处理代码存在的地方，指针所指的对象都必须存在。
- 通常情况下，如果catch接收的异常与额某个继承体系有关，则最好将该catch的参数定义成类型引用
- 如果在多个catch语句的类型之间存在着继承关系，则我们应该把继承链最底端的类(most derived type )放在前面，而将继承链最顶端的类(least derivedtype)放在后面。

异常类型和catch声明的类型是精确匹配的：

- 允许从非常量向常量的类型转换
- 允许派生类向基类的转换
- 数组被转换成指向数组(元素)类型的指针，函数被转换成指向该函数类型的指针。
- 处理构造函数初始值异常的唯一方法是讲构造函数写成try语句块

`catch(...)`可以匹配任意的异常类型。其通常与重新抛出语句一起使用，其中catch执行当前局部能完成的工作，随后重新抛出异常;当其与其它几个`catch`语句一起出现的时候，必须放在最后否则后面的语句永远不会被执行。

```c++
void manip(){
    try{
        //这里的操作将引发并抛出一个异常
    }
    catch (...){
        //处理异常的某些特殊操作
        
        throw;
    }
}
```

注意： 由于构造函数执行的时候，try语句可能还未能成功初始化，所以不能正常的抛出异常。我们必须将构造函数携程 **函数try语句块**的形式。才能正真使用。例：

```c++
temlate <typename T>
Blob<T>::Blob(std::initializer_list<T> il) try :
    data(std::make_shared<std::vector<T>>(il)){
        // 函数体
        
    } catch (const std:bad_alloc &e){handle_out_of_memory(e);}

```
##### 18.1.4 noexcept 异常说明

C++11新标准中，可以通过提供noexceot说明，指定某个函数不会抛出异常。使用时关键字紧跟函数的参数列表后面。

```c++
void recoup(int) noexcept; //不会抛出异常

void alloc(int);  //可能抛出异常

```

注意：

- 通常情况下，编译器不能也不必在编译时验证异常说明。
- noexcept有两层含义:当跟在函数参数列表后面时它是异常说明符;而当作为noexcept异常说明的bool实参出现时，它是一个运算符。

##### 18.1.5 异常类层次

![异常层次图](../img/error.png)

### 18.2 命名空间

#### 18.2.2 命名空间的定义
```
namespcae cplusplus_primer{
    ...
}
```

注意：

- 命名空间作用域后面无须分号；每个命名空间都是一个作用域
- 命名空间可以是不连续的
    + 命名空间的部分成员的作川是定义类，以及声明作为类接口的函数及对象，则这个 成员应该放置几头文件中，这namespace,头文件将被包含在使用了这些成员的文件中。
    + 命名空间成员的z义部分则置于另外的源文件中。
    + 在程序III某此实体只能定义一次:如非内联函数、静态数据成员、变量等。
- 定义多个类型不相关的命名空间应该使用单独的文件分别表示每个类型(或关联类型构成的集合)。
- 对于多个命名空间使用时可以使用`::spcaename::subspacename`的方式来寻找命名空间。
- 模板特例化必须定义在原始模板所属的命名空间中。
- 使用`::`全局作用域，隐式的将函数添加到全局作用域中。
- 未命名的命名空间仅仅在特定的文件内部有效，其作用范围不会横跨多个文件。

**内联命名空间**

内联命名空间和普通的嵌套命名空间不同，内联命名空间可以被外层命名空间直接使用。无需使用外层命名空间名字，就可以直接访问它。

```c++
inline namespace FifthEd{
    //使用内联命名空间
    
}

namespace FifthEd{ //隐式内联

    class Query_base{
        /**/

    };
    //其它相关命名
    
}
```

#### 18.2.2 使用命名空间成员

可以使用通用赋值给命名空间别名,例如：
```c++
namespace primer=cplusplus

namespace Qlib=cplusplus_primer::Querylib;
```
注意避免使用using 指示

#### 18.2.3 类、命名空间与作用域

对命名空间内部名字的查找遵循常规的查找规则:即由内向外依次查找每个外层作川域。外层作川域也可能是一个或多个嵌套的命名空间，直到最外层的个局命名空间查找过程终止。只有位于开放的块中且在使用点之前声的名字才被考虑:

可以从函数的限定名推断出查找名字时检查作用域的次序，限定名以相反次序指出被查找的作用域。

#### 18.2.4 重载与命名空间

 一个。using明引入的函数将重载声明语句所属作作用域已有的其他同名函数。如果using声明出现在局部作川域中，则引入的名字将隐藏外层作用域的相关声明。如果using声明所在的作用域中已经有一个函数与新引入的函数同名且形参列表相同，则该using声明将引发错误。除此之外，using声明将为引入的名字添加额外的重载实例，并最终扩充候选函数集的规模。

using指示将命名空间的成员提升到外层作用域中，如果命名空间的某个函数与该命名空间所属作用域的函数同名，则命名空间的函数将被添加到重载集合。

如果存在多个using指示，则来自每个命名空间的名字都会成为候选函数集的一部分。

### 18.3 多重继承与虚继承

注意：

- 如果从多个基类中继承了相同的构造函数（即形参列表完全相同），则程序将产生错误。
- 当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况、此时，不加前缀限定符直接使用该名字将引发二义性。

#### 18.3.4 虚继承

- 在默认情况下，派生类中含有继承链上每个类对应的f-部分.如果某个类派生类，中出现了多次，则派之卜类中将包含该类的多个子对象。
- 为了解决上述多次继承的情况，设置了 **虚继承**它的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为虚基类( virtual base class ) 。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生中都只包含唯一一个共享的虑基类子对象。
- 虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。
- 虚继承在后续的派生类中共享虚基类的同一份实例。
- 对于相同虚函数的继承，可能存在二义性，最好的办法是在派生类中自定义实例。

#### 18.3.5 构造函数与虚继承

含有虚基类的对象的构造书序与一般的顺序稍有叙别：首先使用提供给最低层派生类（最低层公共部分）构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生表中出现的次序从左向右对其进行初始化。

虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。


## 第 19 章 特殊工具与技术

### 19.1 控制内存分配

new 的过程：

- 分配内存空间
- 赋予初值。
- 指向该指针。

delete过程

- 执行指针所指对象的析构函数
- 调用标准函数库，释放指针。

**当只传入一个指针类型的实参时，定位new表达式构造对象但是不分配内存。**
**调用析构函数会销毁对象，但是不会释放内存。**

### 19.2 运行时类型识别

运行时类型识别(run-time type identification,  RTTI)的功能由两个运算符实现:

- typeid 运算符，用于返回表达式的类型；可以作用于任意类型的表达式。
- dynamic_cast 运算符，用于将基类的指针或引用安全的转换成派生类的指针或者引用。
- 在条件部分执行dynamic cast操作可以确保类型转换和结果检查在同一条表达式中完成。
- 当typeid作用于指针时(而非指针所指的对象)，返回的结果是该指针的静态编译时类型。

`type_info`类，用来鉴定类型是否相同。

type_info类在不同的编译器上有所区别。有的编译器提供了额外的成员函数以提供程序中所用类型的额外信息。读者应该仔细阅读你所用编译器的使用手册，从而获取关于type-info的更多细节。

### 19.3 枚举类型

C++包含两种枚举类型：限定作用域的和不限定作用域的。
限定作用域的枚举类型： enum class(struct) {...}。不限定枚举可以省略掉关键字class，枚举类型名字可选。

```c++
enum color {red,yellow,green};   //不限定作用域的枚举类型

enum stoplight {red,yellow,green};  //错误：重复定义了枚举成员

enum class peppers {red,yellow,green}; //正确：枚举成员被隐藏了

color eyes=green;  //正确： 不限定作用域的枚举类型位于有效的作用域中

pepper p=green;   // 错误：pepper的枚举成员不在有效的作用域中

color hair=color::red;  //正确：允许显式地访问枚举成员

peppers p2=pepper::red;  //正确：使用pappers的red

//指定序号

enum class intType{
    charTyp=8,shortTyp=16,intTyp=16,
    longTyp=32,long_longTyp=64
}

//利用冒号指定类型

enum intValues:unsigned long long {
    charType=255,shortTyp=65535,
    ......
}
```

注意： 

- 即使某个整型值恰好与枚举成员的值相等，它也不能作为函数的enum实参使用。
- 但是可以使用强制类型转换，将enum提升成int或更大的整型。

### 19.4 指针类成员

**成员指针** 是指可以指向类的排静态成员的指针。类的静态成员不属于任何对象。

我们令其指向类的某个成员，但是不指定该成员所属的对象；直到使用成员指针时，才提供成员所属的对象。

#### 19.4.1 数据成员指针

与普通指针不同的是成员指针必须包含成员所属的类

```c++
//pdata可以指向一个常量(非常量)Screen对象的string成员

const string Screen::*pdata;

pdata=&Screen::contents;//获取成员对象

auto pdata=&Screen::contents;
//使用成员指针

Screen myScreen,*pScreen=&myScreen;
//.*解引用pdata以获得myScreen对象的contents成员

auto s=primaryScreen.*pdata;
//->*解引用pdata以获得pScreen所指对象的contents成员

s=pScreen->*pdata;

```

#### 19.4.2 成员函数指针

```c++
//利用auto关键字指向一个常量成员函数
//前提是该函数不接受任何实参，并且返回一个char

auto pmf=&Screen::get_cursor;
//指向含有两个形参的get

char (Screen::*pmf2)(Screen::pos,Screen::pos) const;
pmf2=&Screen::get;
//成员函数的使用

Screen myScreen，*pScreen=&myScreen;
//通过pScreen 所指的对象pmf所指的函数

char c1=(pScreen->*pmf)();
//通过myScreen对象将实参0,0传给含有两个形参的get函数

char c2=(myScreen.*pmf2)(0,0);
//使用成员指针的类型别名

//Action 是一种可以指向Screen成员函数的指针，它接受两个pos实参，返回一个char

using Action=char (Screen::*)(Screen::pos,Screen::pos) const;

Action get=&Screen::get;  //指向Screen的get成员。

//使用函数指针成员表
class Screen{
public:
    Screen& home();  //光标移动函数

    Screen& forward();
    Screen& back();
    Screen& up();
    Screen& down();

    //Action 是一个指针，可以用任意一个光标移动函数对其赋值

    using Action=Screen& (Screen::*)();
    //具体移动方向指定
    
    enum Directions {HOME,FORWARD,BACK,UP,DOWN};
    Screen& move(Directions){
        //运行this对象中索引值为cm的元素
        
        return (this->*Menu[cm])();  //Menu[cm]指向一个函数成员

    };
private:
    static Action Menu[];  //函数表

}

Screen myScreen;

myScreen.move(Screen::HOME);  //调用myScreen.home

myScreen.move(Screen::DOWN);  //调用myScreen.down

//初始化函数表

Screen::Action Screen::Menu[]={
    &Screen::home,
    &Screen::forword,
    ...
};
```

#### 19.4.3 将成员函数用作可调用对象

**使用function生成一个可调用对象**

使用标准模板库function 可以凶函数指针获取可调用对象。

```c++
function<bool (const string&)> fcn=&string::empty;
find_if(svec.begin(),svec.end(),fcn);
```

**使用mem_fn生成一个可调用对象**

```c++
auto f=mem_fn(&string::empty);
```

**使用bind生成一个可调用对象**

```c++
auto it=find_if(svec.begin(),svec.end(),bind(&string::empty,_1));

```


### 19.5 嵌套类

一个类可以定义在另外一个类的内部。可以在类之外声明一个类内的嵌套类：
`class class1_name::class2_name{}`

- 在嵌套类在其外层类之外完成真正的定义之前，它都是一个不完全类型。
- 嵌套类的作用域查找，比一般类多了一个外层类作用域的查找。
- 外层类可以直接使用嵌套类的名字。
- 外层类和嵌套类相互独立，都各自只包含自己的成员名字。

### 19.6 union: 一种节省空间的类

 联合(( union )是一种特殊的类一个union 可以有多个数据成员，但是在仟愈时刻只有一个数据成员可以有直。当我们给union的某个成员赋值之后, 该union的其它成员就变成末定义的状态了。分配给一个union对象的存储空间至少要能容纳它的最大的数据成员。和其他类一样，一个union定义了一种新类型。

**匿名union**

是一个未命名的union,并且在符号之间没有任何声明。一旦我们定义了一个匿名union，编译器自动地位该union创建一个未命名的对象。在union的定义所在的作用域内该union的成员都是可以直接访问的。

注意：

- 匿名union不能包含受保护的成员或者私有成员，也不能定义成员函数。
- union中成员类中成员没有定义默认构造函数，则编译器删除类中的该成员。

### 19.7 局部类

定义在某个函数内部的类称为，局部类。局部类定义的类型只在定义它的作用域内可见。

注意：

- 局部类的所有成员(包括函数在内)都必须完整定义在类的内部。因此，局部类的作用与嵌套类相比相差很远。
- 局部类只能访问外层作用域定义的类型名、静态变量以及枚举成员。
- 局部类不能使用函数作用域中的变量。
- 常规的访问保护规则对局部类同样适用。

### 19.8 固有的不可移植的特性

是指因机器而异常的特性，当机器转移时，需要重新编写该程序。

#### 19.8.1 位域

**位域在内存中的布局是与机器相关的**

位域的类型必须是整型或枚举类型。因为带符号位域的行为是由具体实现确定的。
位域的声明形式是成员名字后紧跟一个冒号以及一个常量表达式，该表达式用于指定成员所占的二进制位数。

```c++
typedef unsigned int Bit;

class File{
    Bit mode: 2;  //mode占2位
    
    Bit modified:1;  //占1位
    
    ...

public:
    //文件类型以八进制表示
    
    enum modes{READ=01,WRITE=02,EXECUTE=03};
}
```
注意： 通常情况下最好将位域设为无符号类型，存储在带符号类型中的位域的行为将因具体实现而定。

#### 19.8.2 volatile 限定符

volatile的确切含义与机器有关，只能通过阅读编译器文档来理解、要想让使用了volatile的程序在移植到新机器或新编译器后仍然有效，通常需要对该程序进行某些改变。关键字volatile告诉编译器不应对这样的对象进行优化。

注意：

- 关键字volatile告诉编译器不应对这样的对象进行优化。
- 合成的拷贝对volatile对象无效。
- volatile 不能使用合成的拷贝/移动构造函数和赋值运算符初始化。

#### 19.8.3 链接指示: extern "C"

要想把c++代码和其他语言(包括c语言)编写的代码放在一起使用.要求我们必须有权访问该语言的编译器，并且这个编译器与当前的c++编译器是兼容的。

当一个#include指示被放置在复合链接指示的花括号中时，文件中的所有普通函数声明都被认为是由链接指示的语言编写的。链接指示可以嵌套，因此如果头文件包含自带链接指示的函数，则该函数的链接不受影响。

```c++
ectern "C"{
    #include <string.h>
}
```

**指向extern "C"函数的指针**

```c++
//pf指向一个c函数，该函数接受一个int返回void

extern "C" void (*pf)(int);

void (*pf1)(int);  //指向一个c++函数
```

注意：

- 有的C++编译器会接受之前的这种赋值操作并将其作为对语言的扩展，尽管从严格意义上来看它是非法的。
- 链接指示对整个声明都有效。当我们使用链接指示时，它不仅仅对函数有效，而且对作为返回内省或形参类型的函数指针也有效。

**导出C++函数到其他语言**
通过使用链接器指示对函数进行定义，我们可以令一个C++函数在其它语言编写的程序中使用

```c++
//calc 函数可以被C程序调用

extern "C" double calc(double dparm){
    /**/
}
```
**有时可以使用预处理器定义`__cplusplus`来有条件的包含代码**
```c++

#if defined(__cplusplus) || defined (c_plusplus)
extern "C"
{
#endif

#include <stdio.h>

#include <stdlib.h>

#include "libavcodec/avcodec.h"

#include "libavformat/avformat.h"
#include "libavutil/pixfmt.h"

#include "libavutil/mathematics.h"

#include "libavutil/time.h"

#include "libswscale/swscale.h"

#if defined(__cplusplus) || defined (c_plusplus)
}
#endif

```

注意：extern "..."的重载和链接与语言本身有关。


# 深度探索C++对象模型
- [深度探索C++对象模型 笔记汇总](http://www.roading.org/develop/cpp/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB.html)
--- 
# 第1章 关于对象(Object Lessons)
## C++的额外成本
- C++较之C的最大区别，无疑在于面向对象。类相较于C的struct不仅只包含了数据，同时还包括了对于数据的操作。在语言层面上C++带来了很多面向对象的新特性，类、继承、多态等等。新特性使得C++更加强大，但却伴随着空间布局和存取时间的额外成本。作为一个以效率为目标的语言，C++对于面向对象的实现，其实不大优雅.
- 额外成本主要由**virtual**引起，包括：
	- **virtual function** 机制，用来支持“执行期绑定”。
	- **virtual base class** ——虚基类机制，以实现共享虚基类的 subobject。
- 除此之外C++没有太多理由比C迟缓
## 三种对象模型
- C++类包含两种数据成员和三种成员函数：
	- 静态数据成员, 非静态数据成员
	- 成员函数, 静态函数, 虚函数
- 在C++对象中表现为中有三种模型(**C++对象模型是在前两种对象模型上发展而来的，甚至于局部上直接用到前两种对象模型**):
	- 简单对象模型、
	- 表格驱动对象模型
	- C++对象模型。
- 假定有一个 **Point类**，我们将用三种对象模型来表现它。Point类定义如下:
	```cpp
	class Point  
	{  
	public:  
	    Point( float xval ); 
	    virtual ~Point();      
	    float x() const;  
	    static int PointCount();  
	
	protected:  
	    virtual ostream&  print( ostream &os ) const;
	    float _x;  
	
	    static int _point_count;  
	};
	```
### 简单对象模型
- 简单对象模型的**概念**：
	- 一个C++对象存储了所有指向成员的指针，而成员本身不存储在对象中。
	- 也就是说不论数据成员还是成员函数，也不论这个是普通成员函数还是虚函数，它们都存储在对象本身之外，同时对象保存指向它们的指针。
---
- 简单对象模型对于编译器来说虽然极尽简单,但同时付出的代价是**空间和执行期的效率**.
	- 对于每一个成员都要额外搭上一个指针大小的空间
	- 对于每成员的操作都增加了一个间接层。
- 因此C++并没有采用这样一种对象模型，但是被用到了C++中 **“指向成员的指针”** 的概念当中。
![简单对象模型](https://img-blog.csdnimg.cn/20191012211235385.png#pic_center =500x400)
### 表格驱动对象模型
- 表格驱动模型则更绝，
	- 它将对象中所有的成员都抽离出来在外建表，
	- 而对象本身只存储指向这个表的指针。
- 下图可以看到，
	- 它将所有的数据成员抽离出来建成一张 **数据成员表**，
	- 将所有的函数抽取出来建成一张 **函数成员表**，
	- 而对象本身只保持一个 **指向数据成员表的指针**。
	![表格驱动对象模型](https://img-blog.csdnimg.cn/2019101221200329.png#pic_center =500x400)
- ==侯大大认为，在对象与成员函数表中间应当加一个虚箭头，他认为这是Lippman的疏漏之处，应当在对象中保存指向函数成员表的指针。==
- 然而我在这儿还是保留原书（而非译本）的截图，因为以我之拙见，不保存指向成员函数表的指针也没有妨碍。因为形如float Point::x()的成员函数实际上相当于float x(Point*)类型的普通函数，因此保存指向成员函数表的指针当属多此一举。
- 当然C++也没有采用这一种对象模型，但C++却**以此模型作为支持虚函数的方案。**
### C++对象模型
- C++对象模型的组成:
	- 所有的**非静态数据成员**存储在**对象本身中**。
	- 所有的**静态数据成员**、**成员函数（包括静态与非静态）**都置于**对象之外**。
	- 另用一张**虚函数表（virtual table) 存储所有指向虚函数的指针**，并在**表头附加上一个该类的type_info对象**，在**对象中则保存一个指向虚函数表的指针**。
- 如下图:
		![C++对象模型](https://img-blog.csdnimg.cn/20191012213609981.png#pic_center =500x400)
## class和struct关键字的差异
- 按照lippman的意思是，struct仅仅是给想学习C++的C程序员攀上高峰少一点折磨。但遗憾的是当我开始学C++的时候这个问题给我带来更多的疑惑。以我的认识class与struct仅限一个默认的权限（后者为public前者为private）的不同。有时我甚至觉得只有一点畸形，他们不应当如此的相像，我甚至认为struct不应该被扩充，仅仅保存它在C中的原意就好了。[^1]
[^1]:  实际上struct还要复杂一点，它有时表现的会和C struct完全一样，有时则会成为class的胞兄弟。
---
-  一个有意思的C技巧（但别在C++中使用）
	- 在C中将一个一个元素的数组放在struct的末尾，可以令每个struct的对象拥有可变数组。
- 这是一个很有意思的小技巧，但是**别在C++中使用**。因为C++的内存布局相对复杂。例如被继承，有虚函数… 问题将不可避免的发生。
- 看代码：
	```c
	struct mumble {  
	    /* stuff */  
	    char pc[ 1 ];  
	};  
	// grab a string from file or standard input  
	// allocate memory both for struct & string  
	struct mumble *pmumb1 = ( struct mumble* )  
	    malloc(sizeof(struct mumble)+strlen(string)+1);  
	strcpy( &mumble.pc, string );
	```
## 三种编程典范
- 程序模型：数据和函数分开。
- 抽象数据类型模型：数据和函数一起封装以来提供。
- 面向对象模型：可通过一个抽象的base class封装起来，用以提供共同接口，需要付出的就是额外的间接性。

- 纯粹使用一种典范编程，有莫大的好处，如果混杂多种典范编程有可能带来意想不到的后果，例如将继承类的对象赋值给基类对象，而妄想实现多态，便是一种ADT模型和面向对象模型混合编程带来严重后果的例子。
## 一个类的对象的内存大小
- 一个类对象的内存:
	- 所有非静态数据成员的大小。
	- 由内存对齐而填补的内存大小。
	- 为了支持virtual有内部产生的额外负担。(**只增加虚表指针,虚表在对象之外[^2]**)
[^2]:Ref: [C++虚函数表，虚表指针，内存分布](https://blog.csdn.net/li1914309758/article/details/79916414)
- 以下类:
	```cpp
	class ZooAnimal {  
	public:  
	    ZooAnimal();  
	    virtual ~ZooAnimal();  
	    virtual void rotate();  
	protected:  
	    int loc;  
	    String name;  
	};
	```
- 在32位计算机上所占内存为16字节：int四字节，String8字节（一个表示长度的整形，一个指向字符串的指针），以及一个指向虚函数表的指针vptr。对于继承类则为基类的内存大小加上本身数据成员的大小。
- 其内存布局如下图：
	![对象的内存布局](https://img-blog.csdnimg.cn/20191013102850495.png#pic_center =250x400)
---
## 一些结论[^3]
[^3]:Ref: [深度探索c++对象模型（一）](https://www.jianshu.com/p/07c9cdb3e214)

- C++在加入封装后(只含有数据成员和普通成员函数）的布局成本增加了多少？
	- 答案是并没有增加布局成本。就像C struct一样，memeber functions虽然含在class的声明之内，却不出现在object中。每一个non-inline member function只会诞生一个函数实体。至于每一个“拥有零个或一个定义的” inline function则会在其每一个使用者(模块)身上产生一个函数实体。

<br></br>
- C++在布局以及存取时间上主要的额外负担是哪来的?
	- virtual funciton机制，用以支持一个有效率的“执行期绑定”
	- virtual base class，用以实现“多次出现在继承体系中的base class，有一个单一而被共享的实体”

<br></br>
- 继承关系指定为虚拟继承,意味着什么?
	- 在虚拟继承的情况下，base class不管在继承链中被派生(derived)多少次，永远只会存在一个实例(称为subobject)。

<br></br>
- 什么时候应该在c++程序中以struct取代class?
	- 答案之一是当他让人感觉比较好的时候。单独来看，关键词本身并不提供任何差异，c++编译器对二者都提供了相同支持，我们可以认为支持struct只是为了方便将c程序迁移到c++中。

<br></br>
- 那为什么我们要引入class关键词？
	- 这是因为引入的不只是class这个关键词，更多的是它所支持的封装和继承的哲学。

<br></br>
- 怎么在c++中用好struct？
	- 将struct和class组合起来，组合，而非继承，才是把c和c++结合在一起的唯一可行的方法。另外，当你要传递“一个复杂的class object的全部或部分”到某个c函数去时，struct声明可以将数据封装起来，并保证拥有与c兼容的空间布局。

<br></br>
- C++支持多态的方式?
	-  经由一组隐式的转化操作。例如把一个derived class指针转化为一个指向其public base type的指针
		- `shape *ps=new circle();`
	- 经由virtual function机制
		- `ps->rotate();`
	- 经由dynamic_cast和typeid运算符
		- `if(circle *pc=dynamic_cast<circle *>(ps))...`
	- **多态的主要用途是经由一个共同的接口来影响类型的封装，这个接口通常被定义在一个抽象的base class中。这个共享接口是以virtual function机制引发的，它可以在执行期根据object的真正类型解析出到底是哪一个函数实体被调用。**

<br></br>
- 需要多少内存才能表现一个class object? [^4]
	[^4]:详情请参考: [C++中的类所占内存空间总结](https://www.cnblogs.com/acSzz/p/4170602.html )
	- 其nonstatic data members的总和大小
	- 加上任何由于aliginment的需求而填补上去的空间(可能存在于members之间，也可能存在于集合体边界),aliginement就是将数值调整到某数的倍数，如在32位的计算机上为4。
	- 加上为了支持virtual而由内部产生的任何额外负担(**对象内的新增需求仅为一个指针**)

<br></br>
- **转型(cast)其实是一种编译器指令。**
	- 大部分情况下它并不改变一个指针所含的真正地址，**它只影响“被指出之内存大大小和其内容”的解释方式**。
	- 如一个类型为void *的指针只能够持有一个地址，但不能 通过它操作所指object。

<br></br>
- 一个基类指针和其派生类指针有什么不同？（单一一层继承，且其都指向派生类对象）
	- 二者都指向基类对象的第一个byte,其间的差别是，派生类指针涵盖的地址包含整个派生类对象，而一个基类指针所涵盖的地址只包含派生类对象的基类子对象部分。
	- 但基类指针可以通过virtual机制访问派生类对象的函数。
	- 如果基类存在虚函数, 即使派生类被强转为基类, 虚表内依旧保存有原派生的类型,可以通过typeid 获取原派生类类型[^5]
		[^5]:参考一下实现: [二重调度问题:解决方案之虚函数+RTTI](https://blog.csdn.net/zzxiaozhao/article/details/102522121#_RTTI_123)

---
- **以下结论貌似有问题**:
<br></br>
- 当一个base class object被直接初始化为(或被指定为)一个derived class object时,会发生什么?
	- derived object就会被切割(sliced)以塞入较小的base type内存中，derived type将没有留下任何蛛丝马迹。
	- 多态于是不再呈现，而一个严格的编译器可以在编译器解析一个“通过此object而触发的virtual function调用操作”，因而回避virtual机制。
	- 如果virtual function被定义为inline，则更有效率上的大收获。
---
# 第2章 构造函数语意学(The Semantics of constructors)
## 2.1 构造函数

> - 通常很多C++程序员存在两种误解：
>	- 没有定义默认构造函数的类都会被编译器生成一个默认构造函数。
>	- 编译器生成的默认构造函数会明确初始化类中每一个数据成员。

- C++标准规定：
	- 如果类的设计者并未为类定义任何构造函数，那么会有一个默认构造函数被暗中生成，而**这个暗中生成的默认构造函数通常是不做什么事的(无用的)**. 只有**下面四种情况除外**.
	- 换句话说，只有以下四种情况编译器必须为未声明构造函数的类生成一个会做点事的默认构造函数。我们会看到这些默认构造函数仅“忠于编译器”，而可能不会按照程序员的意愿程效命。
### 包含有带默认构造函数的对象成员的类 
- 包含有带默认构造函数的对象成员的类(**某成员变量为带默认构造函数的类的对象**)
	- 若一个类X没有定义任何构造函数，但却包含一个或以上定义有默认构造函数的对象成员，此时编译器会为X合成默认构造函数，该默认函数会调用对象成员的默认构造函数为之初始化。
	- 如果对象的成员没有定义默认构造函数，那么编译器合成的默认构造函数将不会为之提供初始化。
	- 例:
		- 类A包含两个数据成员对象，分别为：*string str* 和 *char Cstr*那么编译器生成的默认构造函数将只提供对string类型成员的初始化，而不会提供对*char*类型的初始化。
		- 假如类X的设计者为X定义了默认的构造函数来完成对str的初始化，形如：A::A(){Cstr=”hello”};因为默认构造函数已经定义，编译器将不能再生成一个默认构造函数。但是 *编译器将会扩充程序员定义的默认构造函数——在最前面插入对初始化str的代码*。若有*多个定义有默认构造函数的成员对象* ，那么这些成员对象的**默认构造函数的调用将依据声明顺序排列。**
### 继承自带有默认构造函数的基类的类
- 继承自带有默认构造函数的基类的类(**基类带有默认构造函数**)
	- 若该派生类**没有定义任何构造函数**但是**派生自带有默认构造函数的基类**，那么**编译器为它定义的默认构造函数，将按照声明顺序为之依次调用其基类的默认构造函数**。
	- 若该派生类*没有定义默认构造函数而定义了多个其他构造函数*,同样*派生自带有默认构造函数的基类*，那么**编译器扩充它的所有构造函数——加入必要的基类默认构造函数, 但是不会合成默认构造函数**。~~另外，*编译器会将基类的默认构造函数代码加在对象成员的默认构造函数代码之前。*~~
### 带有虚函数的类
- **带有虚函数的类**
	- *带有虚函数(**来自声明或继承**)的类，与其它类不太一样，因为它多了一个vptr，而vptr的设置是由编译器完成的，**因此编译器会为类的每个构造函数添加代码来完成对vptr的初始化。***
### 带有一个虚基类的类
- 带有一个虚基类的类
	- 在这种情况下，编译器要将虚基类在类中的位置准备妥当，提供支持虚基类的机制。也就是说要在所有构造函数中加入实现前述功能的的代码。**没有构造函数将合成默认构造函数。**
	- 编译器所做的工作包括:
		- 合成默认构造函数(**如果不存在任何构造函数**)
		- 在对象中插入一个指向虚基类对象的指针
		- 将原来的执行存取操作改变为执行期间决定(**原来是在编译时候通过偏移获取不同的值, 现改为通过指向虚基类对象的指针进行访问**)
---
### 总结
- 从概念来上来讲，每一个没有定义构造函数的类都会由编译器来合成一个默认构造函数，以使得可以定义一个该类的对象，但是默认构造函数是否真的会被合成，将视是否有需要而定。**C++ standard 将合成的默认构造函数分为 trivial(不重要) 和 notrivial(重要) 两种**，前文所述的四种情况对应于notrivial默认构造函数，其它情况都属于trivial。对于一个trivial默认构造函数，编译器的态度是，既然它全无用处，干脆就不合成它。在这儿要厘清的是概念与实现的差别，概念上追求缜密完善，在实现上则追求效率，可以不要的东西就不要。
---
## 2.2 拷贝构造函数（copy constuctor）	
> - 通常C++初级程序员会认为当一个类为没有定义拷贝构造函数的时候，编译器会为其合成一个，答案是否定的。
> - 编译器只有在必要的时候在合成拷贝构造函数。
> - 这是的重点是探索:  **那么编译器什么时候合成，什么时候不合成，合成的拷贝构造函数在不同情况下分别如何工作呢？**
- 拷贝构造函数的定义**有一个参数的类型是其类类型的构造函数是为拷贝构造函数**。如下：
	```cpp
	X::X( const X& x);
	Y::Y( const Y& y, int =0 ); //可以是多参数形式，但其第二个即后继参数都有一个默认值
	```
### 拷贝构造函数的**应用**:  
- **当一个类对象以另一个同类实体作为初值时**，大部分情况下会调用拷贝构造函数。
	- 一般为以下三种具体情况：
		- **显式地以一个类对象作为另一个类对象的初值**，形如X xx=x;
		- 当**类对象被作为参数交给函数时**(会产生一个临时对象)
		- 当**函数返回一个类对象时**(会产生一个临时对象)
- **编译器何时合成拷贝构造函数**
	> - 并不是所有未定义有拷贝构造函数的类编译器都会为其合成拷贝构造函数，编译器只有在必要的时候才会为其合成拷贝构造函数。
	> - 必要的时刻是指编译器在普通手段无法完成解决“当一个类对象以另一个同类实体作为初值”时，才会合成拷贝构造函数。也就是说，当常规武器能解决问题的时候，就没必要动用非常规武器。

	- 如果**一个类没有定义拷贝构造函数，通常按照“成员逐一初始化(Default Memberwise Initialization)”的手法来解决“一个类对象以另一个同类实体作为初值”.**
		- 也就是说把内建或派生的数据成员从某一个对象拷贝到另一个对象身上，如果数据成员是一个对象，则递归使用“成员逐一初始化(Default Memberwise Initialization)”的手法。
		- **成员逐一初始化(Default Memberwise Initialization)具体的实现方式则是位逐次拷贝（Bitwise copy semantics）**[^6]。
		 [^6]: Bitwise copy semantics 是Default Memberwise Intializiation的具体实现方式。[别人的解释]
	- 以下几种情况,如果类没有定义拷贝构造函数，那么**编译器将必须为类合成一个拷贝构造函数**
		- 类**内含一个声明有拷贝构造函数成员对象**(不论是设计者定义的还是编译器合成的）。
		- 类**继承自一个声明有拷贝构造函数的类**（不论拷贝构造函数是被显示声明还是由编译器合成的）。
		- 类中**声明有虚函数**。
		- 当类的派生串链中**包含有一个或多个虚基类**。
### 继承带拷贝构造函数的基类以及内含带拷贝构造函数的对象成员
- 不论是**基类还是对象成员**，既然后者声明有**拷贝构造函数**时，*就表明其类的设计者或者编译器希望以其声明的拷贝构造函数来完成“一个类对象以另一个同类实体作为初值”的工作*. 而**设计者或编译器**这样做——**声明拷贝构造函数**，总有它们的理由，而通常**最直接的原因**莫过于因为他们**想要做一些额外的工作或“位逐次拷贝”无法胜任**。
### 有虚函数的类
- 对于**有虚函数的类**，如果两个对象的类型相同那么位逐次拷贝其实是可以胜任的。但问题在于, 按照位逐次拷贝是无法正常对类中的vptr进行copy的,这将导致无法预料的后果——调用一个错误的虚函数实体是无法避免的，轻则带来程序崩溃，更糟糕的问题可能是这个错误被隐藏了。所以 **对于有虚函数的类编译器将会明确的使被初始化的对象的vptr指向正确的虚函数表**。因此有虚函数的类没有声明拷贝构造函数，编译将为之合成一个，来完成上述工作，以及初始化各数据成员，**声明有拷贝构造函数的话也会被插入完成上述工作的代码**。
### 继承串链中有虚基类
- 对于**继承串链中有虚基类**的情况，问题同样出现在继承类向基类提供初值的情况，此时位逐次拷贝有可能破坏对象中虚基类子对象的位置。
- **当一个相同派生类以另一个同类对象为初值时,使用位逐次拷贝是OK的,问题在于,一个class Object以派生类对象作为初值时.**
### 总结
- 编译器需要合成拷贝构造函数的主要原因有三个:
	- 用户反应使用“位逐次拷贝”无法胜任,或有额外操作(**通过声明拷贝构造函数**)
	- 类中指向虚表的指针(**估计是无法隐式的复制**)
	- 类中有指向虚基类的指针(**问题发生于 一个class Object以派生类对象作为初值时**)
## 2.3 命名返回值优化
- 对于一个如foo()这样的函数，它的每一个返回分支都返回相同的对象，编译器有可能对其做**Named return  Value优化**（下文都简称NRV优化），方法是以**一个参数result取代返回对象**。
- foo()的原型：
	```cpp
	X foo() 
	{ 
	    X xx; 
	    if(...)
	        return xx; 
	    else 
	        return xx; 
	}
	```
- 优化后的foo()以result取代xx：
	```cpp
	void  foo(X &result)
	{
	    result.X::X();
	    if(...)
	    {//直接处理result
	        return;
	    }
	    else
	    {//直接处理result
	        return;
	    }
	}
	```
- 对比优化前与优化后的代码可以看出，对于一句类似于X a = foo()这样的代码，NRV优化后的代码相较于原代码节省了一个临时对象的空间（省略了xx）,同时减少了两次函数调用（**减少xx对象的默认构造函数和析构函数，以及一次拷贝构造函数的调用，增加了一次对a的默认构造函数的调用**）。
---
- 附加[^7]:
  [^7]:[命名返回值优化和成员初始化队列](http://www.roading.org/develop/cpp/%E5%91%BD%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96%E5%92%8C%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97.html)
	- Lippman在《深度探索C++》书中指出NRV的开启与关闭取决于是否有显式定义一个拷贝构造函数，我	实在想不出有什么理由必须要有显示拷贝构造函数才能开启NRV优化，于是在vs2010中进行了测试，
	- 测试结果表明
		- 在release版本中，不论是否定义了一个显式拷贝构造函数，NRV都会开启。由此可见vs2010并不以是否有一个显式拷贝构造函数来决定NRV优化的开启与否。
		- 但同时，立足于这一点，可以得出Lippman所说的以是否有一个显式定义的拷贝构造函数来决定是否开启NRV优化，应该指的是他自己领导实现的cfront编译器，而非泛指所有编译器。
		- 那么cfront又为什么要以是否定义有显示的拷贝构造函数来决定是否开启NRV优化呢？我猜测，他大概这样以为，当显式定义有拷贝构造函数的时候一般代表着要进行深拷贝，也就是说此时的拷贝构造函数将费时较长，在这样的情况下NRV优化才会有明显的效果。反之，不开启NRV优化也不是什么大的效率损失。
	- **另外，有一点要注意的是，NRV优化，有可能带来程序员并不想要的结果，最明显的一个就是——当你的类依赖于构造函数或拷贝构造函数，甚至析构函数的调用次数的时候，想想那会发生什么**。由此可见、Lippman的cfront对NRV优化抱有更谨慎的态度，而MS显然是更大胆。
---
## 2.4 成员初始化队列（Member Initialization List）
>- 对于初始化队列，厘清一个概念是非常重要的：(大概可以如下定义)
>	- 把初始化队列直接看做是对成员的定义，
>	- 构造函数体中进行的则是赋值操作。
- 有四种情况必须用到初始化列表：
	- 有const成员
	- 有引用类型成员
	- 成员对象没有默认构造函数
	- 基类对象没有默认构造函数

- 前两者因为要求定义时初始化，所以必须明确的在初始化队列中给它们提供初值。
- 后两者因为不提供默认构造函数，所有必须显示的调用它们的带参构造函数来定义即初始化它们。
<br><br>
- **显而易见的是当类中含有对象成员或者继承自基类的时候，在初始化队列中初始化成员对象和基类子对象会在效率上得到提升——省去了一些赋值操作嘛。**
<br><br>
- 最后，一个关于初始化队列众所周知的陷阱，**初始化队列的顺序**
	- 无论在初始化列表中是什么顺序总是会按照定义的顺序进行初始化
# 第3章 Data语意学（The Semantics of Data）
## 3.1 C++对象的大小
- 一个实例引出的思考
	```cpp
	class X{};
	class Y:virtual public X{};
	class Z:virtual public X{};
	class A:public Y, public Z{};
	```
- 猜猜sizeof上面各个类都为多少？
	```cpp
	// Lippman的一个法国读者的结果是
	sizeof X yielded 1
	sizeof Y yielded 8
	sizeof Z yielded 8
	sizeof A yielded 12
	// vs2010上的结果是
	sizeof X yielded 1
	sizeof Y yielded 4
	sizeof Z yielded 4
	sizeof Z yielded 8
	//gcc
	sizeof X yielded 1
	sizeof Y yielded 8
	sizeof Z yielded 8
	sizeof A yielded 16
	```
- 事实上，对于像X这样的一个的空类，编译器会对其动点手脚——隐晦的插入一个字节。为什么要这样做呢？插入了这一个字节，那么X的每一个对象都将有一个独一无二的地址。如果不插入这一个字节呢？哼哼，那对X的对象取地址的结果是什么？两个不同的X对象间地址的比较怎么办？
<br><br>
- 我们再来看Y和Z。首先我们要明白的是实现虚继承，将要带来一些额外的负担——额外需要一个某种形式的指针。到目前为止，对于一个32位的机器来说Y、Z的大小应该为5，而不是8或者4。我们需要再考虑两点因素：内存对齐（alignment—）和编译器的优化。
	- alignment[^8]会将数值调整到某数的整数倍，32位计算机上位4bytes。内存对齐可以使得总线的运输量达到最高效率。所以Y、Z的大小被补齐到8就不足为奇了。
	 [^8]: 关于更多的memory alignment（内存对齐）的知识见[VC内存对齐准则（Memory alignment）](http://www.roading.org/develop/cpp/vc%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%87%86%E5%88%99%EF%BC%88memory-alignment%EF%BC%89.html), [VC对齐](https://blog.csdn.net/zzxiaozhao/article/details/102522121#VCMemory_alignment_297)
	- 那么在vs2010中为什么Y、Z的大小是4而不是8呢？我们先思考一个问题，X之所以被插入1字节是因为本身为空，需要这一个字节为其在内存中给它占领一个独一无二的地址。但是当这一字节被继承到Y、Z后呢？它已经完全失去了它存在的意义，为什么？因为Y、Z各自拥有一个虚基类指针，它们的大小不是0。既然这一字节在Y、Z中毫无意义，那么就没必要留着。也就是说vs2010对它们进行了优化，优化的结果是去掉了那一个字节,而Lippman的法国读者的编译器显然没有做到这一点。
<br><br>
- 当我们现在再来看A的时候，一切就不是问题了。对于那位Lippman的法国读者来说，A的大小是共享的X实体1字节,X和Y的大小分别减去虚基类带来的内存空间，都是4。A的总计大小为9，alignment以后就是12了。而对于vs2010来说，那个一字节被优化后，A的大小为8，也不需再进行alignment操作。

## 总结
- 影响C++类的大小的三个因素[^8]：
	- 支持特殊功能所带来的额外负担（对各种virtual的支持）。
	- 编译器对特殊情况的优化处理。
	- alignment操作，即内存对齐。
## 3.2 DataMember 的绑定(略,狗啊!)
## 3.3 VC内存对齐准则（Memory alignment）
> - 本文所有内容在建立在一个前提下：**使用VC编译器**。
> - 着重点在于：
>	- VC的内存对齐准则；
>	- 同样的数据，不同的排列有不同的大小;
>	- 在有虚函数或虚拟继承情况下又有如何影响？
> - 内存对齐？！What？Why?
>	- 对于一台32位的机器来说如何才能发挥它的**最佳存取效率**呢？当然是每次都读4字节（32bit）,这样才可以让它的bus处于最高效率。实际上它也是这么做的，即使你只需要一个字节，它也是读一个机器字长（这儿是32bit）。更重要的是，有的机器在存取或存储数据的时候它要求数据必须是对齐的，何谓对齐？它要求数据的地址从4的倍数开始，如若不然，它就报错。还有的机器它虽然不报错，但对于一个类似int变量，假如它横跨一个边界的两端，那么它将要进行两次读取才能获得这个int值。比方它存储在地址为2-5的四个字节中，那么要读取这个int，将要进行两次读取，第一次读取0-3四个字节，第二次读取4~7四个字节。但是如果我们把这个整形的起始地址调整到0,4,8…呢？一次存取就够了！这种调整就是内存对齐了。我们也可以依次类推到16位或64位的机器上。

---
## 结论 
- [Ref](https://blog.csdn.net/zzxiaozhao/article/details/102522121#VCMemory_alignment_297):
- 假设规定对齐量为4， 
	- **char（1byte）变量应该存储在偏移量为1的倍数的地方**， 
	- **int(4byte)则是从偏移量为4的倍数的地方**， 
	- **double(8 byte)也同样应存储在偏移量为4的倍数的地方**
- **结构体整体的大小也应该对齐，对齐依照规定对齐量与最大数据成员两者中较小的进行。**
- **Vptr影响对齐而VbcPoint(Virtual base class pointer)不影响。**
---
## 3.4 C++对象的数据成员
- 数据成员的布局
- 对于一个类来说它的对象中**只存放非静态的数据成员**,但是**除此之外**，编译器**为了实现virtual功能还会合成一些其它成员插入到对象中**。我们来看看这些成员的布局。

- C++ 标准的规定:
	- 在同一个Access Section（也就是private,public,protected片段）中，要求较晚出现的数据成员处在较大的内存中。这意味着同一个片段中的数据成员并不需要紧密相连，编译器所做的成员对齐就是一个例子。
	- 允许编译器将多个Acess Section的顺序自由排列，而不必在乎它们的声明次序。但似乎没有编译器这样做。
	- 对于继承类，C++标准并未指定是其基类成员在前还是自己的成员在前。
	- 对于虚基类成员也是同样的未予规定。

- 一般的编译器怎么做？
	- 同一个Access Section中的数据成员按期声明顺序，依次排列。
	- 但成员与成员之间因为内存对齐的原因可能存在空当。
	- 多个Access Section按其声明顺序排放。
	- 基类的数据成员总放在自己的数据成员之前，但虚基类除外。

- 编译器合成的成员放在哪？
	>- 为了实现虚函数和虚拟继承两个功能，编译器一般会合成Vptr和Vbptr两个指针。那么**这两个指针应该放在什么位置**？C++标准肯定是不曾规定的，因为它甚至并没有规定如何来实现这两个功能，因此就语言层面来看是不存在这两个指针的。

	- 对于Vptr来说有的编译器将它放在末尾，如Lippman领导开发的Cfront。有的则将其放在最前面，如MS的VC，但似乎没人将它放在中间。为什么不放在中间？没有理由可以让人这么做，放在末尾，可以保持C++类对C的struct的良好兼容性，放在最前可以给多重继承下的指针或引用调用虚函数带来好处。
		- 在VS2010和VC6.0中运行的结果都是地址值&x.a比&x大4，可见说**vc的vptr放在对象的最前面此言非虚**。
		- 实验如下：
			```cpp
			class X{
			public:
			    int a;
			    virtual void vfc(){};
			};
			int main()
			{
			    using namespace std;
			    X x;
			    cout<<&x.a<<" "<<&x<<endl;
			    system("pause");
			}
			```
	- 对于Vbptr而言一般的看法为:在每一个虚派生对象中安插一个指向虚基对象的指针
		- 缺点:
				- 多占用了一个指针的空间
				- 随着**虚继承链增长**, 可能会存在多次间接存取问题, 不能得到固定的存取时间
有好几种方法:
		- cfront 对第二个问题的解决方案:  **在虚继承链上取nest virtual base class ptr**
		- VC方案:对第二个问题的解决方案: 在虚继承体系下新增加一个vitual base class table(虚基类表),虚基类表中则存放有指向虚基类的指针,而对象内增加一个指向虚基类表的指针.
		- 另一种解决方案: **在虚函数表中放置 虚基类对象 的偏移量(相对于对象起始位置的偏移量)**
			- 如虚基类对象指针 = rhs + rhs._vptr[-1][^9]
				[^9]:Sun公司实现的编译器 - 虚函数表取负值,表示取回虚基类对象的偏移量,rhs 表示一个存在虚基类的对象. 

<br></br>
- **对象成员或基类对象成员后面的填充空白不能为其它成员所用**
	- 看一段代码：
		```cpp
		class X{
		public:
		    int x;
		    char c;
		};
		class X2:public X
		{
		public:char  c2;
		};
		```
		- X2的布局应当是x(4),c(1),c2(1),这么说来sizeof(X2)的值应该是8？错了，实际上是12。原因在于X后面的三个字节的填充空白不能为c2所用。也就是说X2的大小实际上为：X(8)+c2(1)+填补（3）=12。

- Vptr与Vbptr
	- **在多继承情况下**，即使是多虚拟继承，继承而得的类**只需维护一个Vbptr**；
	- 而多继承情况下Vptr则可能要维护多个Vptr，看其基类有几个虚函数。
	- 一条继承线路只有一个Vptr，但可能有多个Vbptr，视有几次虚拟继承而定。换句话说:
		- 对于继承类对象来说，不需要新合成vptr，而是使用其基类子对象的vptr。
		- 而虚拟继承类对象，必须新合成一个自己的Vbptr。
	- 实例:
		```cpp
		class X{
		    virtual void vf(){};
		};
		class X2:virtual public X
		{
		    virtual void vf(){};
		};
		class X3:virtual public  X2
		{
		     virtual void vf(){};
		}
		```
	- X3将包含有一个Vptr，两个Vbptr。确切的说这两个Vbptr一个属于X3，一个属于X3的子对象X2,X3通过其Vbptr找到子对象X2，而X2通过其Vbptr找到X。
	- 其中差别在于vptr通过一个虚函数表可以确切地知道要调用的函数，而Vbptr通过虚基类表只能够知道其虚基类子对象的偏移量。这两条规则是由虚函数与虚拟继承的实现方式，以及受它们的存取方式和复制控制的要求决定的。

## 数据成员的存取
- 静态数据成员相当于一个仅对该类可见的全局变量，因为程序中只存在一个静态数据成员的实例，所以其地址在编译时就已经被决定。不论如何静态数据成员的存取不会带来任何额外负担。
- **非静态数据成员的存取，相当于对象起始地址加上偏移量**。效率上与C struct成员的效率等同。因为它的偏移量在编译阶段已经确定。**但有一种情况例外：pt->x=0.0。当通过指针或引用来存取——x而x又是虚基类的成员的时候。因为必须要等到执行期才能知道pt指向的确切类型，所以必须通过一个间接导引才能完成**

---
- 附加:
	- 类中对静态成员变量取址: 对静态成员取地址,将会得到一个指向数据类型的指针,而不是一个指向class member的指针,因为静态成员并不内含与class object中.
---
## 小结
- 在VC中数据成员的布局顺序为：
	- vptr部分（如果基类有，则继承基类的）
	- vbptr （如果需要）
	- 基类成员（按声明顺序）
	- 自身数据成员
	- 虚基类数据成员（按声明顺序）
# 第4章 Function语意学（The Semantics of Function）
## 4.1 C++之成员函数调用
> - c++支持三种类型的成员函数，每一种调用方式都不尽相同
>	- static-Function
>	- nostatic-Function
>	- virtual-Function

### 非静态成员函数（Nonstatic Member Functions）
- **保证nostatic member function至少必须和一般的nonmember function有相同的效率是C++的设计准则之一。** 事实上在c++中非静态成员函数（nostatic member function）与普通函数的调用也确实具有相同的效率，因为**本质上非静态成员函数就如同一个普通函数**.
	- 编译器内部会将成员函数等价转换为非成员函数，具体是这样做的: 改写成员函数的签名，使得其可以接受一个额外参数，这个额外参数即是this指针, 当然如果成员函数是const的，插入的this 参数类型将为 const xxx 类型。
	- 例:
		```cpp
		float Point::X();
		//成员函数X被插入额外参数this
		float Point:: X(Point* this );
		```
	 	- 非静态成员函数X float Point::X();就相当于一个普通函数float X(Point* this);
		- 将每一个对非静态数据成员的操作都改写为经过this操作。
		- 将成员函数写成一个外部函数，对函数名进行“mangling”处理，使之成为独一无二的名称。

- 将一个成员函数改写成一个外部函数的关键在于两点，
	- 一是给函数提供一个可以直接读写成员数据的通道，给函数提供一个额外的指针参数
	- 二是解决好有可能带来的名字冲突,通过一定的规则将名字转换，使之独一无二。
---
- T：2019/10/16 19:13
- 起始对于一个类中的成员函数(包括虚函数),提供一个可以直接读写成员数据的通道， **至关重要！！！**， 看面关于多继承下的多态问题，对这个概念尤为深刻。
---
- 由此可以做出一点总结：
	- 一个成员函数实际上就是**一个被插入了一个接受其类的指针类型的额外参数的非成员函数**，还要额外对函数的名称进行处理。**额外插入的参数用来访问数据成员，而名称的特殊处理用来避免名字冲突。**
- 对于名称的特殊处理并没有统一的标准，各大编译器厂商可能有不同的处理规则。
	- 在VC下上述的成员函数X()的名称X处理后就	成了?X@Point@@QAEMXZ
	- 更多信息可以参见维基百科的Visual C++名字修饰。
- VC中对于上面的例子中的成员函数的调用将发生如下的转换：
	```cpp
	//p->X();被转化为
	?X@Point@@QAEMXZ(p);
	//obj.X();被转化为
	?X@Point@@QAEMXZ(&obj);
	```
### 虚拟成员函数(Virtual Member Functions)
- 如果function()是一个虚拟函数，
	- 那么**用指针或引用进行的调用**将发生一点特别的转换  ——  一个中间层被引入进来。
- 例如：
	```cpp
	// p->function()
	// 将转化为
	(*p->vptr[1])(p);
	```
	- 其中vptr为指向虚函数表的指针，它由编译器产生。vptr也要进行名字处理，因为一个继承体系可能有多个vptr。
	- 1是虚函数在虚函数表中的索引，通过它关联到虚函数function().
- 何时发生这种转换？答案是在必需的时候——一个再熟悉不过的答案。
- **当通过指针调用的时候，要调用的函数实体无法在编译期决定，必需待到执行期才能获得，所以上面引入一个间接层的转换必不可少。**
- 但是==当我们通过对象（不是引用，也不是指针）来调用的时候，进行上面的转换就显得多余了，因为在编译器要调用的函数实体已经被决定。此时调用发生的转换，与一个非静态成员函数(Nonstatic Member Functions)调用发生的转换一致。==
### 静态成员函数(Static Member Functions)
- 静态成员函数的一些特性：
	- **不能够直接存取其类中的非静态成员（nostatic members）**，包括不能调用非静态成员函数(Nonstatic Member Functions)。
	- **不能够声明为 const、voliatile或virtual**。
	- 它不需经由对象调用，当然，通过对象调用也被允许。
- **除了缺乏一个this指针他与非静态成员函数没有太大的差别。** 在这里**通过对象调用和通过指针或引用调用，将被转化为同样的调用代码。**
- **需要注意的是通过一个表达式或函数对静态成员函数进行调用，C++ Standard要求对表达式进行求值。**
	- 如：`(a+=b).static_fuc();`
- 虽然省去对a+b求值对于static_fuc()的调用并没有影响，但是程序员肯定会认为表达式a+=b已经执行，一旦编译器为了效率省去了这一步，很难说会浪费多少程序员多少时间。这无疑是一个明智的规定。


## 4.2 C++之虚函数(Virtual Member Functions)
> - 深度探索C++对象模型》是这样来说多态的:
> 	- 在C++中,多态表示“以一个public base class的指针（或引用），寻址出一个derived class object”的意思。


### 静态多态性与动态多态性[^10]
[^10]: [静态多态性与动态多态性](https://blog.csdn.net/Virtual_Func/article/details/47666011)
- 多态：以一个 “public base class” 的指针寻址出一个 “derived class object”（深入探索C++对象模型定义）
	- **静态多态性**: 通常称为编译时多态，到底模板是不是多态？？？我个人认为不是
	- **动态多态性**: 通常称为运行时多态，通过虚函数来实现
- 动态多态性的两个条件：
	- 在基类中必须使用虚函数或纯虚函数
	- 调用函数时使用基类的指针或引用
### 消极多态与积极多态
- 消极多态（没有进行虚函数的调用）
	- 用基类指针来寻址继承类的对象，我们可以这样：
		- `Point ptr=new Point3d;               //Point3d继承自Point`
	- 在这种情况下，多态可以在编译期完成（虚基类情况除外），因此被称作消极多态（没有进行虚函数的调用, 指针的多态机能主要扮演一个输送机制的角色）。
-  积极多态(对象类型需要在执行期才能决定)
	- 积极多态的例子如虚函数和RTTI
	- 如下例关于虚函数的调用， 虚函数的实现机制，将保证调用的z()函数实现,为Point3d:: z()而不是调用了Point:: z()。
	- 例子：
		```cpp
		//例1，虚函数的调用
		ptr->z();
		//例2，RTTI 的应用
		if(Point3d *p=dynamic_cast<Point3d*>(ptr) )
			return p->z();
		```
### 虚函数的实现
- 虚函数的实现：
	- 为每个有虚函数的类配一张虚函数表，它存储该类类型信息和所有虚函数执行期的地址。
	- 为每个有虚函数的类插入一个指针（vptr）,这个指针指向该类的虚函数表。
	- 给每一个虚函数指派一个在表中的索引。
	- 用这种模型来实现虚函数得益于在C++中,虚函数的地址在编译期是可知的，而且这一地址是固定不变的。而且表的大小不会在执行期增大或减小。
<br><br>
- 类的虚函数表中存储有类型信息:
	- 有类型信息（存储在索引为0的位置）
	- 所有虚函数地址
	- 部分编译器还把虚基类的指针放到了虚函数表里面,如早期的Sum编译器
- 虚函数地址包括三种：
	- 这个类定义的虚函数，会改写（overriding）一个可能存在的基类的虚函数实体——假如基类也定义有这个虚函数。
	- 继承自基类的虚函数实体，——基类定义有，而这个类却没有定义。直接继承之。
	- 一个纯虚函数实体。用来在虚函数表中占座，有时候也可以当做执行期异常处理函数。
- 每一个虚函数都被指派一个固定的索引值，这个索引值在整个继承体系中保持前后关联，例如,假如z()在Point虚函数表中的索引值为2，那么在Point3d虚函数表中的索引值也为2。
### 单继承下的虚函数
- 类单继承自有虚函数的基类时，将按如下步**骤构建虚函数表**：
	- 继承基类中声明的虚函数——这些虚函数的实体地址被**拷贝**到继承类中的虚函数表中对于的slot中。
	- 如果有**改写**（override）基类的虚函数，那么在1中应将改写（override）的函数实体的地址放入对应的slot中而不是拷贝基类的。
	- 如果有定义新的虚函数，那么将虚函数表**扩大**一个slot以存放新的函数实体地址。
- 例子:
	```cpp
	ptr->z();
	//被编译器转化为：
	(*ptr->vptr[4])(ptr);
	```
- 我们假设z()函数在Point虚函数表中的索引为4，回到最初的问题——要如何来保证在执行期调用的是正确的z()实体？其中微妙在于，编译将做一个小小的转换:
- 这个转换保证了调用到正确的实体，因为：
	- 虽然我们不知道ptr所指的真正类型,但它可以通过vptr找到正确类型的虚函数表。在整个继承体系中z()的地址总是被放在slot 4。

### 多重继承下的虚函数
- 多重继承中支持virtual functions，其复杂度围绕在第二个及后继的base classes身上，以及“必须在执行期调整this指针”这一点。如下是多重继承体系：
	```cpp
	class Base1
	{
	public:
		Base1();
		virtual ~Base1();
		virtual void speakClearly();
		virtual Base1* clone() const;
	protected:
		float data_Base1;
	};
	 
	class Base2
	{
	public:
		Base2();
		virtual ~Base2();
		virtual void mumble();
		virtual Base2* clone() const;
	protected:
		float data_Base2;
	};
	 
	class Derived: public Base1,public Base2
	{
	public:
		Derived();
		virtual ~Derived();
		virtual Derived* clone() const;
	protected:
		float data_Derived;
	};
	```
- “Derived 支持virtual functions”困难度，都落在Base2 suboject身上，有三个问题要解决：
	- 1.virtual destructor；(进行删除对象的时候,需要把指针调整至于派生类上)
	- 2.被继承下来的Base2::mumble();(需要把指针调整至Base2上)
	- 3.一组clone()函数实例。
- 分析: (**注意编译器需要调整Base2的指针**)
	```cpp
	Base2* pbase2 = new Derived;
	 
	//编译器转化，新的Derived对象必须调整
	//以指向Base2 subobject
	Derived* temp = new Derived;
	Base2* pbase2 = temp?temp + sizeof(Base1):0;
	 
	//调整后，调用虚函数正确
	pbase2->data_Base2; // 指向base2
	 
	//删除pbase2时候，必须正确调用virtual destructor实例
	//然后delete
	delete pbase2; // 指向derived
	```
- 实现过程(Thunk技术):
	- 在多重继承之下，一个derived class内含n-1个额外的virtual tables，n表示其上一次base classes的个数（因此单一继承将不会产生额外的virtual tables）。对于本例而言的Derived，会有两个virtual tables被编译器产生：
		- 一个主要实例，与Base1（最左端base clss）共享, `vtbl_Derived; //主要表格`
		- 一个次要实例，与Base2（第二个base class）有关,`vtbl_Base2_Derived; //次要表格`
	- Thunk允许 虚函数表中的slot包括的地址包括两个类型:
		- 不需要调整地址, 指向虚函数实体地址
		- 需要调整地址,指向一个相关的Thunk(估计是一个偏移量之类的)
	- 当将一个Derived对象地址指定给一个Base1指针或Derived指针，被处理的virtual table主要表格vtbl_Derived;
	- 当将一个Derived对象地址指定给一个Base2指针时，被处理的virtual tables是次要表格vtbl_Base2_Derived;
	- 分析
		- 通过“指向第二个base class”的指针，调用derived class virtual function。ptr必须调整指向Baes2 subobject。
		- 通过“指向derived class”的指针，调用第二个base class中一个继承而来的virtual function。derived class 指针必须再次调整指向第二Base2 subobject
- 图示
				![多重基类虚表配置](https://img-blog.csdnimg.cn/20191016211050923.png#pic_center)
---
- 做如下小结：
- 多继承下的虚函数，影响到虚函数的调用的实际质上为this的调整。而this调整一般为两种：
	- 调整指针指向对应的sub object，一般发生在继承类类型指针向基类类型指针赋值的情况下。
	- 将指向sub object的指针调整回继承类对象的起始点，一般发生在基类指针对继承类虚函数进行调用的时候。
- 第一点，使得该基类指针指向一个与其指针类型匹配的子对象，唯有如此才能保证使得该指针在执行与其指针类型相匹配的特定行为的正确性。比方调用基类的成员，获得正确的虚函数地址。
- 第二点，显然是让一个继承类的虚函数获取一个正确的this指针，因为一个继承类虚函数要的是一个指向继承类对象的this指针，而不是指向其子对象。
- 第一顺序继承类之所以不需要进行调整的关键在于，其sub object的起点与继承类对象的起点一致。
### 虚拟继承下的虚函数
- Lippman说，如果一个虚基类派生自另一虚基类，而且它们都支持虚函数和非静态数据成员的时候，编译器对虚基类的支持就像迷宫一样复杂。
- 图
	![虚基类虚表配置](https://img-blog.csdnimg.cn/20191016211441239.png#pic_center)
## 4.3 指向成员函数的指针
### "指向Nonstatic Member Functions"的指针
>- 取一个nonstatic data member的地址,得到的结果是该member在 class 布局中的byte位置(再加1),它是一个不完整的值,须要被绑定于某个 class object的地址上,才可以被存取.
>- 取一个nonstatic member function的地址,假设该函数是nonvirtual,则得到的结果是它在内存中真正的地址.然而这个值也是不全然的,它也须要被绑定与某个 class object的地址上,才可以通过它调用该函数,全部的nonstatic member functions都须要对象的地址(以參数 this 指出).
- 关于指向成员函数指针的 声明 赋值 调用:
	- 声明member function的指针:
		```cpp
		double		// return type
		(Point::*	// class the function is member
		 pmf)		// name of the pointer to member
		();			// argument list
		```
	- 定义并初始化该指针:`double (Point::*coord)() = &Point::x;`
	- 指针赋值: `coord = &Point::y;`
	- 调用它:`(origin.*coord)();` 或 `(ptr->*coord)();`
		- 这些操作会被编译器转化为: `(coord)(&origin);`和`(coord)(ptr);`
- 关于指向成员函数指针的分析
	- 指向member function的指针的声明语法 中加入 `Point::*` 的作用是是作为 this 指针的空间保留者.这这也就是为什么 static member function(没有 this 指针)的类型是"函数指针",而不是"指向member function的指针"的原因.
- 效率的讨论:
	- 使用一个"member function指针",(不用于 virtual function,多重继承,virtual base class 等情况的话),并不会比使用一个"nonmember function指针"的成本更高.
	- virtual function,多重继承,virtual base class 三种情况的话对于"member function指针"的类型以及调用都太过复杂
### "指向Virtual Member Functions"的指针
- 注意以下的程序片段:
	```cpp
	float (Point::*pmf)() = &Point::z;
	Point *ptr = new Point3d;
	```
- pmf,一个指向member function的指针,被设值为Point::z()(一个 virtual function)的地址,ptr则被指定以一个Point3d对象,
	- 直接经由ptr调用z(): `ptr->z();` 则被调用的是point3d:: z(),
	- 从pmf间接调用z() `(ptr->pmf)();` 仍然是Point3d:: z()被调用
- 也就是说,虚拟机制仍然可以在使用"指向member function的指针"的情况下运行 !

- 对一个nonstatic member function取其地址,将获得该函数在内存中的地址,然而面对一个 virtual function,其地址在编译时期是未知的,所能直到的仅是 virtual function在其相关的 virtual table中的索引值.也就是说,对一个 virtual member function取其地址,所能获得的仅仅是一个索引值.
- 具体实现过程如下:
- 例子:
	```cpp
	class Point {
	public:
		virtual ~Point();
		float x();
		float y();
		virtual float z();
	};
	```
- 对nonstatic函数取地址:
	- 取x()或y()的地址: `&Point::x();`  或 `&Point::y();` 得到的则是**函数在内存中的地址**,由于它们不是 virtual
- 对virtual函数取地址:
	- 取得destructor的地址:`&Point::~Point;` 得到的结果是1(**索引值.**)
	- 取z()的地址:`&Point:: z();` 得到的结果是2(**索引值.**)
- 对指向虚函数的函数指针调用:
	- 通过pmf来调用z(),会被内部转化为一个编译时期的式子,一般形式例如以下: `(*ptr->vptr[(int)pmf])(ptr);`
	- 对一个"指向member function的指针"评估求值(evaluted),会由于该值有两种意义而复杂化;其调用操作也将有别于常规调用操作.
	- pmf的内部定义,为`float (Point::*pmf)();`
		- 这里该定义可以指向nonvirtual x()和 virtual z()两个member functions,因为其有着同样的原型:
			- 只是当中一个代表内存地址
			- 还有一个代表 virtual table中的索引值
			```cpp
			// 二者都能够被指定给pmf
			float Point::x() { return _x; }
			float Point::z() { return 0; }
			```
	- 因此,编译器必须定义pmf使它能够
		- (1)还有两种数值,
		- (2)更重要的是其数值能够被差别代表内存地址还是 virtual table中的索引值.
# 第5章 构造、解构、拷贝 语意学（Semantics of Construction，Destruction，and Copy）
## 几点类设计原则
- **即使是一个抽象基类，如果它有非静态数据成员，也应该给它提供一个带参数的构造函数，来初始化它的数据成员。** 或许你可以通过其派生类来初始化它的数据成员（假如nostatic data member为publish或protected）,但这样做的后果则是破坏了数据的封装性，使类的维护和修改更加困难。由此引申，类的data member应当被初始化，且只在其构造函数或其member function中初始化。

- **不要将析构函数设计为纯虚的，这不是一个好的设计。** 将析构函数设计为纯虚函数意味着，**即使纯虚函数在语法上允许我们只声明而不定义纯虚函数，但还是必须实现该纯虚析构函数，否则它所有的继承类都将遇到链接错误。**
	- 必须定义纯虚析构函数，而不能仅仅声明它的原因在于：
		- 每一个继承类的析构函数会被编译器加以扩展，以静态调用方式其每一个基类的析构函数（假如有的话，不论是显示的还是编译器合成的），所以只要任何一个基类的析构函数缺乏定义，就会导致链接失败。
		- 矛盾就在这里，纯虚函数的语法，允许只声明而不定义纯虚析构函数，而编译器则死脑筋的看到一个其基类的析构函数声明，则去调用它的实体，而不管它有没有被定义。

- **真的必要的时候才使用虚函数，不要滥用虚函数。** 虚函数意味着不小的成本，编译很可能给你的类带来膨胀效应：
	- 每一个对象要多负担一个word的vptr。给每一个构造函数（不论是显示的还是编译器合成的），插入一些代码来初始化vptr，这些代码必须被放在所有基类构造函数的调用之后，但需在任意用户代码之前。
	- 没有构造函数则需要合成，并插入代码。
	- 合成一个拷贝构造函数和一个复制操作符（如果没有的话），并插入对vptr的初始化代码，有的话也需要插入vptr的初始化代码。
	- 意味着，**如果具有bitwise语意，将不再具有**，然后是变大的对象、没有那么高效的构造函数，没有那么高效的复制控制。
- **不能决定一个虚函数是否需要 const ，那么就不要它**。
- **决不在构造函数或析构函数中使用虚函数机制(并不是说不要把构造函数和析构函数设置为虚函数)**。
	- **在构造函数中，每次调用虚函数会被决议为当前构造函数所对应类的虚函数实体，虚函数机制并不起作用。**
	- **当一个base类的构造函数含有对虚函数vf()的调用，当其派生类derived的构造函数调用基类base的构造函数的时候，其中调用的虚函数vf()是base中的实体，而不是derived中的实体。** 
		- 这是由**vptr初始化的位置**决定的——**在所有基类构造函数调用之后，在程序员供应的代码或是成员初始化队列之前**。
		- 因构造函数的调用顺序是：有根源到末端，由内而外，所以对象的构造过程可以看成是，从构建一个最基础的对象开始，一步步构建成一个目标对象。析构函数则有着与构造相反的顺序，因此在构造或析构函数中使用虚函数机制，往往不是程序员的意图。**若要在构造函数或析构函数中调用虚函数，应当直接以静态方式调用，而不要通过虚函数机制。**
## 构造、复制、析构语意学
- 一种所谓的**Plain OI’Data**声明形式：
	```cpp
	struct Point {
	    float x,y,z;
	};
	```
- 概念上来讲，对于一段这样的C++代码,编译器会为之合成一个默认构造函数、复制构造函数、析构函数、赋值操作符。
- 然而实际上编译器会分析这段代码，并给Point贴上Plain OI’Data标签。**编译器在此后对于Point的处理与在C中完全一样,也就是说上述的函数都不会被合成**。可见概念上应当由编译器合成的函数，并不一定会合成，编译器只有在必要的时候才会合成它们。由此一来，原本在观念上应该调用这些函数的地方实质上不会调用，而是用其它的方法来完成上面的功能，**比方复制控制会用bitwise copy。**
- 对象构造语意学 
	- 无继承情况下的对象构造：略。
		 - [5.1 无继承情况下的对象构造(注意和书对比有问题 !!!)](https://blog.csdn.net/Virtual_Func/article/details/47782449)
---
- 单继承体系下的对象构造 [对照一下](https://blog.csdn.net/Virtual_Func/article/details/47833063)
	- 对于简单定义的一个对象T object;,很明显它的默认构造函数会被调用（被编译器合成的或用户提供的）。但是一个构造函数究竟做了什么，就显得比较复杂了——编译器给了它很多的隐藏代码。编译器一般会做如下扩充操作：
	- 调用所有虚基类的构造函数，从左到右，从最深到最浅：
		- 如果该类被列于成员初始化列表中，任何明确指定的参数，都应该被传递过来。若没有列入成员初始化列表中，虚基类的一个默认构造函数被调用（有的话）。
		- 此外，要保证虚基类的偏移量在执行期可存取，对于使用vbptr来实现虚基类的编译器来说，满足这点要求就是对vbptr的初始化。
		- 然而，只有在类对象代表着“most-derived class”时，这些构造函数才可能会被调用。一些支持这个行为的代码会被放进去（直观点说就是，虚基类的构造由最外层类控制)。
	- 调用所有基类构造函数，依声明顺序：
		- 如果该基类被列入了成员初始化队列，那么所有明确指定的参数，应该被传递过来。
		- 没有列入的话，那么调用其默认构造函数，如果有的话。
		- 如果该基类是第二顺位或之后的基类，this 指针必须被调整。
	- 正确初始化vptr,如果有的话。
	- 调用没有出现在初始化成员列表中的member object的默认构造函数，如果有的话。
	- 记录在成员初始化队列中的数据成员初始化操作以声明的顺序被放进构造函数中。
---
-  多重继承的构造函数流程:
	- 在派生类构造函数中,**所有虚基类**以及**上一层的基类**的构造函数都被调用
	- 对象的vptr(s)被初始化指向相关的virtual table(s)
	- 执行构造函数的成员初始化列表
	- 执行**程序猿** 提供的初始化代码段;
- 对象复制语意学 
	- 设计一个类，并考虑到要以一个对象指定给另一个对象时，有三种选择：
		- 什么都不做，采用编译器提供默认行为（bitwise copy或者由编译器合成一个）。
		- 自己提供一个赋值运算符操作。
		- 明确拒绝将一个对象指定给另一个对象。
	- 对于第三点，只要将赋值操作符声明为private，且不定义它就可以了。
	- 对于第二点，只有在第一点的行为不安全或不正确，或你特别想往其中插入点东西的时候。
	- **以下四种情况** copy assignment operator(还是用它的英文名，感觉顺畅点)，**不具有bitwise copy语意**，也就是说这些情况下，编译器要合成copy assignment operator而不能依靠bitwise copy来完成赋值操作，这四种情况与构造函数、拷贝构造函数的情况类似，原因可以参考它们的。四种情况如下：
		- 类包含有定义了copy assignment operator的class object成员。
		- 类的基类有copy assignment operator。
		- 类声明有任何虚函数的时候（问题同样会出现在由继承类对象向基类对象拷贝的时候）。
		- 当class继承体系中有虚基类时。
	- 在虚拟继承情况下，copy assignment opertator会遇到一个不可避免的问题，virtual base class sub object的复制行为会发生多次，与前面说到的在虚拟继承情况下虚基类被构造多次是一个意思，不同的是在这里不能抑制非most-derived class 对virtual base class 的赋值行为。
		- 安全的做法是把虚基类的赋值放在最后，避免被覆盖。
---
- 对象析构语意学
	- 只有在基类拥有析构函数，或者object member拥有析构函数的时候，编译器才为类合成析构函数，否则都被视为不需要。
	- 析构的顺序正好与构造相反：
		- 本身的析构函数被执行。
		- 以声明的相反顺序调用member object 的析构函数，如果有的话。
		- 重设vptr 指向适当的基类的虚函数表，如果有的话。
		- 以声明相反的顺序调用上一层的析构函数，如果有的话。
		- 如果当前类是 most-derived class，那么以构造的相反顺序调用虚基类的析构函数。
# 第6章 执行期语意学（Runting Semantics）

1. 实际上struct还要复杂一点，它有时表现的会和C struct完全一样，有时则会成为class的胞兄弟。 ↩︎

2. Ref:[C++虚函数表，虚表指针，内存分布](https://blog.csdn.net/li1914309758/article/details/79916414)

3. Ref: [深度探索c++对象模型（一）](https://www.jianshu.com/p/07c9cdb3e214)

4. 详情请参考: [C++中的类所占内存空间总结](https://www.cnblogs.com/acSzz/p/4170602.html)

5. 参考一下实现: [二重调度问题:解决方案之虚函数+RTTI](https://blog.csdn.net/zzxiaozhao/article/details/102522121#_RTTI_123)

6. Bitwise copy semantics 是Default Memberwise Intializiation的具体实现方式。[别人的解释]

7. [命名返回值优化和成员初始化队列](http://www.roading.org/develop/cpp/%E5%91%BD%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96%E5%92%8C%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97.html)

8. 关于更多的memory alignment（内存对齐）的知识见[VC内存对齐准则（Memory alignment）,VC对齐](http://www.roading.org/develop/cpp/vc%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%87%86%E5%88%99%EF%BC%88memory-alignment%EF%BC%89.html)

9. Sun公司实现的编译器 - 虚函数表取负值,表示取回虚基类对象的偏移量,rhs 表示一个存在虚基类的对象. ↩︎

10. [静态多态性与动态多态性](https://blog.csdn.net/Virtual_Func/article/details/47666011)

# 面试题

>> T:2019/11/28  W:四 17:0:11
[HTML]: @[TOC](面经汇总 C++基础再探)

# C++ 基础
## 1、引用和指针的区别？ 
- 初始化:
	- 引用在定义的时候必须进行初始化，并且不能够改变
	- 指针在定义的时候不一定要初始化，并且指向的空间可变

- 访问逻辑不同:
	- 通过指针访问对象, 用户需要使用间接访问
	- 通过引用访问对象, 用户只需使用直接访问, 编译器负责将其处理为间接访问

- 运算结果不同:
	- 自增运算结果不同
	- `sizeof`运算的结果不同
	- 下标运算: 
		- 指针通过下标运算结果是指针所指值为基地址加上偏移, 且基地址可变.
		- 引用通过下标运算结果是引用的是数组才能有这个操作.
	- 函数参数:
		- 传指针的实质是传值，传递的值是指针内储存的变量地址；
		- 传引用的实质是传地址，传递的是变量的地址。
	- 多级: 有多级指针，但是没有多级引用，只能有一级引用。


***
- 参考: [C++ 引用占用内存？ - toyijiu的专栏 - CSDN博客](https://blog.csdn.net/toyijiu/article/details/99729949)


***

## 2、从汇编层去解释一下引用
- 参考两个语句
	```c
	int a=1;
	int &b=a;
	// 
***
	mov ptr [ebp-4], 1
	lea eax, [ebp-4]
	mov dword ptr [ebp-8], eax
	```
- `a`的地址为`ebp-4`,` b`的地址为`ebp-8`, 栈地址由高到底分配.
- 可以发现这个和指针的复制几乎一样,所以引用其实是通过指针来实现的

## 3、C++中的指针参数传递和引用参数传递
- **指针参数传递的本质是值传递, 传递的值是对象的地址**, 在调用时形参会在函数栈中开辟空间用于存放传递过来的对象的地址,此时形参相当于是实参的副本, 对形参的任何操作都不会反映到实参上, 但是通过形参间接访问对象的修改是会反应到函数之外的.
- **引用参数传递的本质是传地址, 传递的是实参变量的地址**, 首先形参会在函数栈中开辟空间用来存放实参变量的地址, 然后对该形参的任何操作都会被处理未间接寻址,即通过形参中的地址访问主调函数中的实参变量, 因为通过形参的任何操作都将被应用于主调函数中.
- 从逻辑上引用相当于对变量起了一个别名, 通过该别名可以对变量进行直接访问, 由编译器负责将直接访问转换为间接访问; 而指针访问变量都是间接访问.

## 4、形参与实参的区别？
- 形参属于函数内部的局部变量, 在调用函数时才会分配内存, 在函数调用之后会被释放掉, 因此在函数内部才有效
- 实参可以使常量, 表达式, 函数等, 无论是何种类型,在函数调用时都必须有一个确定的值,以便把函数的值传递给形参
- 实参和形参的个数一定要严格匹配(当然可以忽略有默认值形参), 通常情况下函数类型也是应该严格匹配的, 但是允许隐式类型变换,如果类中定义了零参数构造函数,甚至可以使用空初始化列表`{}`的方式调用零参数构造函数
- 实参到形参的传递是单向的
- 形参类型为非指针非引用, 则传递方式为值传递则, 形参为实参的副本, 对形参的任何修改都不会反应在主调函数中

## 4-2 三种传递方式
- 值传递是通过拷贝构造函数实现的
- 指针传递是属于值传递,实参指针向形参传递的是对象的地址
- 引用传是属于传地址, 相当于对变量起了一个别名, 本质上和指针传递类似传递的都是对象的地址,区别在于对该引用形参的任何操作都会被处理为间接云芝, 也就是会反应到调用函数中

## 5、`static`的用法
- 主要可以分为五个类型: 全局静态变量, 局部静态变量, 静态函数, 静态成员变量, 静态成员函数
1. 全局静态变量
	- 在全局变量前加上关键字`static`，全局变量就定义成一个全局静态变量.
	- 内存中的位置：静态存储区，在整个程序运行期间一直存在。
	- 初始化：未经初始化的全局静态变量会被自动初始化为`0`(对于自动对象,如果没有显示初始化,会调用零参数构造函数,如不存在则编译失败);
	- 作用域：**全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。**
2. 局部静态变量
	- 在局部变量之前加上关键字`static`，局部变量就成为一个局部静态变量。
	- 内存中的位置：静态存储区
	- 初始化：未经初始化的全局静态变量会被自动初始化为`0`(对于自动对象,如果没有显示初始化,会调用零参数构造函数,如不存在则编译失败)；
	- 作用域：作用域仍为局部作用域，
		- 当定义它的函数或者语句块结束的时候，作用域结束。
		- 但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

3. 静态函数
	- 在函数返回类型前加`static`，函数就定义为静态函数。**函数的定义和声明在默认情况下都是`extern`的**，但**静态函数只是在声明他的文件当中可见，不能被其他文件所用**。
	- 函数的实现使用`static`修饰，**那么这个函数只可在本`cpp`内使用，不会同其他`cpp`中的同名函数引起冲突；**
	- `warning`：不要再头文件中声明`static`的全局函数，不要在`cpp`内声明非`static`的全局函数，如果你要在多个`cpp`中复用该函数，就把它的声明提到头文件里去，否则`cpp`内部声明需加上`static`修饰；

4.  类的静态成员
	- 在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。
	- 因此，**静态成员是类的所有对象中共享的成员，而不是某个对象的成员**。对多个对象来说，静态数据成员只存储一处，供所有对象共用

5. 类的静态函数
	- **静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员**。因此，对静态成员的引用不需要用对象名。
	- **在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员(这点非常重要)**。*如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);*
	- 不能被`virtual`修饰,静态成员函数没有`this` 指针，虚函数的实现是为每一个对象分配一个`vptr` 指针，而`vptr` 是通过`this` 指针调用的，所以不能为`virtual`；虚函数的调用关系，`this`->`vptr`->`ctable`->`virtual function`


## 6、静态变量什么时候初始化
- 静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，
- 但在`C `和`C++`中静态局部变量的初始化节点又有点不太一样。
	- 在`C`中，**初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化**，所以我们看到==在`C `语言中无法使用变量对静态局部变量进行初始化==，在程序运行结束，变量所处的全局内存会被全部回收。
	- 而在`C++`中，**初始化时在执行相关代码时才会进行初始化**，主要是由于`C++`引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以  **`C++`标准规定为全局或静态对象是有首次用到时才会进行构造** ，并通过`atexit()`来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在 **`C++`中是可以使用变量对静态局部变量进行初始化的。**

## 7、const?
- 一般可以分为如下六种类型
	- `const`变量: 表明标了为`const`类型, 通常需要被初始化否则后面将不能被修改, 对该变量的修改操作都会被编译器阻止.
	- `const`指针对象: 标明该指针为普通的左值类型可以进行修改, 但是不能通过该变量修改做指向的对象, 则通过该指针只能访问`const`类型的成员函数.
	- `const`引用: 它所绑定的对象不能被修改
	- `const`形参: 和普通的实参分类一样分为const 变量, const指针对象, const 引用, 作用也类似,表示不能修改该变量. 
	- `const`返回值: 通常是为了表明返回值是一个**const类型防止返回值被修改**, 或则**被当做左值放在赋值运算的左边**
	- `const`成员函数: 是指成员函数不会修改类对象的任何成员变量, 如果返回值为对象成员的引用则必须返回`const`引用, 同时`const`成员函数不能调用非`const`函数, 其主要是因为`const`成员函数所持有的`this`指针是一个`const`类型的指针, 因为不能调用非`const`类型的成员函数, 


***
- 参考: [c++函数返回类型什么情况带const - A_zhu - 博客园](https://www.cnblogs.com/Azhu/p/4352613.html)


***

## 8、`const `成员函数的理解和应用？
- `① const Stock & Stock::topval (②const Stock & s) ③const`
- ① 处`const`：确保返回的`Stock `对象在以后的使用中不能被修改
- ② 处`const`：确保此方法不修改传递的参数`s`
- ③ 处`const`：保证此方法不修改调用它的对象，`const `对象只能调用`const `成员函数,不能调用非`const `函数

## 9、指针和`const`的用法
- 当`const `修饰指针时，由于`const `的位置不同，它的修饰对象会有所不同。
- **(常指针对象)** `int *const p2 `中`const `修饰`p2 `的值,所以理解为`p2 `的值不可以改变，即`p2 `只能指向固定的一个变量地址，但可以通过`*p2 `读写这个变量的值。顶层指针表示指针本身是一个常量
- **(常指针)** `int const *p1 `或者`const int *p1 `两种情况中`const `修饰`*p1`，所以理解为`*p1 `的值不可以改变，即不可以给`*p1 `赋值改变`p1 `指向变量的值，但可以通过给`p `赋值不同的地址改变这个指针指向。底层指针表示指针所指向的变量是一个常量。

## 10、`mutable`
- 如果需要在`const `成员方法中修改一个成员变量的值，那么需要将这个成员变量修饰为`mutable`。**即用`mutable `修饰的成员变量不受`const `成员方法的限制;**
- 可以认为`mutable `的变量是类的辅助状态，但是只是起到类的一些方面表述的功能，修改他的内容我们可以认为对象的状态本身并没有改变的。实际上由于`const_cast`的存在，这个概念很多时候用处不是很到了。


***
- 通常情况下
	- `const`成员函数时不能被类对象的成员变量的, 但是可以修改被`mutable`修饰的成员变量
	- 通常我们任务`mutable`位类的辅助状态, 只是类的一些表诉功能, **修改它不会改变对象的状态**
	- 通常我们可以是用`const_cast`在`const`成员函数中修改所有的成员变量


***

## 11、`extern `用法？
- `extern `修饰变量的声明
	- 如果文件`a.c `需要引用`b.c `中变量`int v`，就可以在`a.c `中声明`extern int v`，然后就可以引用变量`v`。
- `extern `修饰函数的声明
	- 如果文件`a.c `需要引用`b.c `中的函数，比如在`b.c `中原型是`int fun(int mu)`，那么就可以在`a.c `中声明`extern int fun(int mu)`，然后就能使用`fun `来做任何事情。
	- 就像变量的声明一样，`extern int fun(int mu)`可以放在`a.c `中任何地方，而不一定非要放在`a.c `的文件作用域的范围中。
	- 默认情况情况下函数都是`extern`的, 除非使用`static`对函数进行了隐匿
- `extern `修饰符可用于指示`C `或者`C++`函数的调用规范。
	- 比如在`C++`中调用`C `库函数，就需要在`C++`程序中用`extern “C”`声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用`C `函数规范来链接。主要原因是`C++`和`C `程序编译完成后在目标代码中命名规则不同。

## 12、`int` 转字符串, 字符串转`int`
- `C++11` 标准增加了全局函数`std::to_string`
- 可以使用`std::stoi`/`std::stol`/`std::stoll` 等等函数

## 12.1 `strcat`,`strcpy`,`strncpy`,`memset`,`memcpy` 的内部实现？
- `strcat`: `char *strcat(char *dst, char const *src);`
	- 头文件: `#include <string.h>`
	- 作用: 将`dst`和`src`字符串拼接起来保存在`dst`上
	- 注意事项:
		- `dst`必须有足够的空间保存整个字符串
		- `dst`和`src`都必须是一个由`\0`结尾的字符串(空字符串也行)
		- `dst`和`src`内存不能发生重叠
	- 函数实现:
		- 首先找到`dst`的`end`
		- 以`src`的`\0`作为结束标志, 将`src`添加到`dst`的`end`上
	- `Code`
	```c
	char *strcat (char * dst, const char * src){
	    assert(NULL != dst && NULL != src);   // 源码里没有断言检测
	    char * cp = dst;
	    while(*cp )
	         cp++;                      /* find end of dst */
	    while(*cp++ = *src++) ;         /* Copy src to end of dst */
	    return( dst );                  /* return dst */
	}
	```
- `strcpy`: `char *strcpy(char *dst, const char *src);`
	- 头文件:`#include <string.h>`
	- 作用: 将`src`的字符串复制到`dst`字符串内
	- 注意事项:
		- `src`必须有结束符(`\0`), 结束符也会被复制
		- `src`和`dst`不能有内存重叠
		- `dst`必须有足够的内存
	- 函数实现:
	```c
	char *strcpy(char *dst, const char *src){   // 实现src到dst的复制
	    if(dst == src) return dst;              //源码中没有此项
	　  assert((dst != NULL) && (src != NULL)); //源码没有此项检查，判断参数src和dst的有效性
	　　char *cp = dst;                         //保存目标字符串的首地址
	　　while (*cp++ = *src++);                 //把src字符串的内容复制到dst下
	　　return dst;
	}
	```
- `strncpy`: `char *strncpy(char *dst, char const *src, size_t len);`
	- 头文件: `#include <string.h>`
	- 作用: 从`src`中复制`len`个字符到`dst`中, 如果不足`len`则用`NULL`填充, 如果`src`超过`len`, 则`dst`将不会以`NULL`结尾
	- 注意事项:
		- `strncpy `把源字符串的字符复制到目标数组，它总是正好向` dst `写入` len `个字符。
		- 如果` strlen(src) `的值小于` len`，`dst `数组就用额外的` NULL `字节填充到` len `长度。
		- 如果` strlen(src)`的值大于或等于` len`，那么只有` len `个字符被复制到`dst`中。这里需要注意它的结果将不会以`NULL`字节结尾。
	- 函数实现:
	```c
	char *strncpy(char *dst, const char *src, size_t len)
	{
	    assert(dst != NULL && src != NULL);     //源码没有此项
	    char *cp = dst;
	    while (len-- > 0 && *src != '\0')
	        *cp++ = *src++;
	    *cp = '\0';                             //源码没有此项
	    return dst;
	}
	```
- `memset`: `void *memset(void *a, int ch, size_t length);`
	- 头文件: `#include <string.h>`
	- 作用: 
		- 将参数`a`所指的内存区域前`length`个字节以参数`ch`填入，然后返回指向`a`的指针。
		- 在编写程序的时候，若需要将某一数组作初始化，`memset()`会很方便。
		- 一定要保证`a`有这么多字节
	- 函数实现:
	```c
	void *memset(void *a, int ch, size_t length){
	    assert(a != NULL);     
	    void *s = a;     
	    while (length--)     
	    {     
	        *(char *)s = (char) ch;     
	        s = (char *)s + 1;     
	    }     
	    return a;     
	}
	```
- `memcpy`
	- 头文件: `#include <string.h>`
	- 作用: 
		- 从` src `所指的内存地址的起始位置开始，拷贝`n`个字节的数据到` dest `所指的内存地址的起始位置。
		- 可以用这种方法复制任何类型的值，
		- **如果`src`和`dst`以任何形式出现了重叠，它的结果将是未定义的。**
	- 函数实现:
	```c
	void *memcpy(void *dst, const void *src, size_t length)
	{
	    assert((dst != NULL) && (src != NULL));
	　　char *tempSrc= (char *)src;            //保存src首地址
	　　char *tempDst = (char *)dst;           //保存dst首地址
	　　while(length-- > 0)                    //循环length次，复制src的值到dst中
	       　　*tempDst++ = *tempSrc++ ;
	　　return dst;
	}
	```


***
- `strcpy `和` memcpy `的主要区别：
	- 复制的内容不同:` strcpy `只能复制字符串，而` memcpy `可以复制任意内容，例如字符数组、整型、结构体、类等。
	- 复制的方法不同:` strcpy `不需要指定长度，它遇到被复制字符的串结束符`\0`才结束，所以容易溢出。`memcpy `则是根据其第`3`个参数决定复制的长度，遇到`\0`并不结束。
	- 用途不同: 通常在复制字符串时用` strcpy`，而需要复制其他类型数据时则一般用` memcpy`


***
- 参考: [各种C语言处理函数 strcat，strcpy，strncpy，memset，memcpy 总结 - New World - CSDN博客](https://blog.csdn.net/nyist_zxp/article/details/80982472)

## 13、深拷贝与浅拷贝？
- 浅复制: 
	- 只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“(浅复制)浅拷贝”，
	- 换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。
- 深复制: 在计算机中开辟了一块新的内存地址用于存放复制的对象。


***
- 浅复制的问题:
	- 在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。
	- 这时，如果B 中有一个成员变量指针已经申请了内存，那A 中的那个成员变量也指向同一块内存。
	- 这就出现了问题：当B把内存释放了(如：析构)，这时A 内的指针就是野指针了，出现运行错误。


***

## 14、`C++`模板是什么，底层怎么实现的？
- **编译器并不是把函数模板处理成能够处理任意类的函数**；编译器从函数模板通过具体类型产生不同的函数；
- 编译器会对函数模板进行两次编译：
	- 在声明的地方对模板代码本身进行编译，
	- 在调用的地方对参数替换后的代码进行编译。
- 这是因为**函数模板要被实例化后才能成为真正的函数**，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。

- 模板可以重载返回值, 函数重载不行

***
- 如果我们试图通过在头文件中定义函数模板, 在`cpp`文件中实现函数模板, 那么我们必须在在实现的那个`cpp`文件中**手动实例化**, 也就是使用你需要使用的参数替换模板, 从而使得编译器为你编译生成相应参数的模板函数.


***

## 15、`C `语言`struct `和`C++` `struct `区别
- `struct `在`C语言`中:
	- 是**用户自定义数据类型`(UDT)`**；
	- 只能是一些**变量的集合体**, 成员不能为函数
	- 没有权限设置
	- 一个**结构标记**声明后，在`C`中必须在**结构标记**前加上`struct`，才能做**结构类型名**;


***
- `struct `在`C++`中:
	- 是**抽象数据类型`(ADT)`**，支持成员函数的定义，(能继承，能实现多态)。
	- 增加了访问权限, 默认访问限定符为`public`(为了与`C `兼容)，`class `中的默认访问限定符为`private`
	- 定义完成之后, 可以直接使用**结构体名字**作为**结构类型名**
	- 可以使用模板

***

## 16、虚函数可以声明为`inline`吗?
- **虚函数要求在运行时进行类型确定，而内敛函数要求在编译期完成相关的函数替换, 所以不能**

***
- 虚函数用于实现运行时的多态，或者称为晚绑定或动态绑定。
- 内联函数用于提高效率, 对于程序中需要频繁使用和调用的小函数非常有用。它是在**编译期间**，对调用内联函数的地方的代码**替换**成函数代码。

***

## 17、类成员初始化方式？构造函数的执行顺序？为什么用成员初始化列表会快一些？
- 概念
	- 赋值初始化，通过在函数体内进行赋值初始化；
	- 列表初始化，在冒号后使用初始化列表进行初始化。
- 这两种方式的主要区别在于：
	- 对于在**函数体中初始化**,是在所有的成员函数分配空间后才进行的。**对于类对象类型成员变量, 则是先调用零参数构造函数, 如果零参数构造函数不存在编译器将会报错.**
	- 列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式)。

- 快的原因: 所以对于列表初始化: 只进行了一次初始化操作, 而赋值初始化则先进性了一次初始化,然后调用了一次复制构造函数.

- 一个派生类构造函数的执行顺序如下：
	- **虚基类**的构造函数(多个虚拟基类则按照继承的顺序执行构造函数)。
	- **基类**的构造函数(多个普通基类也按照继承的顺序执行构造函数)。
	- **类类型的成员对象**的构造函数(按照初始化顺序)
	- 派生类**自己的构造函数**。

## 18、成员列表初始化？
- **必须**使用成员初始化的四种情况
	- 当初始化一个**引用**成员时；
	- 当初始化一个**常量成员**时；
	- **基类**， **无零参数构造函数**时
	- **成员类**，  **无零参数构造函数**时
- 成员初始化列表做了什么
	- 编译器在调用用户代码之前, 会按照类成员声明顺序一一初始化成员变量, 如果成员初始化类别中有初值,则使用初值构造成员函数. 
	- 初始化顺序由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的；

## 19、构造函数为什么不能为虚函数？析构函数为什么要虚函数？
### 构造函数为什么不能为虚函数?
- 首先是没必要使用虚函数:
	- 由于使用间接调用(通过引用或则指针)导致类**类型不可信**, 而使用虚函数机制完成正确的函数调用.
	- 但是构造函数本身是为了初始化对象实例, 创建对象必须制定它的类型, 其类类型是明确的, 因此在编译期间即可确定调用函数入口地址
	- 因而没必要使用虚函数, 其调用在编译时由编译器已经确定. 

- 其次不能使用虚函数:
	- 虚函数的调用依赖于虚函数表, 虚函数表储存于静态储存区, 在存在虚函数的对象中都将插入一个指向虚函数表的指针, 
	- 在对象中插入一个指向虚函数表的指针是由构造函数完成的, 也就是说在调用构造函数时并没有指向虚函数表的指针, 也就不能完成虚函数的调用. 

### 析构函数为什么要虚函数？
- `C++`中基类采用`virtual `虚析构函数是为了防止内存泄漏。
	- 如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。
	- 假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。
	- 所以，为了防止这种情况的发生，`C++`中基类的析构函数应采用`virtual `虚析构函数。	

## 20、析构函数的作用，如何起作用？
- 析构函数名与类名相同,只是在函数名前增加了取反符号`~`以区别于构造函数,其不带任何参数, 也**没有返回值**.  也**不允许重载**. 
- 析构函数与构造函数的作用相反, 当对象生命周期结束的时候,如对象所在函数被调用完毕时,析构函数负责结束对象的生命周期. **注意如果类对象中分配了堆内存一定要在析构函数中进行释放.** 
- 和拷贝构造函数类似,如果用户未定义析构函数, 编译器**并不是一定**会自动合成析构函数, 只有在**成员变量或则基类**拥有析构函数的情况下它才会自动合成析构函数. 
- 如果**成员变量或则基类**拥有析构函数, 则编译器一定会合成析构函数, 负责调用成员变量或则基类的析构函数, 此时如果用户提供了析构函数,则编译器会在用户析构函数之后添加上述代码.
- 类析构的顺序为: 派生类析构函数, 对象成员析构函数, 基类析构函数. 

## 21、构造函数和析构函数可以调用虚函数吗，为什么
- 在C++中，提倡不在构造函数和析构函数中调用虚函数；
- 在构造函数和析构函数调用的所有函数(包括虚函数)都是编译时确定的, 虚函数将运行该类中的版本. 
	- 因为**父类对象会在子类之前进行构造**，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；
	- 析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。


***
- 参考: [C++构造函数和析构函数的调用顺序 - DoubleLi - 博客园](https://www.cnblogs.com/lidabo/p/9328323.html)


***

## 22、构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？
- 构造函数顺序:
	- **基类**构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。
	- **成员类对象**构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。
	- **派生类**构造函数。
- 析构函数顺序:
	- 调用**派生类**的析构函数；
	- 调用**成员类对象**的析构函数；
	- 调用**基类**的析构函数。

## 23、虚析构函数的作用，父类的析构函数是否要设置为虚函数？
- `C++`中基类采用`virtual `虚析构函数是为了防止内存泄漏。
	- 如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。
	- 假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。
	- 所以，为了防止这种情况的发生，`C++`中基类的析构函数应采用`virtual `虚析构函数。	


***
- **纯虚析构函数一定得有定义**，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。**因此缺乏任何一个基类析构函数的定义，就会导致链接失败。**==因此，最好不要把虚析构函数定义为纯虚析构函数。==


***

## 24、`构造函数``析构函数`可以调用虚函数吗？
- 在`构造函数`和`析构函数`中最好不要调用虚函数；
- 在`构造函数`和`析构函数`中调用的成员函数都是属于**编译时确定**的,并**不具有虚函数的动态绑定特性**, 有如下原因:
	- **在构造时, 父类对象总是先于子类对象构造**的, 如果父类的析构函数使用虚函数机制调用子类的函数, 结果将是不可预料的
	- **在析构时, 子类的析构函数总是先于父类**执行, 如果父类的析构函数使用虚函数机制调用子类的函数, 结果将是不可预料的


***
- **参考**: [21、构造函数和析构函数可以调用虚函数吗，为什么](#21%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e5%92%8c%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0%e5%8f%af%e4%bb%a5%e8%b0%83%e7%94%a8%e8%99%9a%e5%87%bd%e6%95%b0%e5%90%97%e4%b8%ba%e4%bb%80%e4%b9%88)

***

## 25、`构造函数`, `析构函数`可否抛出异常
- 构造函数异常
	- 后果:
		- **(原因):**`C++`拒绝为**没有完成构造函数的对象**调用**析构函数**，原因是避免开销
		- 构造函数中发生异常，控制权转出构造函数。如果构造函数中申请了堆内存, 则堆内存将无法释放, 从而造成内存泄漏
		- 例如: 在对象`b `的构造函数中发生异常，对象`b `的析构函数不会被调用。**因此会造成内存泄漏**。
	- 解决方案:
		- 使用**智慧指针**来管理堆内存. 其不需要在析构函数中手动释放资源. 在发生异常时, 智慧指针会自动释放资源从而避免了内存泄漏. 
		- **一般建议不要在构造函数里做过多的资源分配。**
- 析构函数异常
	- 后果:
		- 在异常传递的**堆栈辗转开解**的过程中, 如果发生析构异常, `C++`会调用`terminate`终止程序
		- 如果析构函数发生发生异常，则异常后面的代码将不执行，无法确保完成我们想做的清理工作。
	- 解决方法：
		- 如果异常不可避免，则应在析构函数内捕获，而不应当抛出。
		- 在析构函数中使用`try-catch`块屏蔽所有异常。
	- 附加说明:
		-  **(后果1):** 如果某一个异常发生,某对象的析构函数被调用,而此时析构发生了异常并流出了函数之外,则函数会被立即terminate掉(函数外有catch也不能拯救)

***
- 参考: 
	- `More Effective`: [M9 使用析构函数防止资源泄漏](https://blog.csdn.net/zzxiaozhao/article/details/102504097#M9__116)
	- `More Effective`: [M10 在构造函数中防止资源泄漏](https://blog.csdn.net/zzxiaozhao/article/details/102504097#M10__139)
	- `More Effective`: [M11 禁止异常流出 destructors 之外](https://blog.csdn.net/zzxiaozhao/article/details/102504097#M11__destructors__142)

***

## 26、类如何实现`只能静态分配`和`只能动态分配`
- 建立类的对象有两种方式：
	- 静态建立(栈空间)
		- 静态建立一个类对象，就是由编译器为对象在栈空间中分配内存, 然后调用构造函数初始化这片内存空间.
		- 使用这种方法，**直接调用类的构造函数**。
	- 动态建立(堆空间)，`A *p = new A()`; 
		- 动态建立类对象, 使用new操作符将在堆空间分配内存, 然后调用构造函数初始化这片内存空间.
		- 这种方法，**间接调用类的构造函数**。
- 只能在堆上建立
	- 分析: 类对象只能建立在堆上，就是不能**静态建立类对象**，即不能**直接调用类的构造函数**。
	- 实现方式: 将**析构函数设为私有或则受保护**
	- 方法分析:
		- 静态建立:
			- 当对象`建立`在栈上面时，是由编译器分配内存空间的，调用`构造函数`来`构造`栈对象。
			- 当对象使用`完`后，编译器会调用`析构函数`来`释放`栈对象所占的空间。
			- 编译器管理了对象的整个生命周期。
		- 编译器在为类对象**分配栈空间**时，会**先检查类的析构函数的访问性**，
			- 其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。
			- 如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。
			- 因此，将析构函数设为私有，类对象就无法建立在栈上了。
		- 由此引发的问题:
			- 因为析构函数设置为了私有
			- 需要设置一个`public函数`来调用析构函数
		- 代码如下：
		```cpp
		class  A  
		{  
		protected :  
		    A(){}  
		    ~A(){}  
		public :  
		    static  A* create()  
		    {  
		        return   new  A();  
		    }  
		    void  destory()  
		    {  
		        delete   this ;  
		    }  
		};  
		```
- 只能在栈上建立
	- 只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。**将operator new()设为私有即可**。
	- **注意: 重载了`new`就需要重载`delete `**
	- 代码如下：
		```cpp
		class  A  
		{  
		private :  
		    void * operator  new ( size_t  t){}      // 注意函数的第一个参数和返回值都是固定的   
		    void  operator  delete ( void * ptr){}  // 重载了new就需要重载delete   
		public :  
		    A(){}  
		    ~A(){}  
		}; 
		```

***
- 参考: 
	- [在堆/栈上建立对象](https://zhaostu4.github.io/2019/11/28/%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97-%E7%BB%93%E8%AE%BA%E9%9B%86%E5%90%88/#%E5%9C%A8%E5%A0%86%E6%A0%88%E4%B8%8A%E5%BB%BA%E7%AB%8B%E5%AF%B9%E8%B1%A1)
	- [如何定义一个只能在堆上（栈上）生成对象的类?](https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618)

***

## 27、如果想将某个类用作基类，为什么该类必须定义而非声明？
- 因为在继承体系下, 子类会继承父类的成员, 并且编译器会在子类的构造函数和析构函数中插入父类的构造和析构部分, 因而父类必须有定义. 

## 28、什么情况会自动生成默认构造函数？
- 四种情况:
	- 类成员对象带有默认构造函数.
	- 基类带有默认构造函数
	- 类中存在虚函数
	- 继承体系中存在虚继承

- **在合成的默认构造函数中，只有基类子对象和类类型对象会被初始化**，而其他所有的非静态成员(如整数，指针，数组等)，都不会初始化，对他们进行初始化的应该是程序员，而非编译器。
- 注意：值类型的默认值并不是默认构造的初始化。

***
- 参考: [C++关于编译器合成的默认构造函数 - Cheny# - 博客园](https://www.cnblogs.com/zjc0202/p/4504227.html)

***

## 29、什么是类的继承？
- 类与类之间的关系
	- `(has-A)`包含关系，即一个类的成员属性是另一个已经定义好的类
	- `(use-A)`使用关系, 一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式实现；
	- `(is-A)`继承关系, 继承关系，关系具有传递性；
- 继承的相关概念
	- 所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，
	- 被称为子类或者派生类，被继承的类称为父类或者基类；
- 继承的特点
	- 子类拥有父类的所有属性和方法，子类对象可以当做父类对象使用；
	- 子类可以拥有父类没有的属性和方法；
- 继承中的访问控制
	- `public`、`protected`、`private`
- 继承中的构造和析构函数
	- 子类中构造函数的调用顺序为: 基类构造函数, 成员对象构造函数, 派生类构造函数
	- 子类中析构函数的调用顺序为: 派生类析构函数, 成员对象析构函数, 基类析构函数
- 继承中的兼容性原则
	- 类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。
	- 参考: [继承中的类型兼容性原则 - Say舞步 - 博客园](https://www.cnblogs.com/zhangyaoqi/p/4591571.html)

## 30、什么是组合？
- 一个类里面的数据成员是另一个类的对象，即内嵌其他类的对象作为自己的成员；
- 如果内嵌类没有零参数构造函数， 则必须使用初始化列表进行初始化
- 构造函数的执行顺序：
	- 按照内嵌对象成员在组合类中的定义顺序调用内嵌对象的构造函数。
	- 然后执行组合类构造函数的函数体，析构函数调用顺序相反。

## 31、抽象基类为什么不能创建对象？
- 抽象类的定义：**带有纯虚函数的类**为抽象类。
- 抽象类的作用：
	- 抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。
	- 所以抽象类实际上刻画了一组子类的**操作接口**的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。
- 使用抽象类时注意：
	- 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。
	- 如果**派生类中没有给出所有纯虚函数的实现**，而只是继承基类的纯虚函数，则这个**派生类仍然是一个抽象类**。
	- 如果**派生类中给出了所有纯虚函数的实现**，则该**派生类就不再是抽象类**了，它是一个可以建立对象的具体的类。
	- **抽象类是不能定义对象的**。

***
- 纯虚函数定义: 纯虚函数是一种特殊的虚函数，它的一般格式如下：
	```cpp
	class <类名>
	{
		virtual <类型><函数名>(<参数表>)=0;
		…
	};
	```
- 纯虚函数引入原因
	- 为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。
	- 在很多情况下，基类本身生成对象是不合情理的。
	- 例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。
- 为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数(方法: `virtual ReturnType Function()= 0;`)。
	- 若要使派生类为非抽象类，则编译器要求在派生类中，必须对纯虚函数予以重载以实现多态性。
	- **同时含有纯虚函数的类称为抽象类**，它不能生成对象。

***
- 相似概念
	- 多态性
		- 指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。
		- C++支持两种多态性：编译时多态性，运行时多态性。
			- 编译时多态性(静态多态)：通过重载函数实现。
			- 运行时多态性(动态多态)：通过虚函数实现。
	- 虚函数
		- 虚函数是在基类中被声明为`virtual`，并在派生类中重新定义的成员函数，可实现成员函数的动态重载。
	- 抽象类
		- 包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。

## 32、类什么时候会析构？
- 对于静态对象: 当离开作用区域之后, 对象生命周期结束, 编译器会自动调用析构函数
- 对于动态对象: 当对对象指针调用delete时, 会调用析构函数终止对象生命周期并释放内存. 其中对象指针指针可以对象类型的指针, 也可以时基类指针(注意基类析构函数位虚函数)
- 第三种情况: 当对象中存在嵌入对象时, 该对象析构时, 嵌入对象也会被析构

## 33、为什么友元函数必须在类内部声明？
- 因为编译器必须能够读取这个结构的声明以理解这个数据类型的大、行为等方面的所有规则。
- 有一条规则在任何关系中都很重要，那就是谁可以访问我的私有部分。

***
- 编译器通过读取类的声明从而进行类的访问权限控制, 而友元函数有权访问本类的所有成员, 因而它必须在类内部进行声明, 使得编译器可以正确处理他的权限. 

***

## 34、介绍一下C++里面的多态？
- 静态多态(重载, 模板): 是在编译的时候，就确定调用函数的类型。
- 动态多态(覆盖, 虚函数实现): 在运行的时候，才确定调用的是哪个函数，动态绑定。运行基类指针指向派生类的对象，并调用派生类的函数。


***
- 参考: [理解的虚函数和多态](https://zhaostu4.github.io/2019/11/28/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB-C++%E5%9F%BA%E7%A1%80/#%E7%90%86%E8%A7%A3%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81)
- 函数重载: 
	- 同一可访问区域内, 存在多个不同参数列表的同名函数, 由编译器根据调用参数决定那个函数应该被调用
	- 函数重载不关心返回值类型, 但是对于函数类型时关心的, 例如类中的两个函数拥有相同参数列表的同名函数, 一个为const类型, 一个为非const类型, 依旧时属于函数重载.
- 函数模板:
	- 模板函数会经历两遍编译: 
		- (模板编译)在定义模板函数时对模板本身进行编译
		- (模板实例化)在调用时对参数进行替换, 对替换参数后的代码进行编译
	- 虽然它和函数重载类似都可以根据参数确定将要调用的函数版本, 但是函数模板只会生成将要用到的函数版本, 而函数模板无论是否调用其代码都会生成.
- 覆盖: 是指派生类中重新定义了基类中的`virtual`函数
- **隐藏**：是指派生类的函数屏蔽了与其同名的基类函数，只要函数名相同，基类函数都会被隐藏. 不管参数列表是否相同。

***

## 35、用C 语言实现C++的继承
- 关键点:
	- 使用函数指针保存函数
	- 将基类放在结构题的头部, 这样强转的就不会出错了
	```cpp
	#include <iostream>
	using namespace std;
	//C++中的继承与多态
	struct A{
		virtual void fun() 	{//C++中的多态:通过虚函数实现
			cout<<"A:fun()"<<endl;
		}
		int a;
	};
	struct B:public A {//C++中的继承:B 类公有继承A 类
		virtual void fun() { //C++中的多态:通过虚函数实现（子类的关键字virtual 可加可不加）
			cout<<"B:fun()"<<endl;
		}
		int b;
	};
	
	//C 语言模拟C++的继承与多态
	typedef void (*FUN)(); //定义一个函数指针来实现对成员函数的继承
	struct _A { //父类
		FUN _fun; //由于C 语言中结构体不能包含函数，故只能用函数指针在外面实现
		int _a;
	};
	struct _B { //子类
		_A _a_; //在子类中定义一个基类的对象即可实现对父类的继承
		int _b;
	};
	void _fA() { //父类的同名函数
		printf("_A:_fun()\n");
	}
	void _fB() { //子类的同名函数
		printf("_B:_fun()\n");
	}
	void Test()
	{
		//测试C++中的继承与多态
		A a; //定义一个父类对象a
		B b; //定义一个子类对象b
		A* p1 = &a; //定义一个父类指针指向父类的对象
		p1->fun(); //调用父类的同名函数
		p1 = &b; //让父类指针指向子类的对象
		p1->fun(); //调用子类的同名函数
		//C 语言模拟继承与多态的测试
		_A _a; //定义一个父类对象_a
		_B _b; //定义一个子类对象_b
		_a._fun = _fA; //父类的对象调用父类的同名函数
		_b._a_._fun = _fB; //子类的对象调用子类的同名函数
		_A* p2 = &_a; //定义一个父类指针指向父类的对象
		p2->_fun(); //调用父类的同名函数
		p2 = (_A*)&_b; //让父类指针指向子类的对象,由于类型不匹配所以要进行强转
		p2->_fun(); //调用子类的同名函数
	}
	```

## 36、继承机制中对象之间如何转换？指针和引用之间如何转换？
- 派生类的对象可以当做基类对象使用， 例如赋值或则初始化等
- 派生类对象的地址可以赋给指向基类的指针。 在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员。

- 向上类型转换(派生类转基类, 总是安全的)
	- 将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，**向上类型转换会自动进行**，而且向上类型转换是安全的。
- 向下类型转换(基类转派生类, 不安全)
	- 将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。
	- `RTTI`技术，用dynamic_cast进行向下类型转换, 只有存在虚函数的类才能使用`RTTI`

***
- 参考: 
	- [浅谈C++类型转换的安全性 - freshman94的博客 - CSDN博客](https://blog.csdn.net/qq_22660775/article/details/88715548)
	- [继承的赋值兼容规则](https://blog.csdn.net/vjhghjghj/article/details/90677092#%C2%A0%E7%BB%A7%E6%89%BF%E7%9A%84%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99)update 

***

## 37、组合与继承优缺点？
- 继承: 继承是Is a 的关系，比如说Student 继承Person,则说明Student is a Person。
- 继承的优点: 是子类可以重写父类的方法来方便地实现对父类的扩展。
- 继承的缺点有以下几点：
	- ①：父类的**内部细节**对子类是**可见**的。(可以自己调用父类的方法)
	- ②：子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。
	- ③：如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种高耦合，违背了面向对象思想。

***
- 组合(嵌入式对象): 组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。
- 组合的优点：
	- ①：当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的**内部细节**对当前对象时**不可见**的。(必须通过嵌入式对象调用嵌入式对象的方法)
	- ②：当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。
	- ③：当前对象可以在运行时动态的绑定所包含的对象。可以通过set 方法给所包含对象赋值。
- 组合的缺点：
	- ①：容易产生过多的对象。
	- ②：为了能组合多个对象，必须仔细对接口进行定义。

***
- 参考: [继承的优点和缺点](https://blog.csdn.net/u013675978/article/details/82628710)

***

## 38、左值右值
- 参考: [什么是右值引用，跟左值又有什么区别？](https://blog.csdn.net/zzxiaozhao/article/details/102943714#_45)

## 39、移动构造函数
- 右值的概念: 将亡值, 不具名变量
- 右值引用
	- 概念: 其本身是一个左值, 但是它绑定了一个右值, 此右值的生命周期将和此右值引用一致.
	- 优点:
		- 转移语意
		- 精确语意传递(参数列表分别为**左值引用**和**右值引用**形成参数重载)
- 移动构造函数: 
	- 概念: 当我们使用一个即将消亡的对象A初始化对象B时, 使用移动语意可以避免额外的无意义的复制构造操作, 也避免了释放内存, 新分配内存的开销.  
	- 实现: 
		- 移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。
		- 也就是说，只用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。
		- **作为参数的右值将不会再调用析构函数。**
		- `move`语句，就是将一个左值变成一个将亡值。
	- 优点
		- 避免了无畏的对下销毁和构造的开销
		- 当该类对象申请了堆内存, 并在析构函数中进行释放时, 使用拷贝构造函数可能会存产生也野指针, 而使用移动构造可以避免野指针的产生.

## 40、C 语言的编译链接过程？
- 源代码－－>预处理－－>编译－－>优化－－>汇编－－>链接-->可执行文件
- 参考: [源码到可执行文件的过程](https://blog.csdn.net/zzxiaozhao/article/details/102990773#_1128)

## 41、`vector`与`list`的区别与应用？怎么找某`vector`或者`list`的倒数第二个元素
- `vector`
	- `vector`和数组类似，拥有一段连续的内存空间，并且起始地址不变。
	- 因此能高效的进行随机存取，时间复杂度为`o(1)`;
	- 连续存储结构：
		- `vector`是可以实现动态增长的对象数组，支持对数组高效率的访问和在数组尾端的删除和插入操作，在中间和头部删除和插入相对不易，需要挪动大量的数据。
		- 它与数组最大的区别就是`vector`不需程序员自己去考虑容量问题，库里面本身已经实现了容量的动态增长，而数组需要程序员手动写入扩容函数进形扩容。
		
***
		- 随机访问
		- 高效的尾部操作(增/删)
		- 不那么高效的非尾部操作(增/删), 后面的迭代器会失效
		- 动态扩容, 迁移, 迭代器全部失效
- `list`
	- `list`是由双向链表实现的，因此内存空间是不连续的。
	- 非连续存储结构：
		- `list `是一个双链表结构，支持对链表的双向遍历。
		- 每个节点包括三个信息：元素本身，指向前一个元素的节点`(prev)`和指向下一个元素的节点`(next)`。
		- 因此`list `可以高效率的对数据元素任意位置进行访问和插入删除等操作。由于涉及对额外指针的维护，所以开销比较大。
		
***
		- 高效的插入和删除, 后续迭代器不失效
		- 指针维护开销大
		- 不支持随机访问
- 区别：
	- `vector `的随机访问效率高，但在插入和删除时(不包括尾部)需要挪动数据，不易操作。
	- `list `的访问要遍历整个链表，它的随机访问效率低。
	- 但对数据的插入和删除操作等都比较方便，改变指针的指向即可。
	- `list `是单向的，`vector `是双向的。`vector `中的迭代器在使用后就失效了，而`list `的迭代器在使用之后还可以继续使用。

- `int mySize = vec.size()`;`vec.at(mySize -2);`
- `list`不提供随机访问，所以不能用下标直接访问到某个位置的元素，要访问`list`里的元素只能遍历，
- 不过你要是只需要访问`list `的最后`N `个元素的话，可以用**反向迭代器**来遍历：

## 42、`STL vector`的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？
- vector相关函数:
	- `size / capacity`: 已用空间 / 总空间
	- `resize / reserve`: 改变容器的元素数目 / 概念容器的空间大小
	- `push_back / pop_back`: 尾插 / 尾减
	- `insert / erase`: 任意位置插入 / 任意位置删除
- 迭代器失效问题:
	- 在`capacity`内`insert`和`erase`都会导致在后续元素发生移动, 进而迭代器失效或则改变
	- 如果`insert`或则`push_back`导致空间不足, 则会发生整体的移动操作, 所有迭代器都将失效.
- 两倍扩容问题:
	- 为什么呈倍数扩容(时间复杂度更优)
		- 对于`n`次插入操作, 采用成倍方式扩容可以保证时间复杂度`O(n)`, 而指定大小扩容的时间复杂度为`O(n^2)`
	- 为什么是`1.5`倍扩容(空间可重用)
		- 当`k == 2`时:
			- 第n次扩容的时候需要分配的内存是：`an = a1*q^(n-1) = 4*2^(n-1)`
			- 而前n-1项的内存和为：`Sn = a1*(1-q^(n-1))/(1-q) = 4*(1-2^(n-1)) /(1-2) = 4*2^(n-1)-4`
			- `差值 = an - Sn = 4 > 0`
			- 所以第`n`次扩容需要的空间恰好比前`n-1`扩容要求的空间总和要大，那么即使在前`n-1`次分配空间都是连续排列的最好情况下，也无法实现之前的内存空间重用
		- 当`k = 1.5`时:
			- 第`n`次扩容的时候需要分配的内存是：`an = a1*q^(n-1) = 4*1.5^(n-1)`
			- 而前`n-1`项的内存和为：`Sn = a1*(1-q^(n-1))/(1-q) = 4*(1-1.5^(n-1)) /(1-1.5) = 8*1.5^(n-1)-8`
			- `差值 = an - Sn = 8 - 4*1.5^(n-1)`
			- 当`n`增长到一定的数值后，差值就会变为小于`0`，那么如果前`n-1`次分配的空间都是连续的情况下, 就可以实现内存空间复用
- 释放空间:
	- 使用`swap`: `vector<int>().swap(a);`

***
- 参考: 
	- [STL中vector 扩容为什么要以1.5倍或者2倍扩容？ - Bryant_xw Is Growing~~ - CSDN博客](https://blog.csdn.net/bryant_xw/article/details/89524910)
	- [C++ STL中vector内存用尽后，为啥每次是两倍的增长，而不是3倍或其他数值？ - 知乎](https://www.zhihu.com/question/36538542/answer/67929747)

***

## 43、容器内部删除一个元素
- 顺序容器
	- `erase 迭代器`不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(`list除外`)，所以不能使用`erase(it++)`的方式，但是`erase`的返回值是下一个有效迭代器；
	- `it = c.erase(it);`
- 关联容器
	- `erase 迭代器`只使被删除元素的迭代器失效, 其他迭代器不失效，但是返回值是`void`，所以要采用`erase(it++)`的方式删除迭代器；
	- `c.erase(it++)`

## 44、`STL` 迭代器如何实现
- 迭代器`Iterator`
	- (总结)`Iterator`使用聚合对象, 使得我们在不知道对象内部表示的情况下, 按照一定顺序访问聚合对象的各个元素.
	- `Iterator`模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。
	- 由于`Iterator`模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如`STL`的`list`、`vector`、`stack`等容器类及`ostream_iterator`等扩展`iterator`。
- 迭代器的基本思想:
	- 迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，`->`、`*`、`++`、`--`等。
	- 迭代器封装了指针，是一个“可遍历`STL( Standard Template Library)`容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升`(lift)`，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的`++`，`--`等操作。
	- 迭代器返回的是对象引用而不是对象的值。
- 迭代器产生原因
	- `Iterator`类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构就可以实现集合的遍历,是算法和容器之间的桥梁.

- 最常用的迭代器的相应型别有五种：`value type`、`difference type`、`pointer`、`reference`、`iterator catagoly`;

## 45、`set `与`hash_set `的区别
- `set `底层是以`RB-Tree `实现，`hash_set `底层是以`hash_table `实现的；
- `RB-Tree `有自动排序功能，而`hash_table `不具有自动排序功能；
- `set `和`hash_set `元素的键值就是实值；
- `hash_table `有一些无法处理的型别；(例如字符串无法对`hashtable`的大小进行取模)

## 46、`hashmap `与`map `的区别
- 底层实现不同；
- `map`具有自动排序的功能，`hash_map`不具有自动排序的功能；
- `hashtable`有一些无法处理的型别；(例如字符串无法对`hashtable`的大小进行取模)

## 47、`map`、`set `是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？
- `map`和`set`都是`STL`中的关联容器，其底层实现都是红黑树(`RB-Tree`)。由于 `map` 和`set`所开放的各种操作接口，`RB-tree` 也都提供了，所以几乎所有的`map`和`set`的操作行为，都只是转调`RB-tree`的操作行为。
- `map`中的元素是`key-value(关键字—值)对`：关键字起到索引的作用，值则表示与索引相关联的数据， 红黑树的每个节点包括`key`和`value`；
- `set`只是关键字的简单集合，它的每个元素只包含一个`关键字`， 红黑树每个节点只包括`key`。
- 红黑树的插入删除都可以在`O(logn)`时间内完成, 性能优越

## 48、如何在共享内存上使用STL标准库？
- 为什么要在共享内存中使用模板容器？
	- 共享内存可以在多进程间共享，到达进程间通信的方式。
	- 共享内存可以在进程的生命周期以外仍然存在。这就可以保证在短暂停止服务(服务进程`coredump`，更新变更)后，服务进程仍然可以继续使用这些共享内存的数据。
	- 如果这些优势在加上`C++`容器模板使用方便，开发快速的优势，无疑是双剑合璧，成为服务器开发的利刃。

***
**...........太难了..........**
- 参考: [C++容器模板在共享内存中的使用](https://blog.csdn.net/fullsail/article/details/8540078)

***

## 49、`map`插入方式有几种？
- 下表运算符插入`[]`
- `insert`插入`pair`

## 50、STL 中`unordered_map`和`map`的区别，`unordered_map`如何解决冲突以及扩容
- `unordered_map `和`map`都是键值对不可重复的关联容器, 
- 区别:
	- `map`的底层实现为红黑树, 会根据键值进行排序, 所以键值需要定义小于操作`(operator<)`
	- `unordered_map`底层实现为`hash_table`, 不会根据键值进行排序, 但是需要键值提供等于操作`(operator ==)`, 以防止重复键值

- 哈希表解决冲突常见办法:
	- 开放定址法: 线性探测, 二次探测, 二次哈希
	- **(STL使用):** 拉链法: 使用单链表来保存具有相同哈希值得集合

- 哈希表扩容
	- 什么时候扩容: 哈希表键值发生碰撞的概率, 随着负载因子(负载/容量)的增加而增加, 所以当负载因子大于阈值(0.75)的时候就需要扩容了.
	- 怎么扩容`(resize)`: 通过增加桶的数量(两倍扩张)以达到扩容的目的, 然后将原来的所有键值`rehash`到新的哈希表中, 增大哈希表并不会影响哈希表的插入删除时间,  那是`rehash`需要的时间复杂度为`n`, 所以对实时性非常严格的情况下不要使用

***
- 参考: 	
	- [数据结构——哈希表(散列表)](https://blog.csdn.net/chenhanzhun/article/details/38091431)
	- [散列表(哈希表)(散列函数构造、处理冲突、查找)](https://blog.csdn.net/qq_22238021/article/details/78258605)
	- [C++ STL hash表用法](https://www.cnblogs.com/downey-blog/p/10471875.html)
	- [hashtable详解](https://www.cnblogs.com/yyxt/p/4985894.html)
	- 扩容:
		- [Hash table详解](http://zheming.wang/blog/2014/06/17/05E21D24-A791-4D97-993D-98B7E6C88BC2/)
		- [HASH TABLE::DYNAMIC RESIZING (Java, C++)](http://www.algolist.net/Data_structures/Hash_table/Dynamic_resizing)
	 	- [对 c++ unordered_map 源码的解析 | ZRJ](https://zrj.me/archives/1248)

***

## 51、`vector`越界访问下标，`map`越界访问下标？`vector`删除元素时会不会释放空间？
- `vector `通过下标访问时不会做边界检查，即便下标越界。
	- 也就是说，下标与`first `迭代器相加的结果超过了`finish `迭代器的位置，程序也不会报错，而是返回这个地址中存储的值。
	- 如果想在访问`vector `中的元素时首先进行边界检查，可以使用`vector `中的`at `函数。
	- 通过使用`at `函数不但可以通过下标访问`vector `中的元素，而且在`at `函数内部会对下标进行边界检查。
	
	***
	- **我去是真的**: [访问vector元素时的越界问题](https://blog.csdn.net/zrh_CSDN/article/details/80959258)
	
	***
- `map`通过校表访问会将不存在的`key`插入到`map`中
	- `map `的下标运算符`[]`的作用是：将`key `作为下标去执行查找，并返回相应的值；如果不存在这个`key`，就将一个具有该`key `和`value `的某人值插入这个`map`。

- `erase()`函数，只能删除内容，不能改变容量大小;` erase `成员函数，它删除了`itVect`迭代器指向的元素，并且返回要被删除的`itVect `之后的迭代器，迭代器相当于一个智能指针;`clear()`函数，只能清空内容，不能改变容量大小;

	***
	- 如果要想在删除内容的同时释放内存，那么你可以选择`deque`容器。(`deque`也不总是`erase`之后就会释放内存， 当内存块不在被使用时会释放)
	- 参考： [STL容器删除元素时内存释放情况](https://blog.csdn.net/weixin_30247159/article/details/97269861)
	
	***

## 52、`map[]`与`find`的区别？
1) map 的下标运算符[]的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项**插入**这个map。
2) map 的find 函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器。

## 53、STL 中`list`, `queue`之间的区别
- `vector`: 连续空间存储, 支持随机访问, 高效尾部操作(增/删), 动态空间分配, 迭代器易失效
- `list`: 双向链表, 不支持随机访问(可以反向迭代), 任意位置操作(增/删)高效, 插入时分配空间, 迭代器不易失效
- `deque`: 双向开口的分段连续线性空间，可以在头尾端进行元素的插入和删除, 允许于常数时间内对头端进行插入或删除元素；可以增加一段新的空间, 不过迭代器设置复杂. 
- `queue`: 先进先出队列, 默认基于`deque`容器, 可以对两端进行操作，但是只能在队列头部进行移除元素，只能在队列尾部新增元素，可以访问队列尾部和头部的元素，但是不能遍历容器

***
- `deque`和`vector`的差异
	- `deque`允许于常数时间内对头端进行插入或删除元素；
	- `deque`没有空间包括, 当空间不足时, `deque`可以增加一段新的空间, 而不用进行整体迁移
	- `vector`的迭代器是对指针的封装, `deque`的迭代器相对复杂
- `list`和`vector`的差异
	- `vector`空间是预先分配的, `list`是插入时分配的
	- `vector`是连续数组, 增删操作都可能会造成内存迁移, 后续迭代器失效, `list`是双向链表, 增删操作都可以在常数时间内完成, 迭代器不会失效

***
- 参考: 
	- [STL源码剖析——序列容器之deque](https://blog.csdn.net/chenhanzhun/article/details/39430973)
	- [C++ list，STL list(双向链表)详解](http://c.biancheng.net/view/351.html)
	- [STL源码剖析——序列容器之deque](https://blog.csdn.net/chenhanzhun/article/details/39430973)

***

## 54、STL 中的allocator,deallocator
- 参考: [C++ STL 的内存优化](https://zhaostu4.github.io/2019/11/28/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB-%E7%B1%BB%E5%92%8C%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/#c-stl-%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96)

## 55、STL 中hash_map 扩容发生什么？
1) `hash table`表格内的元素称为桶`(bucket)`,而由桶所链接的元素称为节点`(node)`,其中存入桶元素的容器为`STL`本身很重要的一种序列式容器——`vector `容器。之所以选择`vector `为存放桶元素的基础容器，主要是因为`vector `容器本身具有动态扩容能力，
无需人工干预。

2) 向前操作：首先尝试从目前所指的节点出发，前进一个位置(节点)，由于节点被安置于`list `内，所以利用节点的`next `指针即可轻易完成前进操作，如果目前正巧是`list `的尾端，就跳至下一个`bucket `身上，那正是指向下一个`list `的头部节点。

***
- `hash table`表格内的元素称为桶`(bucket)`,而由桶所链接的元素称为节点`(node)`, 由线性表来储存所有的桶, 其底层实现为`vector`, 因为它支持随机访问, 和动态扩容
- 哈表表键值发生碰撞的概率和负载因子正相关, 当负载因子过大, 哈希表的性能显著降低, 一般负载因子大于阈值(0.75)则对哈希表进行扩容, 然后通过rehash对所有节点进行重映射, 注意扩容并不会增加哈希表插入删除的复杂度, 但是rehash本身的的时间复杂度为n, 所以对高时效性的需求下, 要注意.
- 参考: 
	- [对 c++ unordered_map 源码的解析 | ZRJ](https://zrj.me/archives/1248)
 	- [Hash table详解](http://zheming.wang/blog/2014/06/17/05E21D24-A791-4D97-993D-98B7E6C88BC2/)
	- [HASH TABLE::DYNAMIC RESIZING (Java, C++)](http://www.algolist.net/Data_structures/Hash_table/Dynamic_resizing)
	- [对 c++ unordered_map 源码的解析 | ZRJ](https://zrj.me/archives/1248)

***

## 56、map 如何创建？
- `vector `底层数据结构为数组，支持快速随机访问
- `list `底层数据结构为双向链表，支持快速增删
- `deque `底层数据结构为一个中央控制器和多个缓冲区，详细见`STL `源码剖析`P146`，支持首尾(中间不能)快速增删，也支持随机访问,` deque `是一个双端队列`(double-ended queue)`，也是在堆中保存内容的.它的保存形式
如下:`[堆1] --> [堆2] -->[堆3] --> ...`, 每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list 和vector 的结合品.
- `stack `底层一般用`list `或`deque `实现，封闭头部即可，不用`vector `的原因应该是容量大小有限制，扩容耗时
- `queue `底层一般用`list `或`deque `实现，封闭头部即可，不用`vector `的原因应该是容量大小有限制，扩容耗时`(stack `和`queue `其实是适配器,而不叫容器，因为是对容器的再封装)
- `priority_queue `的底层数据结构一般为`vector `为底层容器，堆`heap `为处理规则来管理底层容器实现
- `set `底层数据结构为红黑树，有序，不重复
- `multiset `底层数据结构为红黑树，有序，可重复
- `map `底层数据结构为红黑树，有序，不重复
- `multimap `底层数据结构为红黑树，有序，可重复
- `hash_set `底层数据结构为`hash `表，无序，不重复
- `hash_multiset `底层数据结构为`hash `表，无序，可重复
- `hash_map `底层数据结构为`hash `表，无序，不重复
- `hash_multimap `底层数据结构为`hash `表，无序，可重复

***
- 红黑树的性质：
	- 每个节点或是红色的，或是黑色的。
	- 根节点是黑色的。
	- 每个叶节点`(NULL)`是黑色的。
	- 如果一个节点是红色的，则它的两个孩子节点都是黑色的。
	- 对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。

- [数据结构——红黑树(RB-Tree)](https://blog.csdn.net/chenhanzhun/article/details/38405041)

***



## 57、vector 的增加删除都是怎么做的？为什么是1.5 倍？
- 参考: [42、STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？](https://zhaostu4.github.io/2019/11/28/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB-C++%E5%9F%BA%E7%A1%80%E5%86%8D%E6%8E%A2/#42stl-vector%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%A0%E9%99%A4%E5%85%B6%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%A4%E5%80%8D%E6%89%A9%E5%AE%B9%E9%87%8A%E6%94%BE%E7%A9%BA%E9%97%B4)

***
1) 新增元素：vector 通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；
2) 对vector 的任何操作，一旦引起空间重新配置，指向原vector 的所有迭代器就都失效了；
3) 初始时刻vector 的capacity 为0，塞入第一个元素后capacity 增加为1；
4) 不同的编译器实现的扩容方式不一样，VS2015 中以1.5 倍扩容，GCC 以2 倍扩容。对比可以发现采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。

	1) 考虑可能产生的堆空间浪费，成倍增长倍数不能太大，使用较为广泛的扩容方式有两种，以2 二倍的方式扩容，或者以1.5 倍的方式扩容。
	2) 以2 倍的方式扩容，导致下一次申请的内存必然大于之前分配内存的总和，导致之前分配的内存不能再被使用，所以最好倍增长因子设置为(1,2)之间：
3) 向量容器vector 的成员函数pop_back()可以删除最后一个元素.
4) 而函数erase()可以删除由一个iterator 指出的元素，也可以删除一个指定范围的元素。
5) 还可以采用通用算法remove()来删除vector 容器中的元素.
6) 不同的是：采用remove 一般情况下不会改变容器的大小，而pop_back()与erase()

## 58、函数指针？
- 什么是函数指针?
	- 函数指针本质是一个指针, 它指向的是函数的入口地址, 它的类型是由函数的参数列表和返回值共同确定.
- 函数指针的声明方法
	- `int (*pf)(const int&, const int&); (1)`
	- `pf`是一个返回类型为int, 参数为两个const int&的函数。**注意*pf 两边的括号是必须的**
		- 否则上面的定义就变成了：
		- `int *pf(const int&, const int&); // 这声明了一个函数pf, 其返回类型为int *, 带有两个const int&参数. `
- 为什么有函数指针
	- 可以通过函数指针进行函数调用
	- 而且函数指针本质是一个指针, 可以把它指向返回值类型和形参列表相同的不同函数
	- 另外还能将函数指针作为函数参数进行传递. 
	- 通过函数指针可以把函数的调用者与被调函数分开。
		- 调用者只需要确定被调函数是一个具有特定参数列表和特定返回值的函数,
		- 而不需要知道具体是哪个函数被调用.
- 两种方法赋值：
	- `指针名 = 函数名`
	- `指针名 = &函数名`

## 59、说说你对c 和c++的看法，c 和c++的区别？
- 面向过程 / 面向对象
- C中的函数编译时不会保留形参列表, 也不能重载; 而C++中的函数在编译时会保留形参列表, 有重载
- struct
	- C中: struct是自定义数据类型; 是变量的集合, 不能添加拥有成员函数; 没有访问权限控制的概念; 结构体名称不能作为参数类型使用, 必须在其前加上struct才能作为参数类型
	- C++中: struct是抽象数据类型, 是一个特殊的类, 可以有成员函数, 默认访问权限和继承权限都是public, 结构体名可以作为参数类型使用
- 动态管理内存的方法不一样: `malloc/free` 和 `new/delete`
- C语言没有引用的概念, 更没有左值引用, 右值引用
- C语言不允许只读数据(const修饰)用作下标定义数组, C++允许
- C语言的局部静态变量初始化发生于编译时，所以在函数中不能使用变量对局部静态变量进行初始化， 而C++因为增加了对象的概念，而对象需要调用构造函数进行初始化，所以编译器将局部静态变量的初始化推迟至该变量使用之前，也就是说可以使用变量来初始化局部静态变量。
- C++相比C，增加多许多类型安全的功能，比如强制类型转换
- C++支持范式编程，比如模板类、函数模板等

***
- `PS:`C/C++的全局变量默认连接属性都是`extern`的啊, 参考:[C语言：链接属性与存储类型](https://blog.csdn.net/sinat_27706697/article/details/47679329)
- 参考: 
	- [C语言：链接属性与存储类型](https://blog.csdn.net/sinat_27706697/article/details/47679329)
	- [为什么用C语言中const常量定义数组大小会报错？](https://blog.csdn.net/weixin_43054397/article/details/90417740)
	- [15、C 语言struct 和C++ struct 区别](https://blog.csdn.net/zzxiaozhao/article/details/103188945#15_C_struct_C_struct__228)

***

## 60、c/c++的内存分配，详细说一下栈、堆、静态存储区？
- 栈区`(stack)`— 由编译器自动分配释放，存放函数的参数值，局部变量的值等其操作方式类似于数据结构中的栈。
- 堆区`(heap) `— 一般由程序员分配释放，若程序员不释放，程序结束时可能由`OS`(操作系统)回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
- 全局区(静态区)`(static)`—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。
- 文字常量区—常量字符串就是放在这里的。程序结束后由系统释放。
- 程序代码区—存放函数体的二进制代码。

***
- 参考: [C++/C的内存分配](https://blog.csdn.net/zzxiaozhao/article/details/102943714#CC_116)

***

## 61、堆与栈的区别？
- 管理方式: 栈由编译器自动管理，无需我们手工控制；堆需要手动释放不再使用的堆空间`memory leak`。
- 空间大小: 
	- `32`位系统下, 堆内存可以达到`4G`(`3G`用户空间, `1G`内核空间). 
	- 栈空间是受限的, 默认大小为`1M`
- 碎片问题：
	- 对于堆来说，频繁的`new/delete` 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。
	- 对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，永远都不可能有一个内存块从栈中间弹出
- 生长方向：
	- 对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；
	- 对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。
- 分配方式：
	- 堆都是动态分配的，没有静态分配的堆。
	- 栈有2种分配方式：静态分配和动态分配。
		- 静态分配是编译器完成的，比如局部变量的分配。
		- 动态分配由[alloca]((https://baike.baidu.com/item/alloca/7621487?fr=aladdin))函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。
- 分配效率：
	- 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。
	- 堆则是`C/C++`函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法(具体的算法可以参考数据结构`/`操作系统)在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间(可能是由于内存碎片太多)，就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。

***
- 参考: 动态栈: [alloca_百度百科](https://baike.baidu.com/item/alloca/7621487?fr=aladdin)

## 62、野指针是什么？如何检测内存泄漏？
- 野指针：指向内存被释放的内存或者没有访问权限的内存的指针。
- “野指针”的成因主要有`3` 种：
	- **指针变量没有被初始化**。任何指针变量刚被创建时不会自动成为`NULL` 指针，它的缺省值是随机的。
	- **指针被`free`** 或者`delete` 之后，没有置为`NULL`；
	- **指针操作超越了变量的作用范围**。
- 如何避免野指针：
	- 对指针进行初始化, 或指向有效地址空间
	- 指针用完后释放内存，将指针赋`NULL`。
		- `char * p = NULL;`
		- `char * p = (char * )malloc(sizeof(char));`
		- `char num[ 30] = {0}; char *p = num;`
		- `delete(p); p = NULL;`

***
- 参考: [野指针和悬空指针](https://blog.csdn.net/bqxdrs012/article/details/78531357)

***

## 63、悬空指针和野指针有什么区别？
- 野指针：野指针指，访问一个已删除或访问受限的内存区域的指针，野指针不能判断是否为`NULL` 来避免。指针没有初始化，释放后没有置空，越界
- 悬空指针：一个指针的指向对象已被删除，那么就成了悬空指针。野指针是那些未初始化的指针。

***
- 参考: [野指针和悬空指针](https://blog.csdn.net/bqxdrs012/article/details/78531357)

***

## 64、内存泄漏
- 内存泄漏
	- 内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。
	- 内存泄漏并非指内存在物理上消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制, 导致此段内存不能被使用；
- 后果
	- 只发生一次小的内存泄漏可能不被注意，但泄漏大量内存的程序将会出现各种证照：**性能下降到内存逐渐用完，导致另一个程序失败；**
- 如何排除
	- 使用工具软件`BoundsChecker`，`BoundsChecker` 是一个运行时错误检测工具，它主要定位程序运行时期发生的各种错误；调试运行`DEBUG` 版程序，运用以下技术：`CRT(C run-time libraries)`、运行时函数调用堆栈、内存泄漏时提示的内存分配序号(集成开发环境`OUTPUT` 窗口)，综合分析内存泄漏的原因，排除内存泄漏。
	
- 解决方法
	- 智能指针。
- 检查、定位内存泄漏
	- 检查方法：在`main` 函数最后面一行，加上一句`_CrtDumpMemoryLeaks()`。调试程序，自然关闭程序让其退出，查看输出：输出这样的格式`{453}` `normal block at 0x02432CA8`,`868 bytes long`被`{}`包围的`453` 就是我们需要的内存泄漏定位值，`868 bytes long` 就是说这个地方有`868` 比特内存没有释放。
- 定位代码位置
	- 在`main` 函数第一行加上`_CrtSetBreakAlloc(453);`意思就是在申请`453` 这块内存的位置中断。然后调试程序，程序中断了，查看调用堆栈。加上头文件`#include <crtdbg.h>`

***
- 参考: 
	- [BoundsChecker使用](https://www.cnblogs.com/hrhguanli/p/3890171.html)
	- [(转)内存管理：_CrtDumpMemoryLeaks和_CrtSetBreakAlloc](https://www.cnblogs.com/jianqiang2010/archive/2010/12/02/1894327.html)
	- [Linux 内存泄露检查工具valgrind简析](https://blog.csdn.net/fanyun_01/article/details/65938998)

***

## 65、`new`和`malloc`的区别？
- 参考: [malloc和new的区别](https://blog.csdn.net/zzxiaozhao/article/details/102604626#mallocnew_430)

## 66、`delete p`;与`delete[]p`，`allocator`
- 动态数组管理`new`一个数组时，`[]`中必须是一个整数，但是不一定是常量整数，普通数组必须是一个常量整数；
- `new` 动态数组返回的并不是数组类型，而是一个元素类型的指针；
- `delete[]`时，数组中的元素按逆序的顺序进行销毁；
- `new` 在内存分配上面有一些局限性，`new` 的机制是将内存分配和对象构造组合在一起，同样的，`delete` 也是将对象析构和内存释放组合在一起的。
- `allocator` 将这两部分分开进行，`allocator` 申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化操作。

- 参考下一个问题:  [67、new和delete的实现原理，delete是如何知道释放内存的大小的额？](#67new%e5%92%8cdelete%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86delete%e6%98%af%e5%a6%82%e4%bd%95%e7%9f%a5%e9%81%93%e9%87%8a%e6%94%be%e5%86%85%e5%ad%98%e7%9a%84%e5%a4%a7%e5%b0%8f%e7%9a%84%e9%a2%9d)

## 67、`new`和`delete`的实现原理，`delete`是如何知道释放内存的大小的额？
- `new` 
	- 简单类型直接调用`operator new` 分配内存；
	- 对于复杂结构，先调用`operator new` 分配内存，然后在分配的内存上调用构造函数；
- `delete` 
	- 简单数据类型默认只是调用`free` 函数；
	- 复杂数据类型先调用析构函数再调用`operator delete`；

***
- `new[]`
	- 对于简单类型，`new[]`计算好大小后调用`operator new`；
	- 对于复杂数据结构
		- `AA* P = new AA[10];`
		- `new[]`先调用`operator new[]`分配内存, **分配内存时多分配四个字节用于存放元素个数.**, 返回地址为`p`
		- `p`的最开始的`4`个字节用于存放元素个数`n`, 然后从调用`n`次构造函数从`p-4`开始构造对象. 
		- 返回地址,也就是`P`, 即为`p-4`
- `delete[]`
	- 对于简单类型, 直接调用`free`进行释放(注意简单类型并没有利用`4`个字节保存元素个数, 由编译器自行优化)
	- 对于复制类型, 
		- 首先将指针前移`4`个字节获得元素个数`n`, 然后执行`n`次析构函数, 最后并释放掉内存. 
		- 因为指针指向的是`p-4`并不是内存的起始地址, 所以使用`delete`将无法完成释放, 因为`free`需要通过起始地址进行释放, 而`p-4`不是起始地址

***
- 参考: **一定要看看:**[深入理解C++ new/delete, new/delete  动态内存管理](https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdHAtMTZiL3AvODY4NDI5OC5odG1s?x-oss-process=image/format,png)	

***

## 68、`malloc`申请的存储空间能用`delete`释放吗
- 不能
	- `malloc /free` 主要为了兼容`C`，`new` 和`delete` 完全可以取代`malloc /free`的。
	- `malloc /free` 的操作对象都是必须明确大小的。而且不能用在动态类上。
	- `new` 和`delete` 会自动进行类型检查和大小，`malloc/free` 不能执行构造函数与析构函数，所以动态对象它是不行的。
	- 当然从理论上说使用`malloc` 申请的内存是可以通过`delete` 释放的。不过一般不这样写的。而且也不能保证每个`C++`的运行时都能正常。

## 69、malloc 与free 的实现原理？
- 参考: [malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？](https://zhaostu4.github.io/2019/11/28/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB-%E7%B1%BB%E5%92%8C%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/#malloc%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%A6%E5%A4%96brk%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8Cmmap%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88)

## 70、`malloc`、`realloc`、`calloc`、`alloca`的区别
- `malloc`函数: 在堆上申请空间, 随机初始化
	- `void* malloc(unsigned int num_size);`
	- `int *p = malloc(20*sizeof(int)); // 申请20 个int 类型的空间；`
-  `calloc`函数: 省去了人为空间计算；`malloc` 申请的空间的值是随机初始化的，`calloc` 申请的空间的值是初始化为`0` 的；
	- `void* calloc(size_t n,size_t size);`
	- `int *p = calloc(20, sizeof(int));`
-  `realloc`函数: 给动态分配的空间分配额外的空间，用于扩充容量。(可能会导致内存迁移)
	- `void realloc(void *p, size_t new_size);`
- `alloca`函数: `_alloca`是在**栈`(stack)`** 上申请空间,该变量离开其作用域之后被自动释放，无需手动调用释放函数。

## 71、`__stdcall` 和`__cdecl` 的区别？
- 在进行函数调用的过程中, 参数入栈肯定是调用者干的事, 但是参数出栈, 可以由调用者干, 也可以由被调函数干; 所以就需要对函数调用者和被调函数之间责任进行划分, `stdcall`和`cdecl`正是两种划分方式
- `cdecl`:
	- 是`c语言`的默认定义, 它规定了由调用者负责回复堆栈,
	- 好处: 参数数量可以是任意多个
	- 缺点: 代码存在冗余, 例如100次调用, 就会右100段回复堆栈的代码
- `stdcall`:
	- 一般用于跨语言的协作, 例如系统调用, 都会使用这种方式, 它规定堆栈的恢复由被调函数负责
	- 好处: 不会存在代码冗余, 100次低调用, 只有一段恢复堆栈的代码
	- 缺点: 只能允许规定的参数个数, 无法实现不定参数个数的调用

***
- `__stdcall`
	- `__stdcall` 是被函数恢复堆栈，只有在函数代码的结尾出现一次恢复堆栈的代码；
	- 在编译时就规定了参数个数，无法实现不定个数的参数调用；
- `__cdecl`
	- `__cdecl` 是调用者恢复堆栈，假设有`100` 个函数调用函数`a`，那么内存中就有`100` 端恢复堆栈的代码；
	- 可以不定参数个数；
	- 每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用`__stacall` 函数大。

***
- 参考: [__stdcall与__cdecl的区别](https://blog.csdn.net/myjisgreat/article/details/46477769)

***

## 72、使用智能指针管理内存资源，`RAII`
- `RAII` 全称是“`Resource Acquisition is Initialization`”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。
- 编译器保证, 栈对象在创建时自动调用构造函数，在超出作用域时自动调用析构函数。
- 所以`RAII`的思想下, 我们使用一个**栈对象**来管理资源, 将资源和对象的生命周期绑定。

- 智能指针`(std::shared_ptr` 和`std::unique_ptr)`即`RAII` 最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记`delete` 造成的内存泄漏。毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现`delete` 了。

## 73、手写实现智能指针类
- 参考: [说一下shared_ptr的实现](https://blog.csdn.net/zzxiaozhao/article/details/102604626#shared_ptr_257)

***
- 计数器: 取计数器, 
- 指针相关: 取原始指针
- 运算符重载: `++`, `--`, `->`, `+`, `-`, `*`, `=`
- 构造函数: 更新计数器
- 复制构造函数: 更新计数器
- 移动构造函数: 计数器不变
- 析构函数: 更新计数器, 按条件释放内存


- 智能指针是一个数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。
- 它会自动记录SmartPointer<T*>对象的引用计数，一旦T 类型对象的引用计数为0，就释放该对象。
- 除了指针对象外，我们还需要一个引用计数的指针设定对象的值，并将引用计数计为1，需要一个构造函数。
- 新增对象还需要一个构造函数，析构函数负责引用计数减少和释放内存。
- 通过覆写赋值运算符，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减1，新的引用计数加1
-  一个构造函数、拷贝构造函数、复制构造函数、析构函数、移走函数；

## 74、内存对齐？位域？
- 字节对齐的原因:
	- 更快: 如果数据未对齐自然边界, 则处理器需要两次寻址才能得到完整的数据
	- 通用: 部分硬件平面不支持访问未对齐的数据, 会抛出硬件异常
- 具体操作
	- 自定义对齐系数
		- 可以通过预编译命令`#pragma pack(n)`，`n=1`,`2`,`4`,`8`,`16`来改变这一系数，其中的`n`就是指定的“对齐系数”
	- 数据成员对齐规则: 
		- 结构`(struct)(`或联合`(union)`)的数据成员，第一个数据成员放在`offset`为`0`的地方，以后每个数据成员的对齐按照`#pragma pack`指定的数值和这个数据成员自身长度中，比较小的那个进行。
		- 结构体作为成员：
			- 如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。
	- 结构(或联合)的整体对齐规则：
		- 在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照`#pragma pack`指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。

- 位域
	- 有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。
	- `Ｃ语言`又提供了一种数据结构，称为“位域”或“位段”。
	- 所谓“位域”是把一个字节中的二进位划分为几 个不同的区域，并说明每个区域的位数。
	- 位段成员必须声明为`int`、`unsigned int`或`signed int`类型`(short char long)`。
	```c
	struct 位域结构名{ 
		位域列表 // 其中位域列表的形式为： 类型说明符 位域名：位域长度
	};  
	
	struct bs {     
		int a:8;
		int b:2;
		int c:6;
	};  
	```

***
- 参考: 
	- [操作系统中的结构体对齐，字节对齐](https://zhaostu4.github.io/2019/11/28/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90)
	- [位域的定义和使用](https://blog.csdn.net/sty124578/article/details/79456405)

***


## 75、结构体变量比较是否相等
- 重载了`==` 操作符
	```c
	struct foo {
		int a;
		int b;
		bool operator==(const foo& rhs) { // 操作运算符重载
			return( a == rhs.a) && (b == rhs.b);
		}
	};
	```
- 元素的话，一个个比；
- 指针直接比较，如果保存的是同一个实例地址，则(p1==p2)为真；

## 76、位运算
- 若一个数m 满足m = 2^n;那么k%m=k&(m-1)

***
- 判断奇偶
	- `a&1 == 0; // 偶数`
	- `a&1 == 1; // 奇数`
- `int`型变量循环左移`k`次，即`a=a<<k|a>>16-k`   `(设sizeof(int)=16)`
- `int`型变量`a`循环右移`k`次，即`a=a>>k|a<<16-k`   `(设sizeof(int)=16)`
- 整数的平均值
	- 对于两个整数`x`,`y`，如果用 `(x+y)/2` 求平均值，会产生溢出，因为 `x+y` 可能会大于`INT_MAX`，但是我们知道它们的平均值是肯定不会溢出的，我们用如下算法：
		```c
		int average(int x, int y) { //返回X,Y 的平均值
		     return (x&y)+((x^y)>>1);
		}
		```
- 判断一个整数是不是`2`的幂,对于一个数 `x >= 0`，判断他是不是`2`的幂
	```c
	boolean power2(int x){
	    return ((x&(x-1))==0)&&(x!=0)；
	}
	```
- 不用 `temp`交换两个整数
	```c
	void swap(int x, int y) {
	    x ^= y;
	    y ^= x;
	    x ^= y;
	}
	```
- 计算绝对值
	```c
	int abs(int x) {
		int y ;
		y = x >> 31 ;
		return (x^y)-y; //or: (x+y)^y
	}
	```
- 取模运算转化成位运算 (在不产生溢出的情况下)
	-  `a % (2^n)` 等价于`a & (2^n - 1)`
	- `a % 2` 等价于 `a & 1`
- 乘法运算转化成位运算 (在不产生溢出的情况下)
	- `a * (2^n)` 等价于 `a<< n`
- 除法运算转化成位运算 (在不产生溢出的情况下)
	- `a / (2^n)` 等价于 `a>> n`
	- 例: `12/8 == 12>>3`
- `if (x == a) x= b; else x= a;` 等价于 `x= a ^ b ^ x;`
- `x`的相反数表示为 `(~x+1)`

***
- 参考: [位运算总结 取模 取余](https://blog.csdn.net/black_ox/article/details/46411997)

***

## 77、为什么内存对齐
- 平台原因(移植原因)
	- 不是所有的硬件平台都能访问任意地址上的任意数据的；
	- 某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异
- 性能原因：
	- 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。
	- 原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

## 78、函数调用过程栈的变化，返回值和参数变量哪个先入栈？
- 调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中,即:从右向左依次把被调函数所需要的参数压入栈;
- 调用者函数使用`call` 指令调用被调函数,并把`call` 指令的下一条指令的地址当成返回地址压入栈中(这个压栈操作隐含在`call` 指令中);
- 在被调函数中,被调函数会先保存调用者函数的栈底地址`(push ebp)`,然后再保存调用者函数的栈顶地址,即:当前被调函数的栈底地址`(mov ebp,esp)`;
- 在被调函数中,从`ebp` 的位置处开始存放被调函数中的局部变量和临时变量,并且这些变量的地址按照定义时的顺序依次减小,即:这些变量的地址是按照栈的延伸方向排列的,先定义的变量先入栈,后定义的变量后入栈;

- 关于返回值: 
	- 如果 `返回值 <= 4字节`，则返回值通过寄存器`eax`带回。
	- 如果 `4< 返回值 <=8字节`，则返回值通过两个寄存器`eax`和`edx`带回。
	- 如果 `返回值 > 8字节`，则返回值通过产生的临时量带回。

***
- 参考: [C语言是怎么进行函数调用的?](https://zhaostu4.github.io/2019/11/28/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB-C++%E5%9F%BA%E7%A1%80/#c%E8%AF%AD%E8%A8%80%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84)
	- 参数逆序入栈
	- 返回地址入栈
	- 调用函数栈顶入栈
	- 被调用函数栈底入栈
	- 局部变量入栈

***

## 79、怎样判断两个浮点数是否相等？
- 对两个浮点数判断大小和是否相等不能直接用`==`来判断，会出错！
- 明明相等的两个数比较反而是不相等！
- 对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！
- 浮点数与`0` 的比较也应该注意。与浮点数的表示方式有关。
- `fabs(a-b)<=1.0e-9`

***
- 参考: [在程序中如何判断两个浮点数相等](https://www.cnblogs.com/liuyc/p/5933850.html)

***

## 80、宏定义一个取两个数中较大值的功能
- `#define MAX（x,y）((x>y?)x:y)`

## 81、`define`、`const`、`typedef`、`inline` 使用方法？
- `const` 与`#define` 的区别：`作用阶段不同`, `功能不同`, `define作用丰富`, `占用的空间不同`, `作用域`
	- 作用阶段不同: `const`在编译和链接阶段其作用, `define`在预编译阶段起作用
	- 功能不同: 
		- `const`是定义一个变量, 拥有数据类型, 会进行语义语法检查
		- `define`是宏定义, 简单的问题替代, 没有类型检查
	- `define`的作用更丰富: `define`可以配合条件预编译指令, 完成特殊的逻辑, 例如防止重复引用文件
	- 编译后占用的空间: `const`定义的是变量, 会储存在数据段空间, `define`是宏替换, 其值会储存在代码段
	- 作用域不同: `define`没有作用域限制, 而const定义的变量通常有作用域的限制(全局变量默认为extern)

- `#define` 和别名`typedef` 的区别
	1) 执行时间不同，`typedef` 在编译阶段有效，`typedef` 有类型检查的功能；#`define` 是宏定义，发生在预处理阶段，不进行类型检查；
	1) 功能差异，`typedef` 用来定义类型的别名，定义与平台无关的数据类型，与`struct`的结合使用等。#`define` 不只是可以为类型取别名，还可以定义常量、变量、编译开关等。
	1) 作用域不同，`#define` 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而`typedef` 有自己的作用域。

- `define` 与`inline` 的区别
	1) `#define` 是关键字，`inline` 是函数；
	1) 宏定义在预处理阶段进行文本替换，`inline` 函数在编译阶段进行替换；
	1) `inline` 函数有类型检查，相比宏定义比较安全；

## 82、`printf` 实现原理？
- 函数的调用过程: 参数逆序入栈, 返回地址入栈, 调用函数栈顶入栈, 设置被调函数栈底, 然后是被调函数的局部变量
- 在调用`printf`时, 首先获取第一个形参, 也就是字符指针, 然后解析所指向的字符串, 得到后续参数的个数和数据类型, 
- 然后计算出偏移量, 并从当前函数栈的栈底往上偏移得到
- `printf("%d,%d",a,b);`

## 83、`#include`的顺序以及尖叫括号和双引号的区别
- 路径不同, 参考: [include头文件的顺序以及双引号””和尖括号<>的区别？](https://blog.csdn.net/zzxiaozhao/article/details/102943714#include_77)

## 84、lambda 函数
- 包括五大部分: 捕获列表, 参数列表, 修饰符, 返回类型, 函数体
- 捕获列表: 对参数的捕获, 捕获方式为`值传递([=], [val])`和`引用([&], [&val])`
- 参数列表: 参数列表, 和不同函数一样, 如果没有可以省略
- 修饰符: 默认情况下lambda函数总是一个const函数，Mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略。
- 返回类型
- 函数体: 除了可以使用参数外, 还可以使用捕获的参数

***
- **参考:** [C++11中的可变参数模板、右值引用和lambda](https://zhaostu4.github.io/2019/11/28/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB-%E7%B1%BB%E5%92%8C%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/#c11%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8Clambda)

***

## 85、hello world 程序开始到打印到屏幕上的全过程?
- 应用程序
- 应用程序载入内存变成进程
- 进程获取系统的标准输出接口
- 系统为进程分配CPU
- 触发缺页中断
- 通过puts系统调用, 往标准输出接口上写字符串
- 操作系统将字符串发送到显示器驱动上
- 驱动判断该操作的合法性, 然后将该操作变成像素, 写入到显示器的储存映射区
- 硬件将该像素值改变转变成控制信号控制显示器显示

*** 
- 用户告诉操作系统执行`HelloWorld` 程序(通过键盘输入等)
- 操作系统：找到`helloworld` 程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址。
- 操作系统：创建一个新进程，将`HelloWorld` 可执行文件映射到该进程结构，表示由该进程执行`helloworld` 程序。
- 操作系统：为`helloworld` 程序设置`cpu` 上下文环境，并跳到程序开始处。
- 执行`helloworld` 程序的第一条指令，发生缺页异常
- 操作系统：分配一页物理内存，并将代码从磁盘读入内存，然后继续执行`helloworld` 程序
- `helloword` 程序执行`puts` 函数(系统调用)，在显示器上写一字符串
- 操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要写的字符串送给该进程
- 操作系统：控制设备的进程告诉设备的窗口系统，它要显示该字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区
- 视频硬件将像素转换成显示器可接收和一组控制数据信号
- 显示器解释信号，激发液晶屏
- `OK`，我们在屏幕上看到了`HelloWorld`

## 86、模板类和模板函数的区别是什么？
- 函数模板的实例化是由编译程序在处理函数调用时自动完成的
- 类模板的实例化必须由程序员在程序中显式地指定。即函数模板允许隐式调用和显式调用而类模板只能显示调用。在使用时类模板必须加<T>，而函数模板不必

## 87、为什么模板类一般都是放在一个h 文件中
- 编译器并不是把函数模板处理成能够处理**任意类型**的函数；编译器从**函数模板**通过**具体类型**==产生==不同的**函数**；
- 编译器会对函数模板进行两次编译：
	- 在声明的地方对模板代码本身进行编译，
	- 在调用的地方对参数替换后的代码进行编译。

- 如果模板函数不是定义在`.h`文件中
	- 编译器编译`.cpp`文件时并不知道另一个`.cpp`文件的存在, 也不会去查找(查找通常是链接阶段的事)
		- 在定义模板函数的`.cpp`文件中, 编译器对函数模板进行了第一次编译, 但是它并没有发现任何调用, 故而没有生产任何的函数实例
		- 在调用了模板函数的`.cpp`文件中, 编译器发现调用其他函数, 但是在此`.cpp`文件中并没有定义, 所以将此次调用处理为外部连接符号, 期望链接阶段由连接器给出被调函数的函数地址. 
	- 在链接阶段, 连接器找不到被调函数故而报不能识别的外部链接错误.

***
- 模板定义很特殊。
	- 由`template<…>`处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。
	- 在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。
	- 所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。

- 在分离式编译的环境下
	- 编译器编译某一个`.cpp` 文件时并不知道另一个`.cpp` 文件的存在，也不会去查找(当遇到未决符号时它会寄希望于连接器)。
	- 这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来，所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。
	- 然而当实现该模板的`.cpp` 文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的`.obj`中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。

***

## 88、C++中类成员的访问权限和继承权限问题。
- 参考: [C++中类成员的访问权限](https://zhaostu4.github.io/2019/11/28/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB-%E7%B1%BB%E5%92%8C%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/#c%E4%B8%AD%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90)

## 89、cout 和printf 有什么区别？
- `cout`有缓冲区, `printf`无缓冲区; 有缓冲区意味着
	- 操作系统可以待用户刷新缓冲区时输出, 或则缓冲区存满的时候输出, 
	- 如果操作系统空闲的话也会检查缓冲区是否有值, 如果有的话立即输出.
	- `endl`相当于输出回车后，再强迫缓冲输出。
	- `flush`立即强迫缓冲输出。
- `cout <<`是一个函数, 它对常见数据类型进行了重载, 所以能自动识别数据的类型并进行输出.

## 90、重载运算符？
- 引入运算符重载，是为了实现类的多态性；
- 只能重载已有的运算符；对于一个重载的运算符，其`优先级`和`结合律`与内置类型一致才可以；不能改变运算符操作数个数；
- `.`, `：`, `？`, `sizeof`, `typeid` `**`不能重载；
- 两种重载方式，成员运算符和非成员运算符，成员运算符比非成员运算符少一个参数；下标运算符、箭头运算符(重载的箭头运算符必须返回类的指针)、解引用运算符必须是成员运算符；
- 当重载的运算符是成员函数时，`this` 绑定到左侧运算符对象。成员运算符函数的参数数量比运算符对象的数量少一个；至少含有一个类类型的参数；
- 下标运算符必须是成员函数，下标运算符通常以所访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本；
- 当运算符既是一元运算符又是二元运算符(`+`，`-`，`*`，`&`)，从参数的个数推断到底定义的是哪种运算符；

## 91、函数重载函数匹配原则
- 首先进行名字查找, 确定候选函数
- 然后按照以下顺序进行匹配:
	- 精确匹配：参数匹配而不做转换，或者只是做微不足道的转换，如数组名到指针、函数名到指向函数的指针、`T`到`const T`；
	- 提升匹配：即整数提升(如`bool`到`int`、`char`到`int`、`short`到`int`、`float`到`double`)，；
	- 使用标准转换匹配：如`int`到`double`、`double`到`int`、`double`到`long double`、`Derived*`到`Base*`、`T*`到`void*`、`int`到`unsigned int`；
	- 使用用户自定义匹配；
	- 使用省略号匹配：类似于`printf`中省略号参数。

***
- 参考: [重载函数的调用匹配规则](https://www.cnblogs.com/bonelee/p/5951718.html)

***

## 92、定义和声明的区别
- 如果是指变量的声明和定义
	- 从编译原理上来说，
		- 变量声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。
		- 变量定义就是分配了内存。
- 如果是指函数的声明和定义
	- 函数声明：一般在头文件里，对编译器说：这里我有一个函数叫`function()` 让编译器知道这个函数的存在。
	- 函数定义：一般在源文件里，具体就是函数的实现过程写明函数体。

## 93、`C++`类型转换有四种
- `const_cast`: 
	- 用来移除`const`或`volatile` 属性。但需要特别注意的是`const_cast`不是用于去除变量的常量性，而是去除**指向常数对象的指针或引用**的常量性，其去除常量性的对象必须为**指针或引用**。
	- 如果对一个指向常量的指针,通过`const_cast`移除`const`属性, 然后进行修改, 编译通过,但是运行时会报段错误
- `static_cast`: 静态类型转换(不能移除`const/volatile`属性)是最常看到的类型转换, 几个功能. 
	- **内置类型之间的转换**, 精度耗损需要有程序员把握
	- **继承体系中的上下行转换**(上行:子类转父类,安全转换; 下行:父类转子类, 不安全转换)
	- **指针类型转换**: `空指针转换成目标类型的空指针`, `把任何类型转换成void 类型`。
- `dynamic_cast`: 主要用在继承体系中的安全向下转型
	- 它能安全地将指向基类的`指针/引用`转型为指向子类的`指针/引用`, 转型失败会返回`null`(转型对象为指针时)或抛出异常`bad_cast`(转型对象为引用时)。
	- `dynamic_cast` 会利用运行时的信息`(RTTI)`来进行动态类型检查，因此dynamic_cast 存在一定的效率损失。
	- 而且`dynamic_cast`进行动态类型检查时, 利用了虚表中的信息, 所以只能用于函数虚函数的类对象中. 
- `reinterpret_cast` 强制类型转换,**非常不安全**
	- 它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针(先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值)。


***
- 参考: 
	- [C++开发必看 四种强制类型转换的总结](https://www.cnblogs.com/lidabo/p/3651049.html)
	- [C++系列总结——volatile关键字](https://www.cnblogs.com/yizui/archive/2019/03/30/10628020.html)

***

## 94、全局变量和static 变量的区别
- static变量分为两个类型: 全局静态变量(在全局变量的类型前加上static)和局部静态变量(在局部变量的类型前加上static).
- 从储存形式看: 他们没有区别, 都储存于静态数据区
- 从作用域看: 
	- 全局变量默认具有extern属性, 它的作用域为整个项目, 可能和其他cpp文件中的全局变量发生命名冲突.
	- 全局静态变量,作用域受限, 它的作用域仅限于定义它的文件内有效, 不会和其他cpp文件中的全局变量发生命名冲突.
	- 局部静态变量, 作用域依旧不管, 当时当离开作用域时不会变量不会被释放, 其值保持不变只是被屏蔽了, 直到再次进入作用域, 其也只会被初始化一次.

## `static` 函数与普通函数有什么区别？
- `static` 函数与普通函数有什么区别？
	- `static` 函数与普通的函数作用域不同。
		- 普通函数默认为`extern`属性, 作用域为整个项目, 可能会和其他`cpp`文件中的函数发生命名冲突.
		- `static`修饰的函数, 作用域受限仅为定义的文件, 不会和其他`cpp`文件中的函数发生命名冲突.

## 95、静态成员与普通成员的区别
- 储存位置不同: 普通成员变量存储在栈或堆中，而静态成员变量存储在静态全局区；
- 声明周期不同:
	- 静态成员变量从类被加载开始到类被卸载，一直存在；
	- 普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束；
- 初始化位置: 普通成员变量在类中初始化；**静态成员变量在类外初始化**；
- 拥有则不同: 静态成员变量可以理解为是属于类的变量,可以通过类名进行访问, 为本类的所有对象所共享；普通成员变量是每个对象单独享用的, 只能通过对象进行访问；

## 96、说一下理解`ifdef` `endif`
- 从源文件到可执行程序的过程, 通常要经历: `预编译`, `编译`, `汇编`, `链接`等过程
- `ifdef`, `endif`为条件预编译指令, 生效于预编译阶段, 根据条件可以完成一些特殊的逻辑, **例如防止文件重复引用**
- `#ifdef`, `#else`,`#endif`为完整的逻辑, 分别表示, 如果定义了某个标识符, 则编译后续程序段, 否则编译另外一个程序段
- 因为预编译阶段处于编译链的第一阶段, 它可以直接影响应用程序的大小. 

## 97、隐式转换，如何消除隐式转换？
- 隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。很多时候用户可能都不知道进行了哪些转换, 
	- 例如: 
		- 类型提升: `(bool, int)`; `(short, int)`; `(float, double)`
		- 类型转换: `(int, float)`; `(int, double)`, `(Derived*, Base*)`
- 基本数据类型的转换, 通常发生于从小到大的变换, 以保证精度不丢失
- 对于用户自定义类型, 如果存在单参数构造函数, 或则除一个参数外其他参数都有默认参数的, 此时编译器可能完成由此参数类型到自定义类型的隐式变换, 消除方式为使用关键字`explicit`禁止隐式转换. 

## 98、虚函数的内存结构，那菱形继承的虚函数内存结构呢
- 如果一个类存在虚函数, 则会发生以下几个变化
	- 如果不存在构造函数, 则编译器一定会合成默认构造函数
	- 编译器会为类生成一个虚表(储存在静态区, 不占用对象内存), 并给该类的每个对象插入一个指向虚表的指针(通常此指针位于对象的起始位置), 虚函数表的每一项为函数的入口地址.
- 如果派生类的基类存在虚函数,则
	- 编译器会复制基类的虚表形成一个副本, 然后给该派生类对象插入一个指向该虚表副本的指针
	- 如果该派生类对基类的虚函数进行了重定义, 则会替换虚表副本中的对应函数入口地址
	- 如果该派生类新增了虚函数, 则对该虚表副本增加对应的项
- 如果存在菱形结构的继承关系, 则通常回使用虚继承的方式, 防止同一类中存在基类的多个副本
	- 虚表的继承方式和普通继承一样, 但是在
 	- 如果不存在构造函数, 则编译器一定会合成默认构造函数
	- 如果类`B`虚拟继承自类`A`, 则类`B`中存在一个虚基类表指针,指向一个虚基类表(储存在静态区, 不占用对象内存), 此虚基类表中存储中虚基类相对于当前类对象的偏移量.
	- 不同的编译器对虚基类表指针的处理方式不同, 例如`VS`编译器将虚基类表指针插入到对象中(会占用对象内存), 而`SUN/GCC`公式的编译器则是插入到虚函数表中(不占用对象内存)

***
- 参考: [给你一个类，里面有static，virtual，之类的，说一说这个类的内存分布](https://blog.csdn.net/zzxiaozhao/article/details/102990773#staticvirtual_731)

***

## 99、多继承的优缺点，作为一个开发者怎么看待多继承
- `C++`允许为一个派生类指定多个基类，这样的继承结构被称做多重继承。
- 优点: 对象可以调用多个基类中的接口；
- 缺点:
	- 如果基类重存在多个相同的基类或则方法, 则会出现二义性(解决方案是调用时加上全局限定符)
	- 容易存在菱形继承, 从而导致存在多个基类的副本(解决方案是使用虚拟继承)

***
- 个人觉得挺方便的, 虽然有缺点,但是也都用对应的解决方案

## 100、迭代器++it,it++哪个好，为什么
- `略`

## 101、C++如何处理多个异常的？
- `C++`中的错误情况：
	- **语法错误(编译错误)**：比如变量未定义、括号不匹配、关键字拼写错误等等编译器在编译时能发现的错误，这类错误可以及时被编译器发现，而且可以及时知道出错的位置及原因，方便改正。
	- **运行时错误**：比如数组下标越界、系统内存不足等等。这类错误不易被程序员发现，它能通过编译且能进入运行，但运行时会出错，导致程序崩溃。为了有效处理程序运行时错误，`C++`中引入异常处理机制来解决此问题。
- `C++`异常处理机制：
	- 异常处理基本思想：执行一个函数的过程中发现异常，可以不用在本函数内立即进行处理， 而是抛出该异常，让函数的调用者直接或间接处理这个问题。
	- `C++`异常处理机制由3 个模块组成：`try(检查)`、`throw(抛出)`、`catch(捕获)`
	- 首先是: 抛出异常的语句格式为：`throw 表达式`；
	- 如果`try`块中程序段发现了异常则抛出异常, 则依次尝试通过`catch`进行捕获, 如果捕获成功则调用相应的函数处理段, 如果捕获失败, 则条用terminal终止程序.
	```cpp
	try{
		// 可能抛出异常的语句；(检查)
	} catch(类型名[形参名]){ //捕获特定类型的异常
		//处理1；
	} catch(类型名[形参名]){//捕获特定类型的异常
		//处理2；
	} catch (…){ //捕获所有类型的异常
	}
	```
- `C++`标准的异常
	- `std::exception`: 所有标准 `C++` 异常的父类。
	- `std::logic_error`: 逻辑错误(无效的参数, 太长的`std::string`, 数组越界)
	- `std::runtime_error`: 运行时错误(数据溢出)
- 我们可以通过这些类派生出自己的错误类型,尤其是对`logic_error`进行重载

***
- 参考: [C++ 异常处理 | 菜鸟教程](https://www.runoob.com/cplusplus/cpp-exceptions-handling.html)

***

## 102、模板和实现可不可以不写在一个文件里面？为什么？
- 参考: [87、为什么模板类一般都是放在一个h 文件中](#87%e4%b8%ba%e4%bb%80%e4%b9%88%e6%a8%a1%e6%9d%bf%e7%b1%bb%e4%b8%80%e8%88%ac%e9%83%bd%e6%98%af%e6%94%be%e5%9c%a8%e4%b8%80%e4%b8%aah-%e6%96%87%e4%bb%b6%e4%b8%ad)

## 104、智能指针的作用；
- `C++11`中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露(忘记释放)，二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。
- 三个指针指针: `unique_ptr`、`shared_ptr` 、`weak_ptr`
- `unique_ptr`
	- 语意为**唯一**拥有所指向对象
	- 其只支持移动语义, 不允许拷贝语义, 不允许强制剥夺, 有条件支持赋值语义(等号右边为右值的时候). 
	- 当unique_ptr指针生命周期结束, 且没有被使用移动语义, 则会将所指向对象释放掉.
- `shared_ptr`
	- 语义为**共享**的拥有多指向的对象, 其支持拷贝语义, 支持移动语义, 支持赋值语义. 
	- `shared_ptr`内部存在一个计数器, 为指向该对象的所有`shared_ptr`所共享, 
	- 每减少一个`shared_ptr`则计数器减一, 没多一个则计数器加一
	- 当计数器为零时则释放所指向的对象.
- `weak_ptr`: 解决交叉引用问题, 房子内存泄漏. 

## 105、`auto_ptr`作用

***
- 已经被`unique_ptr`替代, 其允许强制剥夺所有权, 会存在野指针风险. 

***
1) `auto_ptr` 的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；抛出异常，将导致指针`p` 所指向的空间得不到释放而导致内存泄漏；
2) `auto_ptr` 构造时取得某个对象的控制权，在析构时释放该对象。我们实际上是创建一个`auto_ptr<Type>`类型的局部对象，该局部对象析构时，会将自身所拥有的指针空间释放，所以不会有内存泄漏；
3) `auto_ptr` 的构造函数是`explicit`，阻止了一般指针隐式转换为`auto_ptr` 的构造，所以不能直接将一般类型的指针赋值给`auto_ptr` 类型的对象，必须用`auto_ptr` 的构造函数创建对象；
4) 由于`auto_ptr` 对象析构时会删除它所拥有的指针，所以使用时避免多个auto_ptr对象管理同一个指针；
5) `Auto_ptr` 内部实现，析构函数中删除对象用的是`delete` 而不是`delete`[]，所以`auto_ptr` 不能管理数组；
6) `auto_ptr` 支持所拥有的指针类型之间的隐式类型转换。
7) 可以通过`*`和`->`运算符对`auto_ptr` 所有用的指针进行提领操作；
8) `T* get()`,获得`auto_ptr` 所拥有的指针；`T* release()`，释放`auto_ptr`的所有权，并将所有用的指针返回。

## 106、class、union、struct 的区别
- `struct`在`C`和`C++`中是不同的
	- `C`语言中: 
		- `struct`为自定义数据类型, 结构体名不能单独作为类型使用, 其结构名前必须加`struct` 才行
		- `struct`为变量的集合, 不能存定义函数(但是可以存在函数指针变量)
		- `struct`不存在访问权限控制的概念
	- `C++`中:
		- `struct`为抽象数据类型, 只一个特殊的`class`, 支持成员函数的定义, 可以继承和实现多态
		- 增加了访问权限控制的概念, 但是默认访问和继承权限为`public`
		- 结构体名字可以为直接做为类型使用
- `C++`中`struct`和`class`的区别
	- 默认的访问和继承权限不同
	- 注意`C++`中`struct`可以使用模板

- `union`
	- `C语言`中:
		- `union`是一种数据格式，能够存储不同的数据类型，但只能同时存储其中的一种类型。
		- `union`的数据成员是共享内存的, 以成员最大的做为结构体的大小
		- 每个数据成员在内存中的起始地址是相同的。
	- `C++`中: 
		- `union` 结构式一种特殊的类。 默认访问权限是`public`。
		- 能包含访问权限、成员变量、成员函数(可以包含构造函数和析构函数)。
		- 不能包含虚函数和静态数据变量。也不能被用作其他类的基类，它本身也不能从某个基类派生而来。
		- `union`成员是共享内存的，以`size` 最大的结构作为自己的大小。
		- 每个数据成员在内存中的起始地址是相同的。
	- 无论是`C/C++`, `union`的储存方式都是小端模式储存的

***
- 参考: 
	- [15、C 语言struct 和C++ struct 区别](https://blog.csdn.net/zzxiaozhao/article/details/103188945#15_C_struct_C_struct__228)
	- [C++中struct和class的区别](https://blog.csdn.net/zzxiaozhao/article/details/102943714#Cstructclass_35)
	- [C++的struct可以使用template](https://blog.csdn.net/weixin_30817749/article/details/98037298)

***

## 107、`动态联编`与`静态联编`
- 在`C++`中，**联编是指一个计算机程序的不同部分彼此关联的过程**。按照联编所进行的**阶段**不同，可以分为**静态联编**和**动态联编**；

- **静态联编**
	- 是指联编工作在编译阶段完成的，这种联编过程是在程序运行之前完成的，又称为早期联编。
	- 要实现静态联编，在编译阶段就必须确定程序中的操作调用(如函数调用)与执行该操作代码间的关系，确定这种关系称为束定，在编译时的束定称为静态束定。
	- **静态联编**对**成员函数**的选择是**基于指向对象的指针或者引用的类型**。
	- 其优点是**效率高**，但**灵活性差**。

- **动态联编**
	- 是指联编在程序运行时动态地进行，根据当时的情况来确定调用哪个同名函数，**实际上是在运行时虚函数的实现**。这种联编又称为晚期联编，或动态束定。
	- **动态联编**对**成员函数**的选择是**基于对象的类型**，针对不同的对象类型将做出不同的编译结果。
	- `C++`中一般情况下的联编是静态联编，但是当涉及到**多态性**和**虚函数**时应该使用动态联编。
	- 动态联编的优点是**灵活性强**，但**效率低**。
	- **动态联编规定，只能通过`指向基类的指针或基类对象的引用`来调用虚函数**，其格式为：
		- `指向基类的指针变量名` `->` `虚函数名(实参表);` 
		- `或基类对象的引用名` `.` `虚函数名(实参表)`

***
- 实现动态联编三个条件：
	- 必须把动态联编的行为定义为**类的虚函数**；
	- **类之间应满足子类型关系**，通常表现为一个类从另一个类公有派生而来；
	- 必须先**使用基类指针指向子类型的对象**，然后直接或间接使用**基类指针调用虚函数**；

***
- 参考: [c++动态联编与静态联编](https://blog.csdn.net/neiloid/article/details/6934129)

***

## 108、`动态编译`与`静态编译`
- `静态编译`
	- 静态编译，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去
	- 缺点: **编译慢**, **可执行程序大**
	- 优点: 使可执行文件在运行时**不需要依赖于动态链接库**；

- `动态编译`
	- 动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。
	- 优点: 
		- 一方面是**缩小**了执行文件本身的体积，
		- 另一方面是**加快了编译速度**，节省了系统资源。
	- 缺点:
		- 哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库；
		- 二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。

***
- 参考: [动态编译、静态编译区别(转)](https://blog.csdn.net/weixin_38907560/article/details/81478981)

***

## 109、`动态链接`和`静态链接`区别
- **静态链接**：
	1) 函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。
	1) **空间浪费**：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件在多个程序内都存在一个副本；
	1) **更新困难**：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。
	1) **运行速度快**：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。

- **动态链接**：
	1) 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。
	1) **共享库**：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多个副本，而是这多个程序在执行时共享同一份副本；
	1) **更新方便**：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。
	1) **性能损耗**：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。


***
- 区别
	- 使用静态链接生成的可执行文件可能会存在共享库的多个复本, 而使用动态链接库的可执行文件只有存在一份
	- 使用静态链接库的可执行程序不需要依赖动态链接库, 依赖关系简单; 而使用动态链接库的可执行程序需要引用动态链接库, 故而依赖关系复杂
	- **静态链接生成的静态链接库不能再包含其他的动态链接库或则静态库, 而动态链接库可以包括其他的动态库或则静态库.**

***
- 参考: [动态编译、静态编译区别(转)](https://blog.csdn.net/weixin_38907560/article/details/81478981)

***

## 110、在不使用额外空间的情况下，交换两个数？
- 算术
	```c
	x = x + y;
	y = x - y;
	x = x - y;
	```
- 异或
	```c
	// 原理 x ^= y ^= x; 能对int,char..
	x = x^y; 
	y = x^y;
	x = x^y;
	```

## 111、`strcpy` 和`memcpy` 的区别
- 复制的内容不同。`strcpy` 只能复制字符串，而`memcpy` 可以复制任意内容，例如字符数组、整型、结构体、类等。
- 复制的方法不同。`strcpy` 不需要指定长度，它遇到被复制字符的串结束符`\0`才结束，所以容易溢出。`memcpy` 则是根据其第`3` 个参数决定复制的长度。

## 112、执行`int main(int argc`, `char *argv`[])时的内存结构
- 参数的含义是程序在命令行下运行的时候，需要输入`argc` 个参数，每个参数是以`char`类型输入的，依次存在数组里面，数组是`argv[]`，所有的参数在指针`char *` 指向的内存中，数组的中元素的个数为`argc` 个，第一个参数为程序的名称。


***
- `main`函数是用户代码的入口函数, 其调用过程依旧是函数调用过程, 区别在于main函数的参数有固定的规范
	- main函数参数规范如下:
		- 第一个参数为: `int`型, 表示参数的个数
		- 第二个参数为: `char* 数组`, 每一个`char*`元素指向一个以字符串形式储存在内存中的参数的首地址, 其中第一个参数为程序的名字
- 函数调用过程如下:
	- 首先将参数以字符串的形式保存在内存中, 然后利用字符串起始字符指针组成char* 数组, 并计算参数的个数.
	- 然后将进行函数调用, 
		- 首先, 将参数逆序入栈, 也就是(参数指针数组, 参数个数)
		- 然后返回地址入栈
		- 然后调用则栈顶入栈
		- 将当前栈顶设置为被调函数栈底, 并将栈底入栈
		- 然后被调函数建立形参以及局部变量, 处理相应的逻辑

## 113、`volatile` 关键字的作用？
- `volatile` 关键字是一种类型修饰符，被它修饰的变量拥有三大特性: 易变性, 不可优化性, 顺序性
	- 易变性: 编译器对`valatile`的访问总是从内存中读取数据, 即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。
	- 不可优化性: `volatile`告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。
	- 顺序性: 保证`Volatile`变量间的顺序性，编译器不会进行乱序优化。**但是可能会被CPU优化**
- 声明时语法：`int volatile vInt`; 
- `volatile` 用在如下的几个地方：
	1) 中断服务程序中修改的供其它程序检测的变量需要加`volatile`；
	2) 多任务环境下各任务间共享的标志应该加`volatile`；
	3) 存储器映射的硬件寄存器通常也要加`volatile` 说明，因为每次对它的读写都可能由不同意义；


***
- 参考: [C/C++ Volatile关键词深度剖析](https://www.cnblogs.com/god-of-death/p/7852394.html)

***

## 114、讲讲大端小端，如何检测(三种方法)
大端模式：是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址端。
小端模式，是指数据的高字节保存在内存的高地址中，低位字节保存在在内存的低地址端。

- 直接读取存放在内存中的十六进制数值，取低位进行值判断(在GCC中测试,不可行!)
	```cpp
	int a = 0x12345678;
	int *c = &a;
	c[0] == 0x12 大端模式
	c[0] == 0x78 小段模式 
	```
- 用union来进行判断(union总是小端储存)
	```cpp
	union w{
		char ch;
		int i;
	};
	union w p;
	p.i = 1;
	bool flag = p.ch==1;
	```

## 115、查看内存的方法
- 首先打开vs 编译器，创建好项目，并且将代码写进去，这里就不贴代码了，你可以随便的写个做个测试;
- 调试的时候做好相应的断点，然后点击开始调试;
- 程序调试之后会在你设置断点的地方暂停，然后选择调试->窗口->内存，就打开了内存数据查看的窗口了。

## 116、空类会默认添加哪些东西？怎么写？
- 默认构造函数
- 析构函数
- 拷贝构造函数
- 赋值运算符`(operator=)`
- 两个取址运算符`(operator&)`(`const`和`非const`)
- **当然所有的这些函数都是需要才生成, 例如你都没使用过复制运算, 肯定不会生成的**

***
- 参考:[编译一个空类会默认生成哪些函数?](https://blog.csdn.net/bug07250432/article/details/10099453)

***

## 117、标准库是什么？
1) C++ 标准库可以分为两部分:
	- **标准函数库**: 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自`C语言`。
	- **面向对象类库**: 这个库是类及其相关函数的集合。
- 标准函数库: 输入`/`输出`I/O`、字符串和字符处理、数学、时间、日期和本地化、动态分配、其他、宽字符函数
- 面向对象类库: 标准的`C++` `I/O` 类、`String` 类、数值类、`STL` 容器类、`STL` 算法、`STL` 函数对象、`STL` 迭代器、`STL` 分配器、本地化库、异常处理类、杂项支持库

## 118、`const char*` 与`string` 之间的关系，传递参数问题？
- `string` 是`c++`标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用 `const char*`给`string` 类初始化
- 三者的转化关系如下所示：
	- `string` 转`const char*`
		```c
		string s = “abc”;
		const char* c_s = s.c_str();
		```
	- `const char*` 转`string`，直接赋值即可
		```c
		const char* c_s = “abc”;
		string s(c_s);
		```
	- `string` 转`char*`
		```c
		string s = “abc”;
		char* c;
		const int len = s.length();
		c = new char[len+1];
		strcpy(c,s.c_str());
		```
	- `char*` 转`string`
		```c
		char* c = “abc”;
		string s(c);
		```
	- `const char*` 转`char*`
		```c
		const char* cpc = “abc”;
		char* pc = new char[strlen(cpc)+1];
		strcpy(pc,cpc);
		```
	- `char*` 转`const char*`，直接赋值即可
		```c
		char* pc =
**** “abc”;
		const char* cpc = pc;
		```

## 119、`new`、`delete`、`operator new`、`operator delete`、`placement new`、`placement delete`
- `new operator`
	- `new operator` 完成了两件事情：用于**申请内存**和**初始化对象**。
	- 例如：`string* ps = new string("abc")`;
- `operator new`
	- `operator new` 类似于`C` 语言中的`malloc`，只是负责申请内存。
	- 例如：
		```c
		void* buffer = operator new(sizeof(string)); // 注意这里new 前要有个operator。
		```
-  `placement new`
	- 用于在给定的内存中初始化对象。
	- 例如：
		```c
		void* buffer = operator new(sizeof(string));
		buffer = new(buffer) string("abc");
		``` 
	- 调用了`placement new`，在`buffer` 所指向的内存中创建了一个`string` 类型的对象并且初始值为“`abc`”。


***
- 因此可以看出：
	- `new operator` 可以分解`operator new` 和`placement new` 两个动作，是`operator new` 和`placement new` 的结合。
- 与`new` 对应的`delete` 没有`placement delete` 语法
	- 它只有两种，分别是`delete operator` 和`operator delete`。
    - `delete operator` 和`new operator` 对应，完成**析构对象**和**释放内存**的操作。
    - 而`operator delete` 只是用于**内存的释放**，与`C语言`中的`free` 相似。

***

## 120、为什么拷贝构造函数必须传`引用`不能`传值`？
- 拷贝构造函数的作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例。
- 两种不同的参数传递方式：

- 值传递:
    - 对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)；对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)； 
    - 如`void foo(class_type obj_local){}`, 如果调用`foo(obj)`; 首先`class_type obj_local(obj)` ,这样就定义了局部变量`obj_local` 供函数内部使用
- 引用传递:
    - 无论对内置类型还是类类型，传递引用或指针最终都是传递的**地址值**！而地址总是指针类型(属于简单类型), 显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用(对于类类型).


***
- 拷贝构造函数使用值传递会产生无限递归调用，内存溢出。
- 拷贝构造函数用来初始化一个非引用类类型对象，如果用传值的方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归。

***

## 121、空类的大小是多少？为什么？
- `C++`空类的大小不为`0`，不同编译器设置不一样，`vs` 设置为`1`；
- `C++`标准指出，不允许一个对象(当然包括类对象)的大小为`0`，**因为不同的对象不能具有相同的地址**；
- 带有虚函数的`C++`类大小不为`1`，因为每一个对象会有一个`vptr` 指向虚函数表，具体大小根据指针大小确定；
- `C++`中要求对于类的每个实例都必须有独一无二的地址,那么**编译器自动为空类分配一个字节大小**，这样便保证了每个实例均有独一无二的内存地址。

## 122、你什么情况用指针当参数，什么时候用引用，为什么？
- 使用引用参数的主要原因有两个：
    - 程序员能**修改**调用函数中的数据对象
    - 通过传递引用而不是整个数据–对象，可以提高程序的**运行速度**
- 一般的原则：
    - 对于使用数据对象不做修改的函数：
        - 如果数据对象很`小(内置数据类型或者小型结构)`，则按**照值传递**；
        - 如果数据对象是`数组`，则使用指针 **(唯一的选择)**，并且指针声明为 **`const` 的指针**；
        - 如果数据对象是`较大的结构`，则使用 **`const` 指针或者引用**，已提高程序的效率。这样可以节省结构所需的时间和空间；
        - 如果数据对象是`类对象`，则使用 **`const` 引用**(传递类对象参数的标准方式是按照引用传递)；
    - 对于修改函数中数据的函数：
        - 如果数据是`内置数据类型`，则使用**指针**
        - 如果数据对象`是数组`，则只能使用**指针**
        - 如果数据对象是`结构`，则使用**引用或者指针**
        - 如果数据是`类对象`，则使用**引用**

## 123、大内存申请时候选用哪种？`C++`变量存在哪？变量的大小存在哪？符号表存在哪？
- 大内存申请时，采用堆申请空间，用`new` 申请， 当大于`128K`的时候会在映射区分配内存.
- 变量存储位置:
	- 全局变量
	- 静态变量
	- 局部变量
	- 堆对象:大, 小
- 符号表只存在于编译阶段, 符号表的每一项分别对应变量名和变量地址, 但是`C++`对变量名不作存储，在汇编以后不会出现变量名，变量名作用只是用于方便编译成汇编代码，是给编译器看的，是方便人阅读的

## 124、为什么会有大端小端，`htol` 这一类函数的作用
- 计算机以字节为基本单位进行管理, 每个地址单元都对应着一个字节，一个字节为`8bit`。但是我们常用到大于一个字节的数据类型, 例如`short`, `int`, `float`等, 此时就会存在字节如何放置的问题, 从而出现了大端模式和小端模式. 
- 大端: 低字节放于高地址处(网络字节序为大端)
- 小端: 低字节放于低地址处(通常主机字节序为小端)

- 例如(`16bit` 的`short型 x`)
	- 在内存中的地址为`0x0010`，`x`的值为`0x1122`，那么`0x11` 为高字节，`0x22` 为低字节。
	- 对于大端模式，就将`0x11` 放在低地址中，即`0x0010` 中，`0x22` 放在高地址中，即`0x0011` 中。小端模式，刚好相反。

## 125、静态函数能定义为虚函数吗？常函数?
- 不能 !
	- `static`成员不属于任何类对象或类实例，没有this指针(静态与非静态成员函数的一个主要区别)。
	- 虚函数调用链为: `vptr` -> `vtable` -> `virtual function`
	- 但是访问`vptr`需要使用`this`指针但是`static`成员函数没有`this`指针, 从而无法实现虚函数的调用
	
	
***
	- 虚函数依靠`vptr` 和`vtable` 来处理。`vptr` 是一个指针，在类的构造函数中创建生成，并且只能用`this` 指针来访问它，因为它是类的一个成员，并且`vptr` 指向保存虚函数地址的`vtable.`对于静态成员函数，它没有`this`指针，所以无法访问`vptr.` 这就是为何`static` 函数不能为`virtual.`虚函数的调用关系：`this` -> `vtable` -> `virtual function`

## 126、`this` 指针调用成员变量时，堆栈会发生什么变化？
- 当我们在类中定义非静态成员函数时, 编译器会为此成员函数添加一个参数(最后一个形参), 类型为当前类型的指针
- 当我们进行通过对象或则对象指针调用此成员函数时, 编译器会自动将对象的地址传给作为隐含参数传递给函数，这个隐含参数就是`this`指针。即使你并没有写`this` 指针，编译器在链接时也会加上`this` 的，对各成员的访问都是通过`this` 的。
- 函数调用时, `this`指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。

## 127、**静态绑定**和**动态绑定**的介绍
- 对象的静态类型：**对象在声明时采用的类型**。是在编译期确定的。
- 对象的动态类型：**目前所指对象的类型**。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。

- 静态绑定：绑定的是对象的静态类型，某特性(比如函数)依赖于对象的静态类型，发生在编译期。
- 动态绑定：绑定的是对象的动态类型，某特性(比如函数)依赖于对象的动态类型，发生在运行期。

## 128、设计一个类计算子类的个数
- 为类设计一个`static` 静态变量`count` 作为计数器；
- 类定义结束后初始化`count`;
- 在构造函数中对`count` 进行`+1`;
- 设计拷贝构造函数，在进行拷贝构造函数中进行`count +1`，操作；
- 设计复制构造函数，在进行复制函数中对`count+1` 操作；
- 在析构函数中对`count` 进行`-1`；

## 129、怎么快速定位错误出现的地方
- 如果是简单错误, 通常可以分析编译器辗转解栈过程, 定位到输出位置, 通常都是解栈的靠后位置
- 如果错误较复杂, 就最好使用gdb调试模式, 进行调试, 逐步定位错误位置, 或者添加更多的输出信息.

## 130、虚函数的代价？
	1) 带有虚函数的类，每一个类会产生一个虚函数表，用来存储指向虚成员函数的指针，增大类；
1) 带有虚函数的类的每一个对象，都会有有一个指向虚表的指针，会增加对象的空间大小；
2) **不能再是内敛的函数**，因为内敛函数在编译阶段进行替代，而虚函数表示等待，在运行阶段才能确定到低是采用哪种函数，虚函数不能是内敛函数。

## 131、类对象的大小
1) 类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；
2) 内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；
3) 当该该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展。
4) 虚函数的话，会在类对象插入vptr 指针，加上指针大小；
5) 如果是虚拟继承而来的话, 还会存在一个虚基类表指针, 不同的编译器对这个虚基类指针的处理是不一样的, gcc是存放在虚函数表中(意味着虚函数表指针和虚基类表指针只会存在一个), vc是存放在对象中的(意味着可能会虚函数表指针和虚基类表指针共存)

## 132、移动构造函数
- 移动构造函数是C++11中引入的移动语义的具体实现. 它的主要目的是避免无谓的构造和析构
- 例如: 当我们用右值初始化一个左值时, 通常是使用复制构造函数构造左值,然后对右值调用析构函数, 此时存在大量的浪费. 而且复制构造函数对于指针通常是浅复制, 容易产生野指针.
- 移动构造函数的参数为右值引用, 它的作用就是将此右值的内容**转移**到左值内, 从而避免右值调用构造函数. 也避免了左值分配内存进行构造. 
	```cpp
	Example6 (Example6&& x):ptr(x.ptr){
		x.ptr = nullptr;
	}
	// move assignment
	Example6& operator= (Example6&& x){
		delete ptr;
		ptr = x.ptr;
		x.ptr=nullptr;
		return *this;
	}
	```

## 133、何时需要合成构造函数
- 如果一个类没有构造函数，一共四种情况会合成构造函数:
	- **存在虚函数**的情况
	- **存在虚基类**的情况
	- **基类成员**存在构造函数的情况
	- **对象成员对象**存在构造函数的情况

## 134、何时需要合成复制构造函数
- 有三种情况会以一个对象的内容作为另一个对象的初值：
	1) 对一个对象做显示的初始化操作，`X xx = x;`
	2) 当对象被当做参数交给某个函数时；
	3) 当函数传回一个类对象时；

- 如果一个类没有拷贝构造函数，合成复制构造函数的情况:
	- 成员对象有拷贝构造函数
	- 基类拷贝构造函数
	- 存在虚函数
	- 存在虚基类

## 135、何时需要成员初始化列表？过程是什么？
- 需要成员初始化列表:
	- 引用类型的成员变量
	- const类型的成员变量
	- 基类不存在零参数构造函数
	- 成员对象不存在零参数构造函数
- 过程: 
	- 编译器会根据成员变量定义顺序一一初始化成员变量, 如果相应成员在成员初始化列表中有初始化参数, 则用成员初始化列表中的参数进行构造
	- 发生在用户自定义代码段之前. 

## 136、程序员定义的析构函数被扩展的过程？
- 析构函数的执行顺序(和构造相反):
	- 析构函数函数体被执行
	- 本类的成员对象析构函数被调用, 调用顺序和声明的顺序相反
	- 非虚基类拥有析构函数，会以声明的相反顺序被调用；
	- 虚基类被析构


***
- 参考: [C++虚基类构造函数详解(调用顺序)之一](https://www.cnblogs.com/haoyuanyuan/archive/2013/04/25/3041250.html)

***

## 137、构造函数的执行算法？
- 扩展过程:
	- 虚基类按照定义顺序被构造
	- 基类按照定义顺序被构造
	- 成员变量被构造
	- 执行程序员所提供的代码

- 一个类被构造的执行过程:
	- 虚基类按照定义顺序被构造
	- 基类按照定义顺序被构造
	- 然后是按照定义顺序构造成员变量, 如果某个成员在初始化成员变量列表内存在初始化参数, 则调用初始化成员变量列表内的参数初始化该成员变量
	- 然后是执行构造函数函数体内用户提供的代码.
- 注意事项:
	- 在构造函数函数体内的对虚函数的调用将不具备动态绑定的特性

***
- 参考:
	- [C++ 构造函数执行原理](https://blog.csdn.net/qingdujun/article/details/26626605)
	- [构造函数和析构函数中可以调用调用虚函数吗](https://www.cnblogs.com/sylar5/p/11523992.html)

***

## 138、构造函数的扩展过程？
- 虚基类按照定义顺序被构造
- 基类按照定义顺序被构造
- 成员变量被构造
- 执行程序员所提供的代码

***
- 参考: [构造函数和析构函数中可以调用调用虚函数吗](https://www.cnblogs.com/sylar5/p/11523992.html)

***

## 139、哪些函数不能是虚函数
- 构造函数: 首先是没必要使用虚函数, 其次不能使用虚函数
- 内联函数: 表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；
- 静态函数: 静态函数不属于对象属于类，静态成员函数没有this 指针，因此静态函数设置为虚函数没有任何意义。
- 友元函数: 友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。
- 普通函数: 普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。


***
- 参考: [19. 构造函数为什么不能为虚函数？析构函数为什么要虚函数？](#19%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e8%83%bd%e4%b8%ba%e8%99%9a%e5%87%bd%e6%95%b0%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e8%99%9a%e5%87%bd%e6%95%b0)

***

## 140. `sizeof` 和`strlen` 的区别
- `sizeof` 是一个**取字节运算符**，计算变量所占的内存数(字节大小), 可以用于任意类型
- `strlen` 是个**函数**, 计算字符串的具体长度(只能是字符串)，不包括字符串结束符(`\0`)。
- `strlen` 是个不安全的函数, 如果没有`\0`将会发生段错误。
- `sizeof`和`strlen`对同一个字符串求值, 结果差一.
- 数组做`sizeof` 的参数不退化，传递给`strlen`就退化为指针；

## 141、简述`strcpy`、`sprintf` 与`memcpy` 的区别
- 复制操作: `strcpy`, `memcpy`
	- 复制类容不一样: `strcpy`是用于复制字符串的, 不能用去其他类型, 而`memcpy`是用于复制任意类型的数据类型
	- 复制防止不一样: `strcpy`是通过检测支付中的`\0`判断结束的, 存在溢出风险`(strncpy)`; 而`memcpy`是需要指定复制的字节数的.
- 字符串格式化: `sprintf`
	- 将格式化的数据写入字符串中
	- 注意`sprintf`对写入字符串没有限制大小, 也就存在溢出风险, 建议采用`snprintf`

## 142、编码实现某一变量某位清`0` 或置`1`
```cpp
#define BIT3 (0x1 << 3 ) Satic int a;
//设置a 的bit 3:
void set_bit3( void ){
	a |= BIT3; //将a 第3 位置1
}
//清a 的bit 3
void set_bit3( void ){
	a &= ~BIT3; //将a 第3 位清零
}
```

## 143、将“引用”作为函数参数有哪些特点？
1) 传递引用给函数与传递指针的效果是一样的。
	1) 这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象(在主调函数中)的操作。
2) 使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；
	1) 而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；
	2) 如果传递的是对象，还将调用拷贝构造函数。
	3) 因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。
3) 使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较差；
	1) 另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。


***
- 引用传递 从逻辑上就好像是对主调函数中的实参取了一个别名, 在被调函数中对该别名的任何操作都会反应在主调函数中, 实际的实现过程中, 传递的其实是对象的地址, 和指针传递相似, 区别在于对该引用的任何操作都会被处理为间接寻址
- 引用传递 并没有对`对象`进行拷贝, 只是对指针进行了拷贝, 避免了对`对象`的复制, 效率更高.
- 引用传递 逻辑上相当于对主调函数中的实参取了一个别名, 阅读性更好.

***

## 144、分别写出`BOOL`,`int`,`float`, 指针类型的变量`a` 与“零”的比较语句。
```cpp
BOOL : if ( !a ) or if(a)
int : if ( a == 0)
float : const EXPRESSION EXP = 0.000001 // 1.0e-10 浮点数有精度限制, 所以只能通过阈值来判断是否相等
if ( a < EXP && a >-EXP)
pointer : if ( a != NULL) or if(a == NULL)
```

## 145、局部变量全局变量的问题？
- 局部会屏蔽全局。
	- 要用全局变量，需要使用"::", 局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。
	- 对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内。
- 如何引用一个已经定义过的全局变量，可以用引用头文件的方式，也可以用`extern`关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用`extern` 方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。
- 全局变量可不可以定义在可被多个`.C` 文件包含的头文件中，在不同的`C` 文件中以`static` 形式来声明同名全局变量。可以在不同的`C` 文件中声明同名的全局变量，前提是其中只能有一个`C` 文件中对此变量赋初值，此时连接不会出错


***
- 局部屏蔽全局
- 引用另一个文件中的变量, 使用`extern`关键字, 或则引用头文件
- 全局变量冲突

***

## 146、数组和指针的区别？
- 对数组使用`sizeof`操作符可以计算出数组的容量(字节数). 对指针使用`sizeof`操作符得到的是一个指针变量的字节数，而不是`p` 所指的内存容量。
- 编译器为了简化对数组的支持，实际上是利用指针实现了对数组的支持。具体来说，就是将表达式中的数组元素引用转换为指针加偏移量的引用。
- 在向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针。也就是传递过去是数组的首地址而不是整个数组，能够提高效率；
- 在使用下标的时候，两者的用法相同，都是原地址加上下标值，不过数组的原地址就是数组首元素的地址是固定的，指针的原地址就不是固定的。


***

- 数组作为`sizeof`参数时, 不会退化
- 数组在内存中是连续存放的，开辟一块连续的内存空间；
	- 数组所占存储空间：`sizeof(`数组名)；
	- 数组大小：`sizeof(`数组名`)/sizeof(`数组元素数据类型)；
- 指针也可以使用下标, 表示指针指向地址`+`偏移
	- 参考: [C语言指针变量加下标的作用意思意义](https://blog.csdn.net/qianxuedegushi/article/details/81699033)

***

## 147、C++如何阻止一个类被实例化？一般在什么时候将构造函数声明为private？
1) 将类定义为`抽象基类`或者将`构造函`数声明为`private`；
2) 不允许类外部创建类对象(也就是杜绝了静态构建的可能性)，只能在类内部创建对象(成员函数通过`new`构建)

## 148、如何禁止自动生成拷贝构造函数？
1) 为了阻止编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动去重写这两个函数，某些情况下，为了避免调用拷贝构造函数和拷贝赋值函数，我们需要将他们设置成private，防止被调用。
2) 类的成员函数和friend 函数还是可以调用private 函数，如果这个private 函数只声明不定义，则会产生一个连接错误；
3) 针对上述两种情况，我们可以定一个base 类，在base 类中将拷贝构造函数和拷贝赋值函数设置成private,那么派生类中编译器将不会自动生成这两个函数，且由于base 类中该函数是私有的，因此，派生类将阻止编译器执行相关的操作。

- 参考: [高效C++; 条款6：阻止编译器自动生成拷贝构造函数和赋值函数](https://blog.csdn.net/qq_29422251/article/details/77850312)


***
1) 拷贝构造函数的定义后面使用 `=delete`关键字
2) 将`base`类的拷贝构造函数和拷贝赋值构造函数设置为`private`, 这样编译器就不会自动生成这两个函数, 且由于`base`类的该函数为`private`, 所以编译器会阻止相关操作. 

## 149、`assert` 与`NDEBUG`
1) `assert` 宏的原型定义在`<assert.h>`中，其作用是如果它的条件返回错误，则终止程序执行，原型定义：
	```c
	#include <assert.h>
	void assert( int expression );
	```
	- `assert` 的作用是计算表达式`expression` ，如果其值为假(即为`0`)，那么它先向`stderr` 打印一条出错信息，然后通过调用`abort` 来终止程序运行。如果表达式为真，`assert` 什么也不做。
2) `NDEBUG` 宏是`Standard C` 中定义的宏，专门用来控制`assert()`的行为。
	- 如果定义了这个宏，则`assert` 不会起作用。
	- 定义`NDEBUG` 能避免检查各种条件所需的运行时开销，当然此时根本就不会执行运行时检查。

## 150、`Debug` 和`release` 的区别
1) 调试版本，包含调试信息
	- `体积`比`Release` 大很多，并且`不进行任何优化`(优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂)，便于程序员调试。
	- `Debug` 模式下生成两个文件，除了`.exe` 或`.dll` 文件外，还有一个`.pdb` 文件，该文件记录了代码中断点等调试信息；
3) 发布版本，不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的。(调试信息可在单独的`PDB` 文件中生成)。`Release` 模式下生成一个文件`.exe` 或`.dll` 文件。
4) 实际上，`Debug` 和`Release` 并没有本质的界限，他们只是一组编译选项的集合，编译器只是按照预定的选项行动。事实上，我们甚至可以修改这些选项，从而得到优化过的调试版本或是带跟踪语句的发布版本。

## 151、`main` 函数有没有返回值
1) 程序运行过程入口点`main`函数，`main()`函数返回值类型必须是`int`，这样返回值才能传递给程序激活者(如操作系统)表示程序正常退出。
2) `main(int args, char**argv)`参数的传递。参数的处理，一般会调用`getopt()`函数处理，但实践中，这仅仅是一部分，不会经常用到的技能点。
3) `main`函数事调用用户代码逻辑的接口有着固有的规范(或则逻辑):
	- 返回值: `int` 程序退出状态
	- 参数: 用于传递到用户代码中
		- `int args`: 参数个数
		- `char** argv`: 参数以字符串的形式储存, 然后将字符串首地址组成指针数组作为参数进行传递.


***
- 参考: [命令行选项解析函数(C语言)：getopt()和getopt_long()](https://www.cnblogs.com/chenliyang/p/6633739.html)

***

## 152、写一个比较大小的模板函数
```cpp
#include<iostream>
using namespace std;
template<typename type1,typename type2>//函数模板
type1 Max(type1 a,type2 b){
	return a > b ? a : b;
}
void main(){
	cout<<"Max = "<<Max(5.5,'a')<<endl;
}
```

## 153、`c++`怎么实现一个函数先于main 函数运行
1) 全局对象/全局静态变量的生存期和作用域都高于`mian`函数, 在`main`函数之前初始化
	```cpp
	class simpleClass{
	public:
		simpleClass( ){
			cout << "simpleClass constructor.." << endl;
		}
	};
	simpleClass g_objectSimple; //step1 全局对象
	int _tmain(int argc, _TCHAR* argv[]) { //step3
		return 0;
	}
	```
2) GCC编译器可以使用`__attribute((constructor/deconstrucor))`在`main`**之前**和**之后**注册函数
	```cpp
	// 在main之前
	__attribute((constructor)) void before_main(){
		printf("befor\n");
	}
	// 在main之后
	__attribute((deconstructor)) void after_main(){
		printf("befor\n");
	}
	```


***
- 附加
	- `Main` 函数执行之前，主要就是初始化系统相关资源；
		- 设置栈指针
		- 初始化`static` 静态和`global` 全局变量，即`data` 段的内容
		- 将未初始化部分的全局变量赋初值(即`.bss` 段的内容)：
			- 数值型`short`，`int`，`long`等为`0`，
			- `bool` 为`FALSE`
			- 指针为`NULL`
		- 全局对象初始化，在`main` 之前调用构造函数
		- 将`main` 函数的参数，`argc`，`argv`等传递给`main`函数，然后才真正运行`main`函数
	- `Main` 函数执行之后
		- 全局对象的析构函数会在`main`函数之后执行；
		- 可以用`_onexit`注册一个函数，它会在`main`之后执行;
- 参考: 
	- [在main()之前执行前运行](https://blog.csdn.net/zzxiaozhao/article/details/102604626#main_228)
	- [C++中_onexit()用法简述](https://blog.csdn.net/cafuc46wingw/article/details/38587473)

***

## 154、虚函数与纯虚函数的区别在于
1) 纯虚函数只有定义没有实现，虚函数既有定义又有实现；
2) 含有纯虚函数的类不能定义对象，含有虚函数的类能定义对象；

## 155、智能指针怎么用？智能指针出现循环引用怎么解决？
1) `unique_ptr`: 独占式拥有一个对象, 当`unique_ptr`被销毁时，它所指向的对象也被销毁。

2) `shared_ptr`: 
	- 初始化:
		- `shared_ptr<int> p =make_shared<int>(42);`
		- 通常用`auto`更方便，`auto p =make_shared<int>(42);`
		- `shared_ptr<int> p2(new int(2));`
	- 每个`shared_ptr`都有一个关联的计数器，通常称为引用计数，一旦一个`shared_ptr`的计数器变为`0`，它就会自动释放自己所管理的对象；
	- `shared_ptr`的析构函数就会递减它所指的对象的引用计数。
	- 如果引用计数变为`0`，`shared_ptr` 的析构函数就会销毁对象，并释放它占用的内存。
3) `weak_ptr`:是一种不控制所指向对象生存期的智能指针，它指向由一个`shared_ptr`管理的对象，将一个`weak_ptr` 绑定到一个`shared_ptr` 不会改变引用计数，一旦最后一个指向对象的`shared_ptr` 被销毁，对象就会被释放，即使有`weak_ptr` 指向对象，对象还是会被释放。

4) 弱指针用于专门解决`shared_ptr` 循环引用的问题，`weak_ptr` 不会修改引用计数，即其存在与否并不影响对象的引用计数器。循环引用就是：两个对象互相使用一个`shared_ptr` 成员变量指向对方。弱引用并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。

## 156、`strcpy` 函数和`strncpy` 函数的区别？哪个函数更安全？
1) 函数原型
	```c
	char* strcpy(char* strDest, const char* strSrc)
	char* strncpy(char* strDest, const char* strSrc, int pos)
	```
2) `strcpy` 函数: 
	- 如果参数`dest` 所指的内存空间不够大，可能会造成缓冲溢出`(bufferOverflow)`的错误情况，在编写程序时请特别留意，或者用`strncpy()`来取代。
	- `strncpy` 函数：用来复制源字符串的前`n` 个字符，`src` 和`dest` 所指的内存区域不能重叠，且`dest` 必须有足够的空间放置`n` 个字符。
4) 长度关系:
	- 如果`目标长`>`指定长`>`源长`，则将源长全部拷贝到目标长，自动加上`\0`; 
	- 如果`指定长`<`源长`，则将源长中按指定长度拷贝到目标字符串，不包括`\0`; 
	- 如果`指定长`>`目标长`，运行时错误；

## 157、为什么要用`static_cast`转换而不用`c`语言中的转换？
1) 更加安全；
2) 更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误；
	- 可清楚地辨别代码中每个显式的强制转；
	- 可读性更好，能体现程序员的意图

## 158、成员函数里`memset(this,0,sizeof(*this))`会发生什么
1) 如果类中的所有成员都是内置的数据类型的, 则不会存在问题
2) 如果有以下情况之一会出现问题:
	- 存在对象成员
	- 存在虚函数/虚基类
	- 如果在构造函数中分配了堆内存, 而此操作可能会产生内存泄漏

## 159、方法调用的原理(栈，汇编)
- 每一个函数都对应一个栈帧: 
	- 帧栈可以认为是程序栈的一段
	- 它有两个端点
		- 一个标识起始地址, 开始地址指针ebp;
		- 一个标识着结束地址，结束地址指针esp;
- 函数调用使用的参数, 返回地址等都是通过栈来传递的.
- 函数调用过程:
	- 参数逆序入栈(主调函数)
	- 返回地址入栈(主调函数)(被调函数栈底往上4个子节为返回地址)
	
		
***
	- 主调函数栈底入栈(被调函数)
	- 栈顶给栈底赋值(被调函数)
	- 被调函数局部变量...

	- 被调函数局部变量析构
	- 恢复主调函数栈帧
	- 获取返回地址, 继续执行主调函数代码
	- 关于返回值: 
		- 如果 `返回值 <= 4字节`，则返回值通过寄存器`eax`带回。
		- 如果 `4< 返回值 <=8字节`，则返回值通过两个寄存器`eax`和`edx`带回。
		- 如果 `返回值 > 8字节`，则返回值通过产生的临时量带回。
		
		
***
4) 过程调用和返回指令
	- `call` 指令
	- `leave` 指令
	- `ret` 指令

## 160、`MFC`消息处理如何封装的？

## 161、回调函数的作用
- 回调函数一般可以分为两个类型:
- 中断处理函数
	- 当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数；
	- 此时回调函数就相当于是中断处理函数, 由系统在符合你设定的条件时自动调用。
	- 为此我们需要进行
		- 函数声明
		- 函数定义
		- 设置中断触发, 就是把回调函数名称转化为地址作为一个参数，以便于系统调用；
- 通过函数指针调用的函数
	- 如果函数的指针(地址)作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；
	- 因为可以把调用者与被调用者分开。调用者只需要确定被调函数是一个具有特定参数列表和特定返回值的函数, 而不需要知道具体是哪个函数被调用.

## 162、随机数的生成
```cpp
#include<time.h> 
srand((unsigned)time(NULL)); 
cout<<(rand()%(b-a))+a;
```
- 由于`rand()`的内部实现是用线性同余法做的，所以生成的并不是真正的随机数，而是在一定范围内可看为随机的伪随机数。
- 种子写为`srand(time(0))`代表着获取系统时间，电脑右下角的时间，每一秒后系统时间的改变，数字序列的改变得到的数字

## 164、C++临时对象产生的时机
- 为了使函数调用成功而进行隐式类型转换的时候。
	- 传值方式
	- const 引用传递(!!!!)
- 当函数返回对象的时候。
- 参考: [转：C++中临时对象及返回值优化](https://www.cnblogs.com/xkfz007/articles/2506022.html)




# 结束














